<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>微分IK | Blog</title><meta name=keywords content><meta name=description content="微分 IK（Differential IK）与 Adjoint：从最小二乘到坐标系变换的一条线

这篇文章把一次完整的推导链条拼起来：
微分 IK在算什么 → 最小二乘 / 最小范数为何同时出现 → 伪逆在列满秩/行满秩下如何推导 → **阻尼最小二乘（DLS）**作为优化问题的闭式解 → 为什么 Jacobian 必须用 Adjoint 做坐标系变换 → Adjoint 本身如何从“刚体上不同点速度不同”推导出来。
读者假设：线性代数、最小二乘、一阶条件、正交投影。


1. 微分 IK 在解决什么问题？
经典 IK 是“给末端位姿，求关节角”：

  
$
x = f(q),\quad \text{给定 }x_d\Rightarrow \text{求 }q
$



微分 IK 把问题改成“给末端瞬时速度/误差变化率，求关节速度”：

  
$
\dot{x} = J(q)\,\dot{q}
$



离散实现通常是：

  
$
q_{k+1}=q_k+\dot{q}\,\Delta t
$



其中 $J(q)$ 是 Jacobian，作为线性映射：

  
$
J:\;\dot{q}\mapsto \text{twist（末端瞬时运动）}
$




2. Jacobian 与 twist：输出不是“普通向量”，而是“有坐标系”的速度
在 3D 刚体运动里，常用 6 维 twist 表示瞬时运动："><meta name=author content><link rel=canonical href=https://analyst-huang.github.io/posts/math/differential_ik_adjoint_blog/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://analyst-huang.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://analyst-huang.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://analyst-huang.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://analyst-huang.github.io/apple-touch-icon.png><link rel=mask-icon href=https://analyst-huang.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://analyst-huang.github.io/posts/math/differential_ik_adjoint_blog/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,packages:{"[+]":["ams"]}},options:{skipHtmlTags:["script","noscript","style","textarea","pre","code"]}}</script><script defer src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta property="og:url" content="https://analyst-huang.github.io/posts/math/differential_ik_adjoint_blog/"><meta property="og:site_name" content="Blog"><meta property="og:title" content="微分IK"><meta property="og:description" content="微分 IK（Differential IK）与 Adjoint：从最小二乘到坐标系变换的一条线 这篇文章把一次完整的推导链条拼起来：
微分 IK在算什么 → 最小二乘 / 最小范数为何同时出现 → 伪逆在列满秩/行满秩下如何推导 → **阻尼最小二乘（DLS）**作为优化问题的闭式解 → 为什么 Jacobian 必须用 Adjoint 做坐标系变换 → Adjoint 本身如何从“刚体上不同点速度不同”推导出来。
读者假设：线性代数、最小二乘、一阶条件、正交投影。
1. 微分 IK 在解决什么问题？ 经典 IK 是“给末端位姿，求关节角”：
$ x = f(q),\quad \text{给定 }x_d\Rightarrow \text{求 }q $ 微分 IK 把问题改成“给末端瞬时速度/误差变化率，求关节速度”：
$ \dot{x} = J(q)\,\dot{q} $ 离散实现通常是：
$ q_{k+1}=q_k+\dot{q}\,\Delta t $ 其中 $J(q)$ 是 Jacobian，作为线性映射：
$ J:\;\dot{q}\mapsto \text{twist（末端瞬时运动）} $ 2. Jacobian 与 twist：输出不是“普通向量”，而是“有坐标系”的速度 在 3D 刚体运动里，常用 6 维 twist 表示瞬时运动："><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-30T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-30T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="微分IK"><meta name=twitter:description content="微分 IK（Differential IK）与 Adjoint：从最小二乘到坐标系变换的一条线

这篇文章把一次完整的推导链条拼起来：
微分 IK在算什么 → 最小二乘 / 最小范数为何同时出现 → 伪逆在列满秩/行满秩下如何推导 → **阻尼最小二乘（DLS）**作为优化问题的闭式解 → 为什么 Jacobian 必须用 Adjoint 做坐标系变换 → Adjoint 本身如何从“刚体上不同点速度不同”推导出来。
读者假设：线性代数、最小二乘、一阶条件、正交投影。


1. 微分 IK 在解决什么问题？
经典 IK 是“给末端位姿，求关节角”：

  
$
x = f(q),\quad \text{给定 }x_d\Rightarrow \text{求 }q
$



微分 IK 把问题改成“给末端瞬时速度/误差变化率，求关节速度”：

  
$
\dot{x} = J(q)\,\dot{q}
$



离散实现通常是：

  
$
q_{k+1}=q_k+\dot{q}\,\Delta t
$



其中 $J(q)$ 是 Jacobian，作为线性映射：

  
$
J:\;\dot{q}\mapsto \text{twist（末端瞬时运动）}
$




2. Jacobian 与 twist：输出不是“普通向量”，而是“有坐标系”的速度
在 3D 刚体运动里，常用 6 维 twist 表示瞬时运动："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://analyst-huang.github.io/posts/"},{"@type":"ListItem","position":2,"name":"微分IK","item":"https://analyst-huang.github.io/posts/math/differential_ik_adjoint_blog/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"微分IK","name":"微分IK","description":"微分 IK（Differential IK）与 Adjoint：从最小二乘到坐标系变换的一条线 这篇文章把一次完整的推导链条拼起来：\n微分 IK在算什么 → 最小二乘 / 最小范数为何同时出现 → 伪逆在列满秩/行满秩下如何推导 → **阻尼最小二乘（DLS）**作为优化问题的闭式解 → 为什么 Jacobian 必须用 Adjoint 做坐标系变换 → Adjoint 本身如何从“刚体上不同点速度不同”推导出来。\n读者假设：线性代数、最小二乘、一阶条件、正交投影。\n1. 微分 IK 在解决什么问题？ 经典 IK 是“给末端位姿，求关节角”：\n$ x = f(q),\\quad \\text{给定 }x_d\\Rightarrow \\text{求 }q $ 微分 IK 把问题改成“给末端瞬时速度/误差变化率，求关节速度”：\n$ \\dot{x} = J(q)\\,\\dot{q} $ 离散实现通常是：\n$ q_{k+1}=q_k+\\dot{q}\\,\\Delta t $ 其中 $J(q)$ 是 Jacobian，作为线性映射：\n$ J:\\;\\dot{q}\\mapsto \\text{twist（末端瞬时运动）} $ 2. Jacobian 与 twist：输出不是“普通向量”，而是“有坐标系”的速度 在 3D 刚体运动里，常用 6 维 twist 表示瞬时运动：\n","keywords":[],"articleBody":"微分 IK（Differential IK）与 Adjoint：从最小二乘到坐标系变换的一条线 这篇文章把一次完整的推导链条拼起来：\n微分 IK在算什么 → 最小二乘 / 最小范数为何同时出现 → 伪逆在列满秩/行满秩下如何推导 → **阻尼最小二乘（DLS）**作为优化问题的闭式解 → 为什么 Jacobian 必须用 Adjoint 做坐标系变换 → Adjoint 本身如何从“刚体上不同点速度不同”推导出来。\n读者假设：线性代数、最小二乘、一阶条件、正交投影。\n1. 微分 IK 在解决什么问题？ 经典 IK 是“给末端位姿，求关节角”：\n$ x = f(q),\\quad \\text{给定 }x_d\\Rightarrow \\text{求 }q $ 微分 IK 把问题改成“给末端瞬时速度/误差变化率，求关节速度”：\n$ \\dot{x} = J(q)\\,\\dot{q} $ 离散实现通常是：\n$ q_{k+1}=q_k+\\dot{q}\\,\\Delta t $ 其中 $J(q)$ 是 Jacobian，作为线性映射：\n$ J:\\;\\dot{q}\\mapsto \\text{twist（末端瞬时运动）} $ 2. Jacobian 与 twist：输出不是“普通向量”，而是“有坐标系”的速度 在 3D 刚体运动里，常用 6 维 twist 表示瞬时运动：\n$ V = \\begin{bmatrix} \\omega\\\\ v \\end{bmatrix} \\in\\mathbb{R}^6 $ $\\omega$：角速度 $v$：某个参考点（reference point）的线速度 关键点：twist 的数值依赖你在哪个坐标系表达、以及线速度对应哪个参考点。\n因此 Jacobian 也隐含了“输出 twist 的坐标系”这一选择。\n3. 微分 IK 的核心：线性最小二乘 +（必要时）最小范数 从\n$ J\\dot{q}=\\dot{x} $ 出发，真实世界里会遇到：\n$J$ 非方阵（任务维度 $m$ 与关节维度 $n$ 不相等） 可能超定/欠定 可能奇异（秩不足） 因此更稳健的表述是：\n3.1 最小二乘误差（projection / normal equation） $ \\dot{q}^*=\\arg\\min_{\\dot{q}}\\;\\|J\\dot{q}-\\dot{x}\\|_2^2 $ 一阶条件（法方程）： $ J^T(J\\dot{q}-\\dot{x})=0 $ 这会把残差 $r=\\dot{x}-J\\dot{q}$ 逼到 $ r\\perp \\mathrm{Im}(J) $ 即把 $\\dot{x}$ 正交投影到 $\\mathrm{Im}(J)$。\n3.2 为什么还需要“最小范数”？ 当解不唯一时（典型：欠定、冗余机器人），仅靠最小二乘条件无法选出唯一解。\n此时常用 最小范数 作为二级准则：\n$ \\boxed{ \\min_{\\dot{q}}\\;\\|\\dot{q}\\|_2 \\quad \\text{s.t.}\\quad J\\dot{q}=\\dot{x}\\;\\;(\\text{若可行}) } $ 最终得到 Moore–Penrose 伪逆解： $ \\dot{q}=J^\\dagger \\dot{x} $ 4. 伪逆在两种满秩情形下的推导（列满秩 vs 行满秩） 设 $J\\in\\mathbb{R}^{m\\times n}$。\n4.1 列满秩（column full rank）：$m\\ge n,\\ \\mathrm{rank}(J)=n$ 这是“超定最小二乘”的典型情形。\n目标： $ \\min_{\\dot{q}}\\;\\|J\\dot{q}-\\dot{x}\\|^2 $ 一阶条件： $ J^T(J\\dot{q}-\\dot{x})=0 \\Rightarrow (J^T J)\\dot{q}=J^T\\dot{x} $ 列满秩保证 $J^T J$ 可逆，因此解唯一： $ \\boxed{ \\dot{q}=(J^T J)^{-1}J^T\\dot{x} } $ 4.2 行满秩（row full rank）：$m 这是“欠定但可实现”的典型情形。此时 $\\mathrm{Im}(J)=\\mathbb{R}^m$，任意 $\\dot{x}$ 都可满足： $ J\\dot{q}=\\dot{x} $ 但解不唯一（存在零空间）。因此最小二乘误差可以做到 0，问题退化成最小范数约束问题：\n$ \\min_{\\dot{q}}\\;\\|\\dot{q}\\|^2 \\quad \\text{s.t.}\\quad J\\dot{q}=\\dot{x} $ 步骤 1：刻画所有可行解\n取任意特解 $\\dot{q}_0$，所有可行解： $ \\dot{q}=\\dot{q}_0+z,\\quad z\\in\\ker(J) $ 步骤 2：最小范数条件给出正交性\n$ \\|\\dot{q}_0+z\\|^2=\\|\\dot{q}_0\\|^2+2\\langle \\dot{q}_0,z\\rangle+\\|z\\|^2 $ 要在 $z\\in\\ker(J)$ 上最小，必须 $ \\dot{q}_0\\perp\\ker(J) $ 利用基本关系： $ \\ker(J)^\\perp=\\mathrm{Im}(J^T) $ 因此最小范数解必在 $\\mathrm{Im}(J^T)$ 中，可写为 $ \\dot{q}=J^T\\lambda $ 步骤 3：代回约束并解出 $\\lambda$\n$ J\\dot{q}=JJ^T\\lambda=\\dot{x} $ 行满秩保证 $JJ^T$ 可逆： $ \\lambda=(JJ^T)^{-1}\\dot{x} $ 得到 $ \\boxed{ \\dot{q}=J^T(JJ^T)^{-1}\\dot{x} } $ 这一推导的关键不是“法方程”，而是“最小范数 ⇔ 与零空间正交 ⇔ 落在 $\\mathrm{Im}(J^T)$”。\n5. 阻尼最小二乘（DLS / Levenberg–Marquardt）= 一个优化问题的闭式解 伪逆在奇异附近会导致 $\\dot{q}$ 爆炸。工程上常用 DLS，把问题改写为：\n$ \\boxed{ \\dot{q}^*=\\arg\\min_{\\dot{q}}\\;\\|J\\dot{q}-\\dot{x}\\|^2+\\lambda^2\\|\\dot{q}\\|^2 } $ 对 $\\dot{q}$ 求导并令零： $ 2J^T(J\\dot{q}-\\dot{x})+2\\lambda^2\\dot{q}=0 \\Rightarrow (J^T J+\\lambda^2 I)\\dot{q}=J^T\\dot{x} $ 闭式解： $ \\boxed{ \\dot{q}=(J^T J+\\lambda^2 I)^{-1}J^T\\dot{x} } $ 常见等价形式（当你想逆 $m\\times m$ 而不是 $n\\times n$ 时更划算）： $ \\boxed{ \\dot{q}=J^T(JJ^T+\\lambda^2 I)^{-1}\\dot{x} } $ 且恒等式成立（$\\lambda\u003e0$）： $ (J^T J + \\lambda^2 I)^{-1}J^T = J^T(JJ^T+\\lambda^2 I)^{-1} $ 5.1 为什么 $(J^T J+\\lambda^2 I)$ 一定可逆？ 当 $\\lambda\u003e0$： $ v^T(J^T J+\\lambda^2 I)v = \\|Jv\\|^2+\\lambda^2\\|v\\|^2\u003e0\\quad(\\forall v\\ne 0) $ 因此它是对称正定矩阵，必可逆。\n直觉：把奇异值平方 $\\sigma_i^2$ 变成 $\\sigma_i^2+\\lambda^2$，零也被抬起来。\n6. 冗余与零空间（Null Space）项：把“多余自由度”变成二级目标 当 $n\u003em$ 时（冗余机器人），满足同一任务的 $\\dot{q}$ 不唯一。通解可以写成：\n$ \\boxed{ \\dot{q}=J^\\dagger \\dot{x} + (I-J^\\dagger J)\\,z } $ $J^\\dagger \\dot{x}$：完成主任务（最小二乘/最小范数意义） $(I-J^\\dagger J)$：投影到 $\\ker(J)$ 的算子 $z$：二级目标（避限、最小能量、姿态偏好等） 7. 为什么 Jacobian 需要 Adjoint：因为 twist 有坐标系，而坐标变换不是简单旋转 同一个刚体运动在不同坐标系下的 twist 数值不同。\n设两坐标系 ${A},{B}$ 的位姿关系为：\n$ {}^A T_B= \\begin{bmatrix} R \u0026 p\\\\ 0 \u0026 1 \\end{bmatrix} $ 则 twist 的坐标变换满足：\n$ \\boxed{ {}^A V = \\mathrm{Ad}_{{}^A T_B}\\,{}^B V } $ 于是 Jacobian 也必须随之变换。因为\n$ {}^B V = {}^B J\\,\\dot{q} \\quad\\Rightarrow\\quad {}^A V = \\mathrm{Ad}\\,{}^B J\\,\\dot{q} $ 对任意 $\\dot{q}$ 成立，所以 $ \\boxed{ {}^A J = \\mathrm{Ad}_{{}^A T_B}\\,{}^B J } $ 8. Adjoint 矩阵怎么推导出来？（不要求你熟悉刚体运动学） 你只需要接受一个事实：\n刚体在转动时，不同点的线速度不同；离“转动中心”越远，线速度越大。\n8.1 从“角速度只做旋转”开始 角速度是向量，坐标变换就是旋转： $ \\boxed{\\omega_A = R\\omega_B} $ 8.2 线速度为何会多出一项？（核心） 线速度 $v$ 不是“纯向量旋转”这么简单，因为它依赖于你选的参考点。\n当参考点从 $B$ 原点换到 $A$ 原点时，若刚体有角速度 $\\omega$，参考点平移 $p$ 会引入额外线速度：\n$ \\boxed{ v_A = Rv_B + \\omega_A\\times p } $ 把 $\\omega_A=R\\omega_B$ 代入： $ v_A = Rv_B + (R\\omega_B)\\times p $ 用反对称矩阵表示叉乘：$[p]_\\times x=p\\times x$，则 $ (R\\omega_B)\\times p = [p]_\\times R\\omega_B $ 所以 $ \\boxed{ v_A = Rv_B + [p]_\\times R\\omega_B } $ 8.3 合并成 6×6 的线性变换 把两行合并： $ \\begin{bmatrix} \\omega_A\\\\ v_A \\end{bmatrix} = \\underbrace{ \\begin{bmatrix} R \u0026 0\\\\ [p]_\\times R \u0026 R \\end{bmatrix} }_{\\mathrm{Ad}_{{}^A T_B}} \\begin{bmatrix} \\omega_B\\\\ v_B \\end{bmatrix} $ 因此 $ \\boxed{ \\mathrm{Ad}_T= \\begin{bmatrix} R \u0026 0\\\\ [p]_\\times R \u0026 R \\end{bmatrix} } $ 直觉：\n角速度只旋转（上左 $R$） 线速度既旋转（下右 $R$），又要加上“平移 × 角速度”的耦合项（下左 $[p]_\\times R$） 9. “原点是不是在动？”——参考点 vs 坐标系（避免一个常见误解） 讨论 twist 时有两个概念必须分开：\n参考点（reference point）：线速度 $v$ 取的是“哪个点”的速度 坐标系（frame）：你用哪组轴来表达向量分量 当你把坐标系 $B$ 附着在刚体上（body frame），并且参考点选择为该坐标系原点，则在该坐标系下这个原点对自身不动，所以：\n$ v_B = 0 $ 这并不矛盾，因为同一个运动换到空间坐标系 $A$ 后，一般会得到：\n$ v_A = \\omega_A\\times p \\neq 0 $ 因此“$v_B$ 是否为 0”取决于你到底在用 body twist 还是 spatial twist。\n10. Spatial Jacobian vs Body Jacobian：Adjoint 最常见的落点 Spatial Jacobian $J_s$：输出的 twist 用空间（世界/基座）坐标表达 Body Jacobian $J_b$：输出的 twist 用末端自身坐标表达 若末端位姿为 $T(q)$（从 body 到 space），二者关系：\n$ \\boxed{ J_s(q)=\\mathrm{Ad}_{T(q)}\\,J_b(q) } $ 反向： $ \\boxed{ J_b(q)=\\mathrm{Ad}_{T(q)^{-1}}\\,J_s(q) } $ 11. 实操清单：在微分 IK 里什么时候必须做 Adjoint 变换？ 你真正写控制器时，只需要遵守一条铁律：\nJacobian 输出的 twist 坐标系，必须和你构造的 $\\dot{x}$/误差所在坐标系一致。\n典型场景：\n你用 world frame 写了末端误差/速度 $\\dot{x}_A$，但拿到的是 body Jacobian $J_b$。\n则应先把 $\\dot{x}_A$ 变到 body： $ \\dot{x}_B = \\mathrm{Ad}_{T^{-1}}\\dot{x}_A $ 再做微分 IK： $ \\dot{q}=J_b^\\dagger \\dot{x}_B $ 多个末端、多任务叠加：先统一到同一 frame，再拼接/加权做最小二乘。\n12. 总结：一条从优化到几何的闭环 微分 IK 的方程是 $J\\dot{q}=\\dot{x}$，在一般情形下用最小二乘表述。 解不唯一时引入最小范数，得到伪逆（列满秩/行满秩分别对应两种闭式形式）。 为了奇异稳定，加入 Tikhonov 正则得到 DLS，且 $\\lambda\u003e0$ 保证可逆。 Jacobian 之所以要 Adjoint 变换，是因为它输出的是 twist，而 twist 的坐标变换不是简单旋转；平移会与角速度耦合。 Adjoint 的结构来自一个最基本的事实：刚体转动时，不同点的线速度不同。 附：常用公式速查 伪逆（列满秩）：$;J^\\dagger=(J^T J)^{-1}J^T$ 伪逆（行满秩）：$;J^\\dagger=J^T(JJ^T)^{-1}$ DLS：$;\\dot{q}=(J^T J+\\lambda^2 I)^{-1}J^T\\dot{x}=J^T(JJ^T+\\lambda^2 I)^{-1}\\dot{x}$ Adjoint： $ \\mathrm{Ad}_T= \\begin{bmatrix} R \u0026 0\\\\ [p]_\\times R \u0026 R \\end{bmatrix} $ Jacobian 变换：$;{}^A J=\\mathrm{Ad}_{{}^A T_B},{}^B J$ Spatial/Body Jacobian：$;J_s=\\mathrm{Ad}_{T},J_b$ ","wordCount":"714","inLanguage":"en","datePublished":"2026-01-30T00:00:00Z","dateModified":"2026-01-30T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://analyst-huang.github.io/posts/math/differential_ik_adjoint_blog/"},"publisher":{"@type":"Organization","name":"Blog","logo":{"@type":"ImageObject","url":"https://analyst-huang.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://analyst-huang.github.io/ accesskey=h title="Blog (Alt + H)">Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://analyst-huang.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://analyst-huang.github.io/about/ title=关于><span>关于</span></a></li><li><a href=https://analyst-huang.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://analyst-huang.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://analyst-huang.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">微分IK</h1><div class=post-meta><span title='2026-01-30 00:00:00 +0000 UTC'>January 30, 2026</span>&nbsp;·&nbsp;<span>4 min</span></div></header><div class=post-content><h1 id=微分-ikdifferential-ik与-adjoint从最小二乘到坐标系变换的一条线>微分 IK（Differential IK）与 Adjoint：从最小二乘到坐标系变换的一条线<a hidden class=anchor aria-hidden=true href=#微分-ikdifferential-ik与-adjoint从最小二乘到坐标系变换的一条线>#</a></h1><blockquote><p>这篇文章把一次完整的推导链条拼起来：<br><strong>微分 IK</strong>在算什么 → <strong>最小二乘 / 最小范数</strong>为何同时出现 → 伪逆在<strong>列满秩/行满秩</strong>下如何推导 → **阻尼最小二乘（DLS）**作为优化问题的闭式解 → 为什么 Jacobian 必须用 <strong>Adjoint</strong> 做坐标系变换 → <strong>Adjoint</strong> 本身如何从“刚体上不同点速度不同”推导出来。</p><p>读者假设：线性代数、最小二乘、一阶条件、正交投影。</p></blockquote><hr><h2 id=1-微分-ik-在解决什么问题>1. 微分 IK 在解决什么问题？<a hidden class=anchor aria-hidden=true href=#1-微分-ik-在解决什么问题>#</a></h2><p>经典 IK 是“给末端位姿，求关节角”：</p><span class=math style=display:block;text-align:center>$
x = f(q),\quad \text{给定 }x_d\Rightarrow \text{求 }q
$</span><p>微分 IK 把问题改成“给末端<strong>瞬时速度/误差变化率</strong>，求关节<strong>速度</strong>”：</p><span class=math style=display:block;text-align:center>$
\dot{x} = J(q)\,\dot{q}
$</span><p>离散实现通常是：</p><span class=math style=display:block;text-align:center>$
q_{k+1}=q_k+\dot{q}\,\Delta t
$</span><p>其中 $J(q)$ 是 Jacobian，作为线性映射：</p><span class=math style=display:block;text-align:center>$
J:\;\dot{q}\mapsto \text{twist（末端瞬时运动）}
$</span><hr><h2 id=2-jacobian-与-twist输出不是普通向量而是有坐标系的速度>2. Jacobian 与 twist：输出不是“普通向量”，而是“有坐标系”的速度<a hidden class=anchor aria-hidden=true href=#2-jacobian-与-twist输出不是普通向量而是有坐标系的速度>#</a></h2><p>在 3D 刚体运动里，常用 6 维 twist 表示瞬时运动：</p><span class=math style=display:block;text-align:center>$
V =
\begin{bmatrix}
\omega\\
v
\end{bmatrix}
\in\mathbb{R}^6
$</span><ul><li>$\omega$：角速度</li><li>$v$：某个<strong>参考点</strong>（reference point）的线速度</li></ul><p>关键点：<strong>twist 的数值依赖你在哪个坐标系表达、以及线速度对应哪个参考点</strong>。<br>因此 Jacobian 也隐含了“输出 twist 的坐标系”这一选择。</p><hr><h2 id=3-微分-ik-的核心线性最小二乘-必要时最小范数>3. 微分 IK 的核心：线性最小二乘 +（必要时）最小范数<a hidden class=anchor aria-hidden=true href=#3-微分-ik-的核心线性最小二乘-必要时最小范数>#</a></h2><p>从</p><span class=math style=display:block;text-align:center>$
J\dot{q}=\dot{x}
$</span><p>出发，真实世界里会遇到：</p><ul><li>$J$ 非方阵（任务维度 $m$ 与关节维度 $n$ 不相等）</li><li>可能超定/欠定</li><li>可能奇异（秩不足）</li></ul><p>因此更稳健的表述是：</p><h3 id=31-最小二乘误差projection--normal-equation>3.1 最小二乘误差（projection / normal equation）<a hidden class=anchor aria-hidden=true href=#31-最小二乘误差projection--normal-equation>#</a></h3><p><span class=math style=display:block;text-align:center>$
\dot{q}^*=\arg\min_{\dot{q}}\;\|J\dot{q}-\dot{x}\|_2^2
$
</span>一阶条件（法方程）：
<span class=math style=display:block;text-align:center>$
J^T(J\dot{q}-\dot{x})=0
$</span></p><p>这会把残差 $r=\dot{x}-J\dot{q}$ 逼到
<span class=math style=display:block;text-align:center>$
r\perp \mathrm{Im}(J)
$
</span>即把 $\dot{x}$ 正交投影到 $\mathrm{Im}(J)$。</p><h3 id=32-为什么还需要最小范数>3.2 为什么还需要“最小范数”？<a hidden class=anchor aria-hidden=true href=#32-为什么还需要最小范数>#</a></h3><p>当解不唯一时（典型：欠定、冗余机器人），仅靠最小二乘条件无法选出唯一解。<br>此时常用 <strong>最小范数</strong> 作为二级准则：</p><span class=math style=display:block;text-align:center>$
\boxed{
\min_{\dot{q}}\;\|\dot{q}\|_2
\quad \text{s.t.}\quad J\dot{q}=\dot{x}\;\;(\text{若可行})
}
$</span><p>最终得到 Moore–Penrose 伪逆解：
<span class=math style=display:block;text-align:center>$
\dot{q}=J^\dagger \dot{x}
$</span></p><hr><h2 id=4-伪逆在两种满秩情形下的推导列满秩-vs-行满秩>4. 伪逆在两种满秩情形下的推导（列满秩 vs 行满秩）<a hidden class=anchor aria-hidden=true href=#4-伪逆在两种满秩情形下的推导列满秩-vs-行满秩>#</a></h2><p>设 $J\in\mathbb{R}^{m\times n}$。</p><h3 id=41-列满秩column-full-rankmge-n-mathrmrankjn>4.1 列满秩（column full rank）：$m\ge n,\ \mathrm{rank}(J)=n$<a hidden class=anchor aria-hidden=true href=#41-列满秩column-full-rankmge-n-mathrmrankjn>#</a></h3><p>这是“超定最小二乘”的典型情形。<br>目标：
<span class=math style=display:block;text-align:center>$
\min_{\dot{q}}\;\|J\dot{q}-\dot{x}\|^2
$
</span>一阶条件：
<span class=math style=display:block;text-align:center>$
J^T(J\dot{q}-\dot{x})=0
\Rightarrow (J^T J)\dot{q}=J^T\dot{x}
$
</span>列满秩保证 $J^T J$ 可逆，因此解唯一：
<span class=math style=display:block;text-align:center>$
\boxed{
\dot{q}=(J^T J)^{-1}J^T\dot{x}
}
$</span></p><h3 id=42-行满秩row-full-rankmn-mathrmrankjm>4.2 行满秩（row full rank）：$m&lt;n,\ \mathrm{rank}(J)=m$<a hidden class=anchor aria-hidden=true href=#42-行满秩row-full-rankmn-mathrmrankjm>#</a></h3><p>这是“欠定但可实现”的典型情形。此时 $\mathrm{Im}(J)=\mathbb{R}^m$，任意 $\dot{x}$ 都可满足：
<span class=math style=display:block;text-align:center>$
J\dot{q}=\dot{x}
$
</span>但解不唯一（存在零空间）。因此最小二乘误差可以做到 0，问题退化成最小范数约束问题：</p><span class=math style=display:block;text-align:center>$
\min_{\dot{q}}\;\|\dot{q}\|^2
\quad \text{s.t.}\quad J\dot{q}=\dot{x}
$</span><p><strong>步骤 1：刻画所有可行解</strong><br>取任意特解 $\dot{q}_0$，所有可行解：
<span class=math style=display:block;text-align:center>$
\dot{q}=\dot{q}_0+z,\quad z\in\ker(J)
$</span></p><p><strong>步骤 2：最小范数条件给出正交性</strong><br><span class=math style=display:block;text-align:center>$
\|\dot{q}_0+z\|^2=\|\dot{q}_0\|^2+2\langle \dot{q}_0,z\rangle+\|z\|^2
$
</span>要在 $z\in\ker(J)$ 上最小，必须
<span class=math style=display:block;text-align:center>$
\dot{q}_0\perp\ker(J)
$
</span>利用基本关系：
<span class=math style=display:block;text-align:center>$
\ker(J)^\perp=\mathrm{Im}(J^T)
$
</span>因此最小范数解必在 $\mathrm{Im}(J^T)$ 中，可写为
<span class=math style=display:block;text-align:center>$
\dot{q}=J^T\lambda
$</span></p><p><strong>步骤 3：代回约束并解出 $\lambda$</strong><br><span class=math style=display:block;text-align:center>$
J\dot{q}=JJ^T\lambda=\dot{x}
$
</span>行满秩保证 $JJ^T$ 可逆：
<span class=math style=display:block;text-align:center>$
\lambda=(JJ^T)^{-1}\dot{x}
$
</span>得到
<span class=math style=display:block;text-align:center>$
\boxed{
\dot{q}=J^T(JJ^T)^{-1}\dot{x}
}
$</span></p><blockquote><p>这一推导的关键不是“法方程”，而是“最小范数 ⇔ 与零空间正交 ⇔ 落在 $\mathrm{Im}(J^T)$”。</p></blockquote><hr><h2 id=5-阻尼最小二乘dls--levenbergmarquardt-一个优化问题的闭式解>5. 阻尼最小二乘（DLS / Levenberg–Marquardt）= 一个优化问题的闭式解<a hidden class=anchor aria-hidden=true href=#5-阻尼最小二乘dls--levenbergmarquardt-一个优化问题的闭式解>#</a></h2><p>伪逆在奇异附近会导致 $\dot{q}$ 爆炸。工程上常用 DLS，把问题改写为：</p><span class=math style=display:block;text-align:center>$
\boxed{
\dot{q}^*=\arg\min_{\dot{q}}\;\|J\dot{q}-\dot{x}\|^2+\lambda^2\|\dot{q}\|^2
}
$</span><p>对 $\dot{q}$ 求导并令零：
<span class=math style=display:block;text-align:center>$
2J^T(J\dot{q}-\dot{x})+2\lambda^2\dot{q}=0
\Rightarrow (J^T J+\lambda^2 I)\dot{q}=J^T\dot{x}
$</span></p><p>闭式解：
<span class=math style=display:block;text-align:center>$
\boxed{
\dot{q}=(J^T J+\lambda^2 I)^{-1}J^T\dot{x}
}
$</span></p><p>常见等价形式（当你想逆 $m\times m$ 而不是 $n\times n$ 时更划算）：
<span class=math style=display:block;text-align:center>$
\boxed{
\dot{q}=J^T(JJ^T+\lambda^2 I)^{-1}\dot{x}
}
$
</span>且恒等式成立（$\lambda>0$）：
<span class=math style=display:block;text-align:center>$
(J^T J + \lambda^2 I)^{-1}J^T = J^T(JJ^T+\lambda^2 I)^{-1}
$</span></p><h3 id=51-为什么-jt-jlambda2-i-一定可逆>5.1 为什么 $(J^T J+\lambda^2 I)$ 一定可逆？<a hidden class=anchor aria-hidden=true href=#51-为什么-jt-jlambda2-i-一定可逆>#</a></h3><p>当 $\lambda>0$：
<span class=math style=display:block;text-align:center>$
v^T(J^T J+\lambda^2 I)v = \|Jv\|^2+\lambda^2\|v\|^2>0\quad(\forall v\ne 0)
$
</span>因此它是对称正定矩阵，必可逆。</p><blockquote><p>直觉：把奇异值平方 $\sigma_i^2$ 变成 $\sigma_i^2+\lambda^2$，零也被抬起来。</p></blockquote><hr><h2 id=6-冗余与零空间null-space项把多余自由度变成二级目标>6. 冗余与零空间（Null Space）项：把“多余自由度”变成二级目标<a hidden class=anchor aria-hidden=true href=#6-冗余与零空间null-space项把多余自由度变成二级目标>#</a></h2><p>当 $n>m$ 时（冗余机器人），满足同一任务的 $\dot{q}$ 不唯一。通解可以写成：</p><span class=math style=display:block;text-align:center>$
\boxed{
\dot{q}=J^\dagger \dot{x} + (I-J^\dagger J)\,z
}
$</span><ul><li>$J^\dagger \dot{x}$：完成主任务（最小二乘/最小范数意义）</li><li>$(I-J^\dagger J)$：投影到 $\ker(J)$ 的算子</li><li>$z$：二级目标（避限、最小能量、姿态偏好等）</li></ul><hr><h2 id=7-为什么-jacobian-需要-adjoint因为-twist-有坐标系而坐标变换不是简单旋转>7. 为什么 Jacobian 需要 Adjoint：因为 twist 有坐标系，而坐标变换不是简单旋转<a hidden class=anchor aria-hidden=true href=#7-为什么-jacobian-需要-adjoint因为-twist-有坐标系而坐标变换不是简单旋转>#</a></h2><p>同一个刚体运动在不同坐标系下的 twist 数值不同。<br>设两坐标系 ${A},{B}$ 的位姿关系为：</p><span class=math style=display:block;text-align:center>$
{}^A T_B=
\begin{bmatrix}
R & p\\
0 & 1
\end{bmatrix}
$</span><p>则 twist 的坐标变换满足：</p><span class=math style=display:block;text-align:center>$
\boxed{
{}^A V = \mathrm{Ad}_{{}^A T_B}\,{}^B V
}
$</span><p>于是 Jacobian 也必须随之变换。因为</p><p><span class=math style=display:block;text-align:center>$
{}^B V = {}^B J\,\dot{q}
\quad\Rightarrow\quad
{}^A V = \mathrm{Ad}\,{}^B J\,\dot{q}
$
</span>对任意 $\dot{q}$ 成立，所以
<span class=math style=display:block;text-align:center>$
\boxed{
{}^A J = \mathrm{Ad}_{{}^A T_B}\,{}^B J
}
$</span></p><hr><h2 id=8-adjoint-矩阵怎么推导出来不要求你熟悉刚体运动学>8. Adjoint 矩阵怎么推导出来？（不要求你熟悉刚体运动学）<a hidden class=anchor aria-hidden=true href=#8-adjoint-矩阵怎么推导出来不要求你熟悉刚体运动学>#</a></h2><p>你只需要接受一个事实：</p><blockquote><p><strong>刚体在转动时，不同点的线速度不同；离“转动中心”越远，线速度越大。</strong></p></blockquote><h3 id=81-从角速度只做旋转开始>8.1 从“角速度只做旋转”开始<a hidden class=anchor aria-hidden=true href=#81-从角速度只做旋转开始>#</a></h3><p>角速度是向量，坐标变换就是旋转：
<span class=math style=display:block;text-align:center>$
\boxed{\omega_A = R\omega_B}
$</span></p><h3 id=82-线速度为何会多出一项核心>8.2 线速度为何会多出一项？（核心）<a hidden class=anchor aria-hidden=true href=#82-线速度为何会多出一项核心>#</a></h3><p>线速度 $v$ 不是“纯向量旋转”这么简单，因为它依赖于你选的参考点。<br>当参考点从 $B$ 原点换到 $A$ 原点时，若刚体有角速度 $\omega$，参考点平移 $p$ 会引入额外线速度：</p><span class=math style=display:block;text-align:center>$
\boxed{
v_A = Rv_B + \omega_A\times p
}
$</span><p>把 $\omega_A=R\omega_B$ 代入：
<span class=math style=display:block;text-align:center>$
v_A = Rv_B + (R\omega_B)\times p
$</span></p><p>用反对称矩阵表示叉乘：$[p]_\times x=p\times x$，则
<span class=math style=display:block;text-align:center>$
(R\omega_B)\times p = [p]_\times R\omega_B
$
</span>所以
<span class=math style=display:block;text-align:center>$
\boxed{
v_A = Rv_B + [p]_\times R\omega_B
}
$</span></p><h3 id=83-合并成-66-的线性变换>8.3 合并成 6×6 的线性变换<a hidden class=anchor aria-hidden=true href=#83-合并成-66-的线性变换>#</a></h3><p>把两行合并：
<span class=math style=display:block;text-align:center>$
\begin{bmatrix}
\omega_A\\
v_A
\end{bmatrix}
=
\underbrace{
\begin{bmatrix}
R & 0\\
[p]_\times R & R
\end{bmatrix}
}_{\mathrm{Ad}_{{}^A T_B}}
\begin{bmatrix}
\omega_B\\
v_B
\end{bmatrix}
$</span></p><p>因此
<span class=math style=display:block;text-align:center>$
\boxed{
\mathrm{Ad}_T=
\begin{bmatrix}
R & 0\\
[p]_\times R & R
\end{bmatrix}
}
$</span></p><blockquote><p>直觉：</p><ul><li>角速度只旋转（上左 $R$）</li><li>线速度既旋转（下右 $R$），又要加上“平移 × 角速度”的耦合项（下左 $[p]_\times R$）</li></ul></blockquote><hr><h2 id=9-原点是不是在动参考点-vs-坐标系避免一个常见误解>9. “原点是不是在动？”——参考点 vs 坐标系（避免一个常见误解）<a hidden class=anchor aria-hidden=true href=#9-原点是不是在动参考点-vs-坐标系避免一个常见误解>#</a></h2><p>讨论 twist 时有两个概念必须分开：</p><ul><li><strong>参考点</strong>（reference point）：线速度 $v$ 取的是“哪个点”的速度</li><li><strong>坐标系</strong>（frame）：你用哪组轴来表达向量分量</li></ul><p>当你把坐标系 $B$ <strong>附着在刚体上</strong>（body frame），并且参考点选择为该坐标系原点，则在该坐标系下这个原点对自身不动，所以：</p><span class=math style=display:block;text-align:center>$
v_B = 0
$</span><p>这并不矛盾，因为同一个运动换到空间坐标系 $A$ 后，一般会得到：</p><span class=math style=display:block;text-align:center>$
v_A = \omega_A\times p \neq 0
$</span><p>因此“$v_B$ 是否为 0”取决于你到底在用 <strong>body twist</strong> 还是 <strong>spatial twist</strong>。</p><hr><h2 id=10-spatial-jacobian-vs-body-jacobianadjoint-最常见的落点>10. Spatial Jacobian vs Body Jacobian：Adjoint 最常见的落点<a hidden class=anchor aria-hidden=true href=#10-spatial-jacobian-vs-body-jacobianadjoint-最常见的落点>#</a></h2><ul><li><strong>Spatial Jacobian</strong> $J_s$：输出的 twist 用空间（世界/基座）坐标表达</li><li><strong>Body Jacobian</strong> $J_b$：输出的 twist 用末端自身坐标表达</li></ul><p>若末端位姿为 $T(q)$（从 body 到 space），二者关系：</p><p><span class=math style=display:block;text-align:center>$
\boxed{
J_s(q)=\mathrm{Ad}_{T(q)}\,J_b(q)
}
$
</span>反向：
<span class=math style=display:block;text-align:center>$
\boxed{
J_b(q)=\mathrm{Ad}_{T(q)^{-1}}\,J_s(q)
}
$</span></p><hr><h2 id=11-实操清单在微分-ik-里什么时候必须做-adjoint-变换>11. 实操清单：在微分 IK 里什么时候必须做 Adjoint 变换？<a hidden class=anchor aria-hidden=true href=#11-实操清单在微分-ik-里什么时候必须做-adjoint-变换>#</a></h2><p>你真正写控制器时，只需要遵守一条铁律：</p><blockquote><p><strong>Jacobian 输出的 twist 坐标系，必须和你构造的 $\dot{x}$/误差所在坐标系一致。</strong></p></blockquote><p>典型场景：</p><ol><li><p>你用 world frame 写了末端误差/速度 $\dot{x}_A$，但拿到的是 body Jacobian $J_b$。<br>则应先把 $\dot{x}_A$ 变到 body：
<span class=math style=display:block;text-align:center>$
\dot{x}_B = \mathrm{Ad}_{T^{-1}}\dot{x}_A
$
</span>再做微分 IK：
<span class=math style=display:block;text-align:center>$
\dot{q}=J_b^\dagger \dot{x}_B
$</span></p></li><li><p>多个末端、多任务叠加：先统一到同一 frame，再拼接/加权做最小二乘。</p></li></ol><hr><h2 id=12-总结一条从优化到几何的闭环>12. 总结：一条从优化到几何的闭环<a hidden class=anchor aria-hidden=true href=#12-总结一条从优化到几何的闭环>#</a></h2><ul><li>微分 IK 的方程是 $J\dot{q}=\dot{x}$，在一般情形下用最小二乘表述。</li><li>解不唯一时引入最小范数，得到伪逆（列满秩/行满秩分别对应两种闭式形式）。</li><li>为了奇异稳定，加入 Tikhonov 正则得到 DLS，且 $\lambda>0$ 保证可逆。</li><li>Jacobian 之所以要 Adjoint 变换，是因为它输出的是 twist，而 twist 的坐标变换不是简单旋转；平移会与角速度耦合。</li><li>Adjoint 的结构来自一个最基本的事实：<strong>刚体转动时，不同点的线速度不同</strong>。</li></ul><hr><h2 id=附常用公式速查>附：常用公式速查<a hidden class=anchor aria-hidden=true href=#附常用公式速查>#</a></h2><ul><li>伪逆（列满秩）：$;J^\dagger=(J^T J)^{-1}J^T$</li><li>伪逆（行满秩）：$;J^\dagger=J^T(JJ^T)^{-1}$</li><li>DLS：$;\dot{q}=(J^T J+\lambda^2 I)^{-1}J^T\dot{x}=J^T(JJ^T+\lambda^2 I)^{-1}\dot{x}$</li><li>Adjoint：
<span class=math style=display:block;text-align:center>$
\mathrm{Ad}_T=
\begin{bmatrix}
R & 0\\
[p]_\times R & R
\end{bmatrix}
$</span></li><li>Jacobian 变换：$;{}^A J=\mathrm{Ad}_{{}^A T_B},{}^B J$</li><li>Spatial/Body Jacobian：$;J_s=\mathrm{Ad}_{T},J_b$</li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://analyst-huang.github.io/>Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>