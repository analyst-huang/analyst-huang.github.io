<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Socket | Blog</title><meta name=keywords content><meta name=description content="进程、内核与 Socket：通信机制要点
一、每个进程都有哪些是“独立的”？
每个进程有独立的：

虚拟地址空间
寄存器上下文

内核用时间片轮转在同一颗物理 CPU 上切换它们。
但有一件事是不虚拟的：

所有进程共享同一个操作系统内核。

而 socket 属于：

内核对象（kernel object）

当你在用户态调用：
sock.send(...)
实际上发生的是：

触发系统调用（syscall）
CPU 切到内核态
内核代表你这个进程去执行真正的发送逻辑

所以通信的“公共场所”不是 CPU，而是：

内核里的网络协议栈 + 内核缓冲区


二、Socket 在内核里到底是什么？
从内核视角看，一个 socket 大致包含：

socket 结构体
接收缓冲区（recv buffer）
发送缓冲区（send buffer）
协议状态机（TCP 状态、序列号等）

每个进程持有的其实只是：

一个文件描述符 fd → 指向内核里的 socket 对象

所以：


两个进程可以分别持有：

指向同一个 socket 对象的 fd（例如通过 fork 继承）
或一对互相关联的 socket（TCP 连接两端）



Socket 与 TCP 出现之前的通信历史（极简时间线）
一、最早期：只有物理通信（无协议）

串口、并口、专用总线
直接发送电信号
特点：

无地址
无连接
无可靠性


本质：硬件层通信，没有操作系统抽象


二、分组交换网络：只有“包”，没有“连接”

ARPANET / 早期 IP 思想
通信模型：

send(packet)
网络尽力投递


特点：

无连接
可能丢包 / 乱序 / 重复


接近今天的：IP / UDP 语义


三、应用自己实现可靠性（应用层协议时代）

FTP / Telnet 等早期协议
每个应用自己实现：

序号
ACK
重传
流控


问题：

重复造轮子
质量不可控
网络整体容易拥塞




四、TCP 的出现：把“可靠流”下沉到内核

TCP 抽象：

可靠
有序
字节流


协议状态必须长期维护：

状态机
缓冲区
拥塞控制


结果：

状态进入操作系统内核
通信关系成为内核对象




五、Socket 的诞生：进程访问内核协议栈的统一接口

BSD Unix 引入 socket API
设计目标：

用 fd 表示通信端点
统一 TCP / UDP / 本地域通信


本质：

socket = 协议状态 + 缓冲区 + 控制逻辑 的内核对象




一句话总结


TCP 之前：
→ 要么无连接无可靠性（只发包）
→ 要么可靠性由应用自己实现"><meta name=author content><link rel=canonical href=https://analyst-huang.github.io/posts/system/socket/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://analyst-huang.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://analyst-huang.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://analyst-huang.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://analyst-huang.github.io/apple-touch-icon.png><link rel=mask-icon href=https://analyst-huang.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://analyst-huang.github.io/posts/system/socket/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\\\(",right:"\\\\)",display:!1},{left:"\\\\[",right:"\\\\]",display:!0}]})})</script><meta property="og:url" content="https://analyst-huang.github.io/posts/system/socket/"><meta property="og:site_name" content="Blog"><meta property="og:title" content="Socket"><meta property="og:description" content="进程、内核与 Socket：通信机制要点 一、每个进程都有哪些是“独立的”？ 每个进程有独立的：
虚拟地址空间 寄存器上下文 内核用时间片轮转在同一颗物理 CPU 上切换它们。
但有一件事是不虚拟的：
所有进程共享同一个操作系统内核。
而 socket 属于：
内核对象（kernel object） 当你在用户态调用：
sock.send(...) 实际上发生的是：
触发系统调用（syscall） CPU 切到内核态 内核代表你这个进程去执行真正的发送逻辑 所以通信的“公共场所”不是 CPU，而是：
内核里的网络协议栈 + 内核缓冲区
二、Socket 在内核里到底是什么？ 从内核视角看，一个 socket 大致包含：
socket 结构体 接收缓冲区（recv buffer） 发送缓冲区（send buffer） 协议状态机（TCP 状态、序列号等） 每个进程持有的其实只是：
一个文件描述符 fd → 指向内核里的 socket 对象
所以：
两个进程可以分别持有：
指向同一个 socket 对象的 fd（例如通过 fork 继承） 或一对互相关联的 socket（TCP 连接两端） Socket 与 TCP 出现之前的通信历史（极简时间线） 一、最早期：只有物理通信（无协议） 串口、并口、专用总线 直接发送电信号 特点： 无地址 无连接 无可靠性 本质：硬件层通信，没有操作系统抽象 二、分组交换网络：只有“包”，没有“连接” ARPANET / 早期 IP 思想 通信模型： send(packet) 网络尽力投递 特点： 无连接 可能丢包 / 乱序 / 重复 接近今天的：IP / UDP 语义 三、应用自己实现可靠性（应用层协议时代） FTP / Telnet 等早期协议 每个应用自己实现： 序号 ACK 重传 流控 问题： 重复造轮子 质量不可控 网络整体容易拥塞 四、TCP 的出现：把“可靠流”下沉到内核 TCP 抽象： 可靠 有序 字节流 协议状态必须长期维护： 状态机 缓冲区 拥塞控制 结果： 状态进入操作系统内核 通信关系成为内核对象 五、Socket 的诞生：进程访问内核协议栈的统一接口 BSD Unix 引入 socket API 设计目标： 用 fd 表示通信端点 统一 TCP / UDP / 本地域通信 本质： socket = 协议状态 + 缓冲区 + 控制逻辑 的内核对象 一句话总结 TCP 之前：
→ 要么无连接无可靠性（只发包）
→ 要么可靠性由应用自己实现"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-09T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-09T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Socket"><meta name=twitter:description content="进程、内核与 Socket：通信机制要点
一、每个进程都有哪些是“独立的”？
每个进程有独立的：

虚拟地址空间
寄存器上下文

内核用时间片轮转在同一颗物理 CPU 上切换它们。
但有一件事是不虚拟的：

所有进程共享同一个操作系统内核。

而 socket 属于：

内核对象（kernel object）

当你在用户态调用：
sock.send(...)
实际上发生的是：

触发系统调用（syscall）
CPU 切到内核态
内核代表你这个进程去执行真正的发送逻辑

所以通信的“公共场所”不是 CPU，而是：

内核里的网络协议栈 + 内核缓冲区


二、Socket 在内核里到底是什么？
从内核视角看，一个 socket 大致包含：

socket 结构体
接收缓冲区（recv buffer）
发送缓冲区（send buffer）
协议状态机（TCP 状态、序列号等）

每个进程持有的其实只是：

一个文件描述符 fd → 指向内核里的 socket 对象

所以：


两个进程可以分别持有：

指向同一个 socket 对象的 fd（例如通过 fork 继承）
或一对互相关联的 socket（TCP 连接两端）



Socket 与 TCP 出现之前的通信历史（极简时间线）
一、最早期：只有物理通信（无协议）

串口、并口、专用总线
直接发送电信号
特点：

无地址
无连接
无可靠性


本质：硬件层通信，没有操作系统抽象


二、分组交换网络：只有“包”，没有“连接”

ARPANET / 早期 IP 思想
通信模型：

send(packet)
网络尽力投递


特点：

无连接
可能丢包 / 乱序 / 重复


接近今天的：IP / UDP 语义


三、应用自己实现可靠性（应用层协议时代）

FTP / Telnet 等早期协议
每个应用自己实现：

序号
ACK
重传
流控


问题：

重复造轮子
质量不可控
网络整体容易拥塞




四、TCP 的出现：把“可靠流”下沉到内核

TCP 抽象：

可靠
有序
字节流


协议状态必须长期维护：

状态机
缓冲区
拥塞控制


结果：

状态进入操作系统内核
通信关系成为内核对象




五、Socket 的诞生：进程访问内核协议栈的统一接口

BSD Unix 引入 socket API
设计目标：

用 fd 表示通信端点
统一 TCP / UDP / 本地域通信


本质：

socket = 协议状态 + 缓冲区 + 控制逻辑 的内核对象




一句话总结


TCP 之前：
→ 要么无连接无可靠性（只发包）
→ 要么可靠性由应用自己实现"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://analyst-huang.github.io/posts/"},{"@type":"ListItem","position":2,"name":"System","item":"https://analyst-huang.github.io/posts/system/"},{"@type":"ListItem","position":3,"name":"Socket","item":"https://analyst-huang.github.io/posts/system/socket/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Socket","name":"Socket","description":"进程、内核与 Socket：通信机制要点 一、每个进程都有哪些是“独立的”？ 每个进程有独立的：\n虚拟地址空间 寄存器上下文 内核用时间片轮转在同一颗物理 CPU 上切换它们。\n但有一件事是不虚拟的：\n所有进程共享同一个操作系统内核。\n而 socket 属于：\n内核对象（kernel object） 当你在用户态调用：\nsock.send(...) 实际上发生的是：\n触发系统调用（syscall） CPU 切到内核态 内核代表你这个进程去执行真正的发送逻辑 所以通信的“公共场所”不是 CPU，而是：\n内核里的网络协议栈 + 内核缓冲区\n二、Socket 在内核里到底是什么？ 从内核视角看，一个 socket 大致包含：\nsocket 结构体 接收缓冲区（recv buffer） 发送缓冲区（send buffer） 协议状态机（TCP 状态、序列号等） 每个进程持有的其实只是：\n一个文件描述符 fd → 指向内核里的 socket 对象\n所以：\n两个进程可以分别持有：\n指向同一个 socket 对象的 fd（例如通过 fork 继承） 或一对互相关联的 socket（TCP 连接两端） Socket 与 TCP 出现之前的通信历史（极简时间线） 一、最早期：只有物理通信（无协议） 串口、并口、专用总线 直接发送电信号 特点： 无地址 无连接 无可靠性 本质：硬件层通信，没有操作系统抽象 二、分组交换网络：只有“包”，没有“连接” ARPANET / 早期 IP 思想 通信模型： send(packet) 网络尽力投递 特点： 无连接 可能丢包 / 乱序 / 重复 接近今天的：IP / UDP 语义 三、应用自己实现可靠性（应用层协议时代） FTP / Telnet 等早期协议 每个应用自己实现： 序号 ACK 重传 流控 问题： 重复造轮子 质量不可控 网络整体容易拥塞 四、TCP 的出现：把“可靠流”下沉到内核 TCP 抽象： 可靠 有序 字节流 协议状态必须长期维护： 状态机 缓冲区 拥塞控制 结果： 状态进入操作系统内核 通信关系成为内核对象 五、Socket 的诞生：进程访问内核协议栈的统一接口 BSD Unix 引入 socket API 设计目标： 用 fd 表示通信端点 统一 TCP / UDP / 本地域通信 本质： socket = 协议状态 + 缓冲区 + 控制逻辑 的内核对象 一句话总结 TCP 之前：\n→ 要么无连接无可靠性（只发包）\n→ 要么可靠性由应用自己实现\n","keywords":[],"articleBody":"进程、内核与 Socket：通信机制要点 一、每个进程都有哪些是“独立的”？ 每个进程有独立的：\n虚拟地址空间 寄存器上下文 内核用时间片轮转在同一颗物理 CPU 上切换它们。\n但有一件事是不虚拟的：\n所有进程共享同一个操作系统内核。\n而 socket 属于：\n内核对象（kernel object） 当你在用户态调用：\nsock.send(...) 实际上发生的是：\n触发系统调用（syscall） CPU 切到内核态 内核代表你这个进程去执行真正的发送逻辑 所以通信的“公共场所”不是 CPU，而是：\n内核里的网络协议栈 + 内核缓冲区\n二、Socket 在内核里到底是什么？ 从内核视角看，一个 socket 大致包含：\nsocket 结构体 接收缓冲区（recv buffer） 发送缓冲区（send buffer） 协议状态机（TCP 状态、序列号等） 每个进程持有的其实只是：\n一个文件描述符 fd → 指向内核里的 socket 对象\n所以：\n两个进程可以分别持有：\n指向同一个 socket 对象的 fd（例如通过 fork 继承） 或一对互相关联的 socket（TCP 连接两端） Socket 与 TCP 出现之前的通信历史（极简时间线） 一、最早期：只有物理通信（无协议） 串口、并口、专用总线 直接发送电信号 特点： 无地址 无连接 无可靠性 本质：硬件层通信，没有操作系统抽象 二、分组交换网络：只有“包”，没有“连接” ARPANET / 早期 IP 思想 通信模型： send(packet) 网络尽力投递 特点： 无连接 可能丢包 / 乱序 / 重复 接近今天的：IP / UDP 语义 三、应用自己实现可靠性（应用层协议时代） FTP / Telnet 等早期协议 每个应用自己实现： 序号 ACK 重传 流控 问题： 重复造轮子 质量不可控 网络整体容易拥塞 四、TCP 的出现：把“可靠流”下沉到内核 TCP 抽象： 可靠 有序 字节流 协议状态必须长期维护： 状态机 缓冲区 拥塞控制 结果： 状态进入操作系统内核 通信关系成为内核对象 五、Socket 的诞生：进程访问内核协议栈的统一接口 BSD Unix 引入 socket API 设计目标： 用 fd 表示通信端点 统一 TCP / UDP / 本地域通信 本质： socket = 协议状态 + 缓冲区 + 控制逻辑 的内核对象 一句话总结 TCP 之前：\n→ 要么无连接无可靠性（只发包）\n→ 要么可靠性由应用自己实现\nTCP 之后：\n→ 可靠通信成为操作系统职责\n→ 必须有内核级端点对象\n→ socket 因此诞生\nPython Socket API（要点总结：1–5） 一、Python 的 socket 对应内核里的什么？\nsocket.socket() 调用内核的 socket() 系统调用创建内核 socket 对象 内核返回文件描述符（fd），Python 将其封装成 socket 对象 真实的数据缓冲区、协议状态机全部在内核中 send/recv 实际路径：Python → libc → syscall → 内核协议栈 二、socket.socket(…) 参数含义\n标准构造：\nsocket.socket(family, type, proto=0) 常见组合：\nTCP：\nsocket.socket(AF_INET, SOCK_STREAM) IPv4 + 字节流 + 面向连接 → TCP UDP：\nsocket.socket(AF_INET, SOCK_DGRAM) IPv4 + 数据报 + 无连接 → UDP 本机通信：\nsocket.socket(AF_UNIX, SOCK_STREAM) 仅在内核中拷贝，不走网络协议栈 三、TCP 服务端完整流程（内核视角）\n创建 socket\ns = socket.socket() 内核创建 socket 对象 bind\ns.bind((ip, port)) 绑定本地地址与端口 listen\ns.listen(backlog) socket 进入 LISTEN 状态 建立连接等待队列 不能用于数据传输 accept\nconn, addr = s.accept() 内核创建新的 socket（ESTABLISHED） 返回新的 fd 用于真实通信 原 socket 仍用于继续监听 send / recv\nconn.send(...) conn.recv(...) TCP 提供可靠有序字节流 不保证消息边界，需自定义协议分帧 四、TCP 客户端流程\ns = socket.socket() s.connect((server_ip, port)) 触发三次握手 socket 进入 ESTABLISHED 状态 之后 send/recv 与服务端对等通信 五、UDP API 的本质区别\n无连接、无状态机、无重传保证 发送：\ns.sendto(data, addr) 接收：\ndata, addr = s.recvfrom(4096) 特点：\n无 listen / accept 每个数据报独立处理 可调用 connect() 仅用于固定默认目标地址（不建立真实连接） 一句话对比\nTCP socket：内核维护连接状态与缓冲区，提供可靠字节流 UDP socket：仅提供数据报投递接口，不提供可靠性与顺序保证 ","wordCount":"302","inLanguage":"en","datePublished":"2026-01-09T00:00:00Z","dateModified":"2026-01-09T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://analyst-huang.github.io/posts/system/socket/"},"publisher":{"@type":"Organization","name":"Blog","logo":{"@type":"ImageObject","url":"https://analyst-huang.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://analyst-huang.github.io/ accesskey=h title="Blog (Alt + H)">Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://analyst-huang.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://analyst-huang.github.io/about/ title=关于><span>关于</span></a></li><li><a href=https://analyst-huang.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://analyst-huang.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://analyst-huang.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://analyst-huang.github.io/posts/system/>System</a></div><h1 class="post-title entry-hint-parent">Socket</h1><div class=post-meta><span title='2026-01-09 00:00:00 +0000 UTC'>January 9, 2026</span>&nbsp;·&nbsp;<span>2 min</span></div></header><div class=post-content><h1 id=进程内核与-socket通信机制要点>进程、内核与 Socket：通信机制要点<a hidden class=anchor aria-hidden=true href=#进程内核与-socket通信机制要点>#</a></h1><h2 id=一每个进程都有哪些是独立的>一、每个进程都有哪些是“独立的”？<a hidden class=anchor aria-hidden=true href=#一每个进程都有哪些是独立的>#</a></h2><p>每个进程有独立的：</p><ul><li>虚拟地址空间</li><li>寄存器上下文</li></ul><p>内核用<strong>时间片轮转</strong>在同一颗物理 CPU 上切换它们。</p><p>但有一件事是<strong>不虚拟的</strong>：</p><blockquote><p>所有进程共享同一个操作系统内核。</p></blockquote><p>而 <strong>socket 属于</strong>：</p><ul><li>内核对象（kernel object）</li></ul><p>当你在用户态调用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>sock.send(...)
</span></span></code></pre></div><p>实际上发生的是：</p><ol><li>触发系统调用（syscall）</li><li>CPU 切到内核态</li><li>内核代表你这个进程去执行真正的发送逻辑</li></ol><p>所以通信的“公共场所”不是 CPU，而是：</p><blockquote><p>内核里的网络协议栈 + 内核缓冲区</p></blockquote><hr><h2 id=二socket-在内核里到底是什么>二、Socket 在内核里到底是什么？<a hidden class=anchor aria-hidden=true href=#二socket-在内核里到底是什么>#</a></h2><p>从内核视角看，一个 socket 大致包含：</p><ul><li>socket 结构体</li><li>接收缓冲区（recv buffer）</li><li>发送缓冲区（send buffer）</li><li>协议状态机（TCP 状态、序列号等）</li></ul><p>每个进程持有的其实只是：</p><blockquote><p>一个文件描述符 <code>fd</code> → 指向内核里的 socket 对象</p></blockquote><p>所以：</p><ul><li><p>两个进程可以分别持有：</p><ul><li>指向<strong>同一个 socket 对象</strong>的 fd（例如通过 <code>fork</code> 继承）</li><li>或一对<strong>互相关联的 socket</strong>（TCP 连接两端）</li></ul></li></ul><h1 id=socket-与-tcp-出现之前的通信历史极简时间线>Socket 与 TCP 出现之前的通信历史（极简时间线）<a hidden class=anchor aria-hidden=true href=#socket-与-tcp-出现之前的通信历史极简时间线>#</a></h1><h2 id=一最早期只有物理通信无协议>一、最早期：只有物理通信（无协议）<a hidden class=anchor aria-hidden=true href=#一最早期只有物理通信无协议>#</a></h2><ul><li>串口、并口、专用总线</li><li>直接发送电信号</li><li>特点：<ul><li>无地址</li><li>无连接</li><li>无可靠性</li></ul></li><li>本质：硬件层通信，没有操作系统抽象</li></ul><hr><h2 id=二分组交换网络只有包没有连接>二、分组交换网络：只有“包”，没有“连接”<a hidden class=anchor aria-hidden=true href=#二分组交换网络只有包没有连接>#</a></h2><ul><li>ARPANET / 早期 IP 思想</li><li>通信模型：<ul><li>send(packet)</li><li>网络尽力投递</li></ul></li><li>特点：<ul><li>无连接</li><li>可能丢包 / 乱序 / 重复</li></ul></li><li>接近今天的：IP / UDP 语义</li></ul><hr><h2 id=三应用自己实现可靠性应用层协议时代>三、应用自己实现可靠性（应用层协议时代）<a hidden class=anchor aria-hidden=true href=#三应用自己实现可靠性应用层协议时代>#</a></h2><ul><li>FTP / Telnet 等早期协议</li><li>每个应用自己实现：<ul><li>序号</li><li>ACK</li><li>重传</li><li>流控</li></ul></li><li>问题：<ul><li>重复造轮子</li><li>质量不可控</li><li>网络整体容易拥塞</li></ul></li></ul><hr><h2 id=四tcp-的出现把可靠流下沉到内核>四、TCP 的出现：把“可靠流”下沉到内核<a hidden class=anchor aria-hidden=true href=#四tcp-的出现把可靠流下沉到内核>#</a></h2><ul><li>TCP 抽象：<ul><li>可靠</li><li>有序</li><li>字节流</li></ul></li><li>协议状态必须长期维护：<ul><li>状态机</li><li>缓冲区</li><li>拥塞控制</li></ul></li><li>结果：<ul><li>状态进入操作系统内核</li><li>通信关系成为内核对象</li></ul></li></ul><hr><h2 id=五socket-的诞生进程访问内核协议栈的统一接口>五、Socket 的诞生：进程访问内核协议栈的统一接口<a hidden class=anchor aria-hidden=true href=#五socket-的诞生进程访问内核协议栈的统一接口>#</a></h2><ul><li>BSD Unix 引入 socket API</li><li>设计目标：<ul><li>用 fd 表示通信端点</li><li>统一 TCP / UDP / 本地域通信</li></ul></li><li>本质：<ul><li>socket = 协议状态 + 缓冲区 + 控制逻辑 的内核对象</li></ul></li></ul><hr><h2 id=一句话总结>一句话总结<a hidden class=anchor aria-hidden=true href=#一句话总结>#</a></h2><ul><li><p>TCP 之前：<br>→ 要么无连接无可靠性（只发包）<br>→ 要么可靠性由应用自己实现</p></li><li><p>TCP 之后：<br>→ 可靠通信成为操作系统职责<br>→ 必须有内核级端点对象<br>→ socket 因此诞生</p></li></ul><h1 id=python-socket-api要点总结15>Python Socket API（要点总结：1–5）<a hidden class=anchor aria-hidden=true href=#python-socket-api要点总结15>#</a></h1><p>一、Python 的 socket 对应内核里的什么？</p><ul><li>socket.socket() 调用内核的 socket() 系统调用创建内核 socket 对象</li><li>内核返回文件描述符（fd），Python 将其封装成 socket 对象</li><li>真实的数据缓冲区、协议状态机全部在内核中</li><li>send/recv 实际路径：Python → libc → syscall → 内核协议栈</li></ul><hr><p>二、socket.socket(…) 参数含义</p><p>标准构造：</p><pre><code>socket.socket(family, type, proto=0)
</code></pre><p>常见组合：</p><ul><li><p>TCP：</p><pre><code>socket.socket(AF_INET, SOCK_STREAM)
</code></pre><ul><li>IPv4 + 字节流 + 面向连接 → TCP</li></ul></li><li><p>UDP：</p><pre><code>socket.socket(AF_INET, SOCK_DGRAM)
</code></pre><ul><li>IPv4 + 数据报 + 无连接 → UDP</li></ul></li><li><p>本机通信：</p><pre><code>socket.socket(AF_UNIX, SOCK_STREAM)
</code></pre><ul><li>仅在内核中拷贝，不走网络协议栈</li></ul></li></ul><hr><p>三、TCP 服务端完整流程（内核视角）</p><ol><li><p>创建 socket</p><pre><code>s = socket.socket()
</code></pre><ul><li>内核创建 socket 对象</li></ul></li><li><p>bind</p><pre><code>s.bind((ip, port))
</code></pre><ul><li>绑定本地地址与端口</li></ul></li><li><p>listen</p><pre><code>s.listen(backlog)
</code></pre><ul><li>socket 进入 LISTEN 状态</li><li>建立连接等待队列</li><li>不能用于数据传输</li></ul></li><li><p>accept</p><pre><code>conn, addr = s.accept()
</code></pre><ul><li>内核创建新的 socket（ESTABLISHED）</li><li>返回新的 fd 用于真实通信</li><li>原 socket 仍用于继续监听</li></ul></li><li><p>send / recv</p><pre><code>conn.send(...)
conn.recv(...)
</code></pre><ul><li>TCP 提供可靠有序字节流</li><li>不保证消息边界，需自定义协议分帧</li></ul></li></ol><hr><p>四、TCP 客户端流程</p><pre><code>s = socket.socket()
s.connect((server_ip, port))
</code></pre><ul><li>触发三次握手</li><li>socket 进入 ESTABLISHED 状态</li><li>之后 send/recv 与服务端对等通信</li></ul><hr><p>五、UDP API 的本质区别</p><ul><li>无连接、无状态机、无重传保证</li></ul><p>发送：</p><pre><code>s.sendto(data, addr)
</code></pre><p>接收：</p><pre><code>data, addr = s.recvfrom(4096)
</code></pre><p>特点：</p><ul><li>无 listen / accept</li><li>每个数据报独立处理</li><li>可调用 connect() 仅用于固定默认目标地址（不建立真实连接）</li></ul><hr><p>一句话对比</p><ul><li>TCP socket：内核维护连接状态与缓冲区，提供可靠字节流</li><li>UDP socket：仅提供数据报投递接口，不提供可靠性与顺序保证</li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://analyst-huang.github.io/>Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>