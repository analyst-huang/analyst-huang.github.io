<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>System on Blog</title><link>https://analyst-huang.github.io/posts/system/</link><description>Recent content in System on Blog</description><generator>Hugo -- 0.155.0</generator><language>zh-cn</language><lastBuildDate>Fri, 09 Jan 2026 00:00:00 +0000</lastBuildDate><atom:link href="https://analyst-huang.github.io/posts/system/index.xml" rel="self" type="application/rss+xml"/><item><title>Socket</title><link>https://analyst-huang.github.io/posts/system/socket/</link><pubDate>Fri, 09 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/system/socket/</guid><description>&lt;h1 id="进程内核与-socket通信机制要点"&gt;进程、内核与 Socket：通信机制要点&lt;/h1&gt;
&lt;h2 id="一每个进程都有哪些是独立的"&gt;一、每个进程都有哪些是“独立的”？&lt;/h2&gt;
&lt;p&gt;每个进程有独立的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟地址空间&lt;/li&gt;
&lt;li&gt;寄存器上下文&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核用&lt;strong&gt;时间片轮转&lt;/strong&gt;在同一颗物理 CPU 上切换它们。&lt;/p&gt;
&lt;p&gt;但有一件事是&lt;strong&gt;不虚拟的&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所有进程共享同一个操作系统内核。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而 &lt;strong&gt;socket 属于&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核对象（kernel object）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当你在用户态调用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"&gt;&lt;code class="language-text" data-lang="text"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;sock.send(...)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;实际上发生的是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;触发系统调用（syscall）&lt;/li&gt;
&lt;li&gt;CPU 切到内核态&lt;/li&gt;
&lt;li&gt;内核代表你这个进程去执行真正的发送逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以通信的“公共场所”不是 CPU，而是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;内核里的网络协议栈 + 内核缓冲区&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="二socket-在内核里到底是什么"&gt;二、Socket 在内核里到底是什么？&lt;/h2&gt;
&lt;p&gt;从内核视角看，一个 socket 大致包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;socket 结构体&lt;/li&gt;
&lt;li&gt;接收缓冲区（recv buffer）&lt;/li&gt;
&lt;li&gt;发送缓冲区（send buffer）&lt;/li&gt;
&lt;li&gt;协议状态机（TCP 状态、序列号等）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个进程持有的其实只是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个文件描述符 &lt;code&gt;fd&lt;/code&gt; → 指向内核里的 socket 对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;两个进程可以分别持有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指向&lt;strong&gt;同一个 socket 对象&lt;/strong&gt;的 fd（例如通过 &lt;code&gt;fork&lt;/code&gt; 继承）&lt;/li&gt;
&lt;li&gt;或一对&lt;strong&gt;互相关联的 socket&lt;/strong&gt;（TCP 连接两端）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="socket-与-tcp-出现之前的通信历史极简时间线"&gt;Socket 与 TCP 出现之前的通信历史（极简时间线）&lt;/h1&gt;
&lt;h2 id="一最早期只有物理通信无协议"&gt;一、最早期：只有物理通信（无协议）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;串口、并口、专用总线&lt;/li&gt;
&lt;li&gt;直接发送电信号&lt;/li&gt;
&lt;li&gt;特点：
&lt;ul&gt;
&lt;li&gt;无地址&lt;/li&gt;
&lt;li&gt;无连接&lt;/li&gt;
&lt;li&gt;无可靠性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;本质：硬件层通信，没有操作系统抽象&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="二分组交换网络只有包没有连接"&gt;二、分组交换网络：只有“包”，没有“连接”&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ARPANET / 早期 IP 思想&lt;/li&gt;
&lt;li&gt;通信模型：
&lt;ul&gt;
&lt;li&gt;send(packet)&lt;/li&gt;
&lt;li&gt;网络尽力投递&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;特点：
&lt;ul&gt;
&lt;li&gt;无连接&lt;/li&gt;
&lt;li&gt;可能丢包 / 乱序 / 重复&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接近今天的：IP / UDP 语义&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="三应用自己实现可靠性应用层协议时代"&gt;三、应用自己实现可靠性（应用层协议时代）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;FTP / Telnet 等早期协议&lt;/li&gt;
&lt;li&gt;每个应用自己实现：
&lt;ul&gt;
&lt;li&gt;序号&lt;/li&gt;
&lt;li&gt;ACK&lt;/li&gt;
&lt;li&gt;重传&lt;/li&gt;
&lt;li&gt;流控&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;问题：
&lt;ul&gt;
&lt;li&gt;重复造轮子&lt;/li&gt;
&lt;li&gt;质量不可控&lt;/li&gt;
&lt;li&gt;网络整体容易拥塞&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="四tcp-的出现把可靠流下沉到内核"&gt;四、TCP 的出现：把“可靠流”下沉到内核&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;TCP 抽象：
&lt;ul&gt;
&lt;li&gt;可靠&lt;/li&gt;
&lt;li&gt;有序&lt;/li&gt;
&lt;li&gt;字节流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;协议状态必须长期维护：
&lt;ul&gt;
&lt;li&gt;状态机&lt;/li&gt;
&lt;li&gt;缓冲区&lt;/li&gt;
&lt;li&gt;拥塞控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;结果：
&lt;ul&gt;
&lt;li&gt;状态进入操作系统内核&lt;/li&gt;
&lt;li&gt;通信关系成为内核对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="五socket-的诞生进程访问内核协议栈的统一接口"&gt;五、Socket 的诞生：进程访问内核协议栈的统一接口&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;BSD Unix 引入 socket API&lt;/li&gt;
&lt;li&gt;设计目标：
&lt;ul&gt;
&lt;li&gt;用 fd 表示通信端点&lt;/li&gt;
&lt;li&gt;统一 TCP / UDP / 本地域通信&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;本质：
&lt;ul&gt;
&lt;li&gt;socket = 协议状态 + 缓冲区 + 控制逻辑 的内核对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="一句话总结"&gt;一句话总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TCP 之前：&lt;br&gt;
→ 要么无连接无可靠性（只发包）&lt;br&gt;
→ 要么可靠性由应用自己实现&lt;/p&gt;</description></item></channel></rss>