<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>XML 语法与工程实践：从树模型到 XPath、Namespace 与 CDATA | Blog</title><meta name=keywords content="XML,URDF,XPath,Namespace,CDATA,Python"><meta name=description content='0. 这篇文章解决什么问题
XML（eXtensible Markup Language）经常被当作“带尖括号的文本”。但在工程场景（URDF、USD/Omniverse 配置、各种工具链描述文件）里，理解 XML 的关键并不是记住几个标签写法，而是把它当成：

一棵“有序树 + 属性 + 文本”的数据结构
程序读的不是字符流，而是结构。

本文从这个树模型出发，系统整理 XML 的核心语法与常见机制：text/tail、XPath、Namespace、CDATA，并给出 Python（ElementTree）与命令行工具的可用做法。

1. Markup Language 是什么：用“标记”把文本变成结构
Markup Language（标记语言）的本质：用标签（tag）给文本加上边界、层级与语义。
<robot name="taco">
  <link name="base_link"/>
</robot>
这不是“字符串里夹标签”，而是树：
robot (name="taco")
└── link (name="base_link")
标签名是“语义”，属性是“参数”，嵌套是“结构”。
因此 XML 的强项是：跨系统传递结构化语义（而不是仅仅渲染）。

2. XML 的基本语法（严格规则）
XML 比 HTML 严格得多。常见约束如下：
2.1 标签必须闭合
✅ 正确：
<mesh></mesh>
<mesh />
❌ 错误：
<mesh>
2.2 区分大小写
<Mesh> ≠ <mesh>
2.3 属性必须加引号
✅
<link name="base_link"/>
❌
<link name=base_link/>
2.4 必须正确嵌套，且只有一个根节点
✅
<a><b/></a>
❌
<a><b></a></b>

3. Element / Attribute / Text：把 XML 当成对象模型
一个元素（Element）由：'><meta name=author content><link rel=canonical href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/xml/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://analyst-huang.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://analyst-huang.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://analyst-huang.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://analyst-huang.github.io/apple-touch-icon.png><link rel=mask-icon href=https://analyst-huang.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/xml/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/xml/"><meta property="og:site_name" content="Blog"><meta property="og:title" content="XML 语法与工程实践：从树模型到 XPath、Namespace 与 CDATA"><meta property="og:description" content='0. 这篇文章解决什么问题 XML（eXtensible Markup Language）经常被当作“带尖括号的文本”。但在工程场景（URDF、USD/Omniverse 配置、各种工具链描述文件）里，理解 XML 的关键并不是记住几个标签写法，而是把它当成：
一棵“有序树 + 属性 + 文本”的数据结构
程序读的不是字符流，而是结构。
本文从这个树模型出发，系统整理 XML 的核心语法与常见机制：text/tail、XPath、Namespace、CDATA，并给出 Python（ElementTree）与命令行工具的可用做法。
1. Markup Language 是什么：用“标记”把文本变成结构 Markup Language（标记语言）的本质：用标签（tag）给文本加上边界、层级与语义。
<robot name="taco"> <link name="base_link"/> </robot> 这不是“字符串里夹标签”，而是树：
robot (name="taco") └── link (name="base_link") 标签名是“语义”，属性是“参数”，嵌套是“结构”。
因此 XML 的强项是：跨系统传递结构化语义（而不是仅仅渲染）。
2. XML 的基本语法（严格规则） XML 比 HTML 严格得多。常见约束如下：
2.1 标签必须闭合 ✅ 正确：
<mesh></mesh> <mesh /> ❌ 错误：
<mesh> 2.2 区分大小写 <Mesh> ≠ <mesh> 2.3 属性必须加引号 ✅
<link name="base_link"/> ❌
<link name=base_link/> 2.4 必须正确嵌套，且只有一个根节点 ✅
<a><b/></a> ❌
<a><b></a></b> 3. Element / Attribute / Text：把 XML 当成对象模型 一个元素（Element）由：'><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-19T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-19T00:00:00+00:00"><meta property="article:tag" content="XML"><meta property="article:tag" content="URDF"><meta property="article:tag" content="XPath"><meta property="article:tag" content="Namespace"><meta property="article:tag" content="CDATA"><meta property="article:tag" content="Python"><meta name=twitter:card content="summary"><meta name=twitter:title content="XML 语法与工程实践：从树模型到 XPath、Namespace 与 CDATA"><meta name=twitter:description content='0. 这篇文章解决什么问题
XML（eXtensible Markup Language）经常被当作“带尖括号的文本”。但在工程场景（URDF、USD/Omniverse 配置、各种工具链描述文件）里，理解 XML 的关键并不是记住几个标签写法，而是把它当成：

一棵“有序树 + 属性 + 文本”的数据结构
程序读的不是字符流，而是结构。

本文从这个树模型出发，系统整理 XML 的核心语法与常见机制：text/tail、XPath、Namespace、CDATA，并给出 Python（ElementTree）与命令行工具的可用做法。

1. Markup Language 是什么：用“标记”把文本变成结构
Markup Language（标记语言）的本质：用标签（tag）给文本加上边界、层级与语义。
<robot name="taco">
  <link name="base_link"/>
</robot>
这不是“字符串里夹标签”，而是树：
robot (name="taco")
└── link (name="base_link")
标签名是“语义”，属性是“参数”，嵌套是“结构”。
因此 XML 的强项是：跨系统传递结构化语义（而不是仅仅渲染）。

2. XML 的基本语法（严格规则）
XML 比 HTML 严格得多。常见约束如下：
2.1 标签必须闭合
✅ 正确：
<mesh></mesh>
<mesh />
❌ 错误：
<mesh>
2.2 区分大小写
<Mesh> ≠ <mesh>
2.3 属性必须加引号
✅
<link name="base_link"/>
❌
<link name=base_link/>
2.4 必须正确嵌套，且只有一个根节点
✅
<a><b/></a>
❌
<a><b></a></b>

3. Element / Attribute / Text：把 XML 当成对象模型
一个元素（Element）由：'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://analyst-huang.github.io/posts/"},{"@type":"ListItem","position":3,"name":"XML 语法与工程实践：从树模型到 XPath、Namespace 与 CDATA","item":"https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/xml/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"XML 语法与工程实践：从树模型到 XPath、Namespace 与 CDATA","name":"XML 语法与工程实践：从树模型到 XPath、Namespace 与 CDATA","description":"0. 这篇文章解决什么问题 XML（eXtensible Markup Language）经常被当作“带尖括号的文本”。但在工程场景（URDF、USD/Omniverse 配置、各种工具链描述文件）里，理解 XML 的关键并不是记住几个标签写法，而是把它当成：\n一棵“有序树 + 属性 + 文本”的数据结构\n程序读的不是字符流，而是结构。\n本文从这个树模型出发，系统整理 XML 的核心语法与常见机制：text/tail、XPath、Namespace、CDATA，并给出 Python（ElementTree）与命令行工具的可用做法。\n1. Markup Language 是什么：用“标记”把文本变成结构 Markup Language（标记语言）的本质：用标签（tag）给文本加上边界、层级与语义。\n\u0026lt;robot name=\u0026#34;taco\u0026#34;\u0026gt; \u0026lt;link name=\u0026#34;base_link\u0026#34;/\u0026gt; \u0026lt;/robot\u0026gt; 这不是“字符串里夹标签”，而是树：\nrobot (name=\u0026#34;taco\u0026#34;) └── link (name=\u0026#34;base_link\u0026#34;) 标签名是“语义”，属性是“参数”，嵌套是“结构”。\n因此 XML 的强项是：跨系统传递结构化语义（而不是仅仅渲染）。\n2. XML 的基本语法（严格规则） XML 比 HTML 严格得多。常见约束如下：\n2.1 标签必须闭合 ✅ 正确：\n\u0026lt;mesh\u0026gt;\u0026lt;/mesh\u0026gt; \u0026lt;mesh /\u0026gt; ❌ 错误：\n\u0026lt;mesh\u0026gt; 2.2 区分大小写 \u0026lt;Mesh\u0026gt; ≠ \u0026lt;mesh\u0026gt; 2.3 属性必须加引号 ✅\n\u0026lt;link name=\u0026#34;base_link\u0026#34;/\u0026gt; ❌\n\u0026lt;link name=base_link/\u0026gt; 2.4 必须正确嵌套，且只有一个根节点 ✅\n\u0026lt;a\u0026gt;\u0026lt;b/\u0026gt;\u0026lt;/a\u0026gt; ❌\n\u0026lt;a\u0026gt;\u0026lt;b\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/b\u0026gt; 3. Element / Attribute / Text：把 XML 当成对象模型 一个元素（Element）由：\n","keywords":["XML","URDF","XPath","Namespace","CDATA","Python"],"articleBody":"0. 这篇文章解决什么问题 XML（eXtensible Markup Language）经常被当作“带尖括号的文本”。但在工程场景（URDF、USD/Omniverse 配置、各种工具链描述文件）里，理解 XML 的关键并不是记住几个标签写法，而是把它当成：\n一棵“有序树 + 属性 + 文本”的数据结构\n程序读的不是字符流，而是结构。\n本文从这个树模型出发，系统整理 XML 的核心语法与常见机制：text/tail、XPath、Namespace、CDATA，并给出 Python（ElementTree）与命令行工具的可用做法。\n1. Markup Language 是什么：用“标记”把文本变成结构 Markup Language（标记语言）的本质：用标签（tag）给文本加上边界、层级与语义。\n","wordCount":"510","inLanguage":"en","datePublished":"2026-01-19T00:00:00Z","dateModified":"2026-01-19T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/xml/"},"publisher":{"@type":"Organization","name":"Blog","logo":{"@type":"ImageObject","url":"https://analyst-huang.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://analyst-huang.github.io/ accesskey=h title="Blog (Alt + H)">Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://analyst-huang.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://analyst-huang.github.io/about/ title=关于><span>关于</span></a></li><li><a href=https://analyst-huang.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://analyst-huang.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://analyst-huang.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">XML 语法与工程实践：从树模型到 XPath、Namespace 与 CDATA</h1><div class=post-meta><span title='2026-01-19 00:00:00 +0000 UTC'>January 19, 2026</span>&nbsp;·&nbsp;<span>3 min</span></div></header><div class=post-content><h2 id=0-这篇文章解决什么问题>0. 这篇文章解决什么问题<a hidden class=anchor aria-hidden=true href=#0-这篇文章解决什么问题>#</a></h2><p>XML（eXtensible Markup Language）经常被当作“带尖括号的文本”。但在工程场景（URDF、USD/Omniverse 配置、各种工具链描述文件）里，理解 XML 的关键并不是记住几个标签写法，而是把它当成：</p><blockquote><p><strong>一棵“有序树 + 属性 + 文本”的数据结构</strong><br>程序读的不是字符流，而是结构。</p></blockquote><p>本文从这个树模型出发，系统整理 XML 的核心语法与常见机制：<code>text/tail</code>、XPath、Namespace、CDATA，并给出 Python（ElementTree）与命令行工具的可用做法。</p><hr><h2 id=1-markup-language-是什么用标记把文本变成结构>1. Markup Language 是什么：用“标记”把文本变成结构<a hidden class=anchor aria-hidden=true href=#1-markup-language-是什么用标记把文本变成结构>#</a></h2><p><strong>Markup Language（标记语言）<strong>的本质：用标签（tag）给文本加上</strong>边界、层级与语义</strong>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;robot</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;taco&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;link</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;base_link&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/robot&gt;</span>
</span></span></code></pre></div><p>这不是“字符串里夹标签”，而是树：</p><pre tabindex=0><code>robot (name=&#34;taco&#34;)
└── link (name=&#34;base_link&#34;)
</code></pre><p>标签名是“语义”，属性是“参数”，嵌套是“结构”。<br>因此 XML 的强项是：<strong>跨系统传递结构化语义</strong>（而不是仅仅渲染）。</p><hr><h2 id=2-xml-的基本语法严格规则>2. XML 的基本语法（严格规则）<a hidden class=anchor aria-hidden=true href=#2-xml-的基本语法严格规则>#</a></h2><p>XML 比 HTML 严格得多。常见约束如下：</p><h3 id=21-标签必须闭合>2.1 标签必须闭合<a hidden class=anchor aria-hidden=true href=#21-标签必须闭合>#</a></h3><p>✅ 正确：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;mesh&gt;&lt;/mesh&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;mesh</span> <span style=color:#f92672>/&gt;</span>
</span></span></code></pre></div><p>❌ 错误：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;mesh&gt;</span>
</span></span></code></pre></div><h3 id=22-区分大小写>2.2 区分大小写<a hidden class=anchor aria-hidden=true href=#22-区分大小写>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;Mesh&gt;</span> ≠ <span style=color:#f92672>&lt;mesh&gt;</span>
</span></span></code></pre></div><h3 id=23-属性必须加引号>2.3 属性必须加引号<a hidden class=anchor aria-hidden=true href=#23-属性必须加引号>#</a></h3><p>✅</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;link</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;base_link&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span></code></pre></div><p>❌</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;link</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>base_link/</span><span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><h3 id=24-必须正确嵌套且只有一个根节点>2.4 必须正确嵌套，且只有一个根节点<a hidden class=anchor aria-hidden=true href=#24-必须正确嵌套且只有一个根节点>#</a></h3><p>✅</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;a&gt;&lt;b/&gt;&lt;/a&gt;</span>
</span></span></code></pre></div><p>❌</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;</span>
</span></span></code></pre></div><hr><h2 id=3-element--attribute--text把-xml-当成对象模型>3. Element / Attribute / Text：把 XML 当成对象模型<a hidden class=anchor aria-hidden=true href=#3-element--attribute--text把-xml-当成对象模型>#</a></h2><p>一个元素（Element）由：</p><ul><li><code>tag</code>：标签名</li><li><code>attrib</code>：属性字典（键值都是字符串）</li><li><code>text</code>：开始标签后、第一个子元素前的文本</li><li><code>children</code>：子元素列表</li><li><code>tail</code>：该元素结束标签后、下一个兄弟元素前的文本（见下一节）</li></ul><p>示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;scale&gt;</span>1 1 1<span style=color:#f92672>&lt;/scale&gt;</span>
</span></span></code></pre></div><p>在 Python 里（ElementTree）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span>elem<span style=color:#f92672>.</span>tag     <span style=color:#75715e># &#34;scale&#34;</span>
</span></span><span style=display:flex><span>elem<span style=color:#f92672>.</span>text    <span style=color:#75715e># &#34;1 1 1&#34;</span>
</span></span><span style=display:flex><span>elem<span style=color:#f92672>.</span>attrib  <span style=color:#75715e># {}</span>
</span></span></code></pre></div><hr><h2 id=4-text-与-tail尾文本tail到底有什么用>4. text 与 tail：尾文本（tail）到底有什么用<a hidden class=anchor aria-hidden=true href=#4-text-与-tail尾文本tail到底有什么用>#</a></h2><p>XML 支持<strong>混合内容（mixed content）</strong>：文本与子标签交错。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;p&gt;</span>
</span></span><span style=display:flex><span>  This is <span style=color:#f92672>&lt;b&gt;</span>important<span style=color:#f92672>&lt;/b&gt;</span> text.
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/p&gt;</span>
</span></span></code></pre></div><p>如果只保存 <code>p.text</code> 与 <code>b.text</code>，你会丢掉 <code>&lt;/b></code> 之后的 “ text.”<br>因此引入了 <code>tail</code>：</p><ul><li><code>p.text</code>：<code>"This is "</code></li><li><code>b.text</code>：<code>"important"</code></li><li><code>b.tail</code>：<code>" text."</code></li></ul><h3 id=41-工程意义什么时候你真的需要-tail>4.1 工程意义：什么时候你真的需要 tail<a hidden class=anchor aria-hidden=true href=#41-工程意义什么时候你真的需要-tail>#</a></h3><ul><li><strong>需要</strong>：HTML/富文本、文档转换（HTML → PDF）、带内联标记的内容。</li><li><strong>基本不需要</strong>：URDF、配置文件、纯结构数据。</li></ul><p>URDF 场景里，你几乎可以把 <code>tail</code> 当作“无关字段”。</p><hr><h2 id=5-xpath在-xml-树上按路径查询的语言>5. XPath：在 XML 树上“按路径查询”的语言<a hidden class=anchor aria-hidden=true href=#5-xpath在-xml-树上按路径查询的语言>#</a></h2><p><strong>XPath</strong>是一种在 XML 树上定位节点的查询语言。可以把它类比为：</p><ul><li>文件系统路径：<code>/home/user/file</code></li><li>JSON 路径：<code>data.users[0].name</code></li><li>XML 路径：XPath</li></ul><p>ElementTree 支持 XPath 的一个子集（足够解决 90% 实用问题）。</p><h3 id=51-常用-xpath-速查>5.1 常用 XPath 速查<a hidden class=anchor aria-hidden=true href=#51-常用-xpath-速查>#</a></h3><h4 id=递归搜索后代>递归搜索后代<a hidden class=anchor aria-hidden=true href=#递归搜索后代>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span>root<span style=color:#f92672>.</span>findall(<span style=color:#e6db74>&#34;.//mesh&#34;</span>)
</span></span></code></pre></div><p>含义：从当前节点递归找所有 <code>mesh</code>。</p><h4 id=直接子节点>直接子节点<a hidden class=anchor aria-hidden=true href=#直接子节点>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span>root<span style=color:#f92672>.</span>findall(<span style=color:#e6db74>&#34;link&#34;</span>)
</span></span></code></pre></div><p>只找 <code>root</code> 的直接子 <code>link</code>。</p><h4 id=指定路径>指定路径<a hidden class=anchor aria-hidden=true href=#指定路径>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span>root<span style=color:#f92672>.</span>findall(<span style=color:#e6db74>&#34;link/visual/geometry/mesh&#34;</span>)
</span></span></code></pre></div><h4 id=属性过滤>属性过滤<a hidden class=anchor aria-hidden=true href=#属性过滤>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span>root<span style=color:#f92672>.</span>findall(<span style=color:#e6db74>&#34;.//link[@name=&#39;base_link&#39;]&#34;</span>)
</span></span><span style=display:flex><span>root<span style=color:#f92672>.</span>findall(<span style=color:#e6db74>&#34;.//mesh[@filename]&#34;</span>)
</span></span></code></pre></div><blockquote><p>提示：XPath 过滤属性时只比较字符串；XML 没有原生数值类型。</p></blockquote><hr><h2 id=6-xml-vs-html看起来像设计目标完全不同>6. XML vs HTML：看起来像，设计目标完全不同<a hidden class=anchor aria-hidden=true href=#6-xml-vs-html看起来像设计目标完全不同>#</a></h2><table><thead><tr><th>维度</th><th>XML</th><th>HTML</th></tr></thead><tbody><tr><td>目标</td><td>描述结构与数据</td><td>描述网页展示</td></tr><tr><td>标签语义</td><td>可自定义</td><td>浏览器预定义</td></tr><tr><td>语法容错</td><td>极严格</td><td>很宽松</td></tr><tr><td>是否必须闭合</td><td>必须</td><td>经常可省略</td></tr><tr><td>是否区分大小写</td><td>是</td><td>基本不区分</td></tr><tr><td>错误处理</td><td>解析失败</td><td>尽量渲染</td></tr></tbody></table><p>一句话总结：</p><blockquote><p><strong>HTML 是展示语言；XML 是数据建模语言。</strong></p></blockquote><hr><h2 id=7-namespace同名标签如何避免语义冲突>7. Namespace：同名标签如何避免“语义冲突”<a hidden class=anchor aria-hidden=true href=#7-namespace同名标签如何避免语义冲突>#</a></h2><p>当不同标准或不同系统都用 <code>&lt;link></code>、<code>&lt;joint></code> 之类的名字时，会产生歧义。<br>**Namespace（命名空间）**的作用是给标签加上“全局唯一身份”。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;root</span> <span style=color:#a6e22e>xmlns:urdf=</span><span style=color:#e6db74>&#34;http://ros.org/urdf&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;urdf:joint</span> <span style=color:#a6e22e>name=</span><span style=color:#e6db74>&#34;j1&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/root&gt;</span>
</span></span></code></pre></div><p>在解析器内部，标签名通常会变成：</p><pre tabindex=0><code>{http://ros.org/urdf}joint
</code></pre><h3 id=71-elementtree-查找带-namespace-的节点>7.1 ElementTree 查找带 Namespace 的节点<a hidden class=anchor aria-hidden=true href=#71-elementtree-查找带-namespace-的节点>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span>ns <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#34;urdf&#34;</span>: <span style=color:#e6db74>&#34;http://ros.org/urdf&#34;</span>}
</span></span><span style=display:flex><span>root<span style=color:#f92672>.</span>findall(<span style=color:#e6db74>&#34;.//urdf:joint&#34;</span>, namespaces<span style=color:#f92672>=</span>ns)
</span></span></code></pre></div><blockquote><p>若你发现 <code>findall(".//joint")</code> 完全匹配不到，首先检查是否存在 namespace。</p></blockquote><hr><h2 id=8-cdata为什么它存在到底解决什么>8. CDATA：为什么它存在、到底解决什么<a hidden class=anchor aria-hidden=true href=#8-cdata为什么它存在到底解决什么>#</a></h2><p>XML 里有保留字符：<code>&lt;</code>、<code>></code>、<code>&</code> 等。<br>直接写代码或内嵌 HTML 常会“撞上语法”。</p><p>例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;script&gt;</span>
</span></span><span style=display:flex><span>  if (a <span style=color:#f92672>&lt; b</span><span style=color:#960050;background-color:#1e0010>)</span> <span style=color:#960050;background-color:#1e0010>{</span> <span style=color:#960050;background-color:#1e0010>...</span> <span style=color:#960050;background-color:#1e0010>}</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>&lt;/script</span><span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><p>这不是合法 XML，因为 <code>&lt;</code> 会被当作新标签开头。</p><p>**CDATA（Character Data）**告诉解析器：里面的内容按纯文本处理，不做标记解析。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;script&gt;</span><span style=color:#75715e>&lt;![CDATA[
</span></span></span><span style=display:flex><span><span style=color:#75715e>  if (a &lt; b &amp;&amp; b &gt; c) {
</span></span></span><span style=display:flex><span><span style=color:#75715e>    printf(&#34;hello &amp; goodbye&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e>  }
</span></span></span><span style=display:flex><span><span style=color:#75715e>]]&gt;</span><span style=color:#f92672>&lt;/script&gt;</span>
</span></span></code></pre></div><h3 id=81-cdata-的工程定位>8.1 CDATA 的工程定位<a hidden class=anchor aria-hidden=true href=#81-cdata-的工程定位>#</a></h3><ul><li><strong>适合</strong>：嵌入代码/模板、嵌入一段 HTML。</li><li><strong>不常见</strong>：URDF、一般配置文件（更推荐做转义：<code>&amp;lt;</code>、<code>&amp;amp;</code>）。</li></ul><hr><h2 id=9-python-实战elementtree-解析查找修改写回>9. Python 实战：ElementTree 解析、查找、修改、写回<a hidden class=anchor aria-hidden=true href=#9-python-实战elementtree-解析查找修改写回>#</a></h2><p>下面以 URDF 常见需求为例：批量替换 <code>&lt;mesh filename="..."></code>。</p><h3 id=91-解析与遍历>9.1 解析与遍历<a hidden class=anchor aria-hidden=true href=#91-解析与遍历>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> xml.etree.ElementTree <span style=color:#66d9ef>as</span> ET
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> pathlib <span style=color:#f92672>import</span> Path
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>urdf_path <span style=color:#f92672>=</span> Path(<span style=color:#e6db74>&#34;robot.urdf&#34;</span>)
</span></span><span style=display:flex><span>tree <span style=color:#f92672>=</span> ET<span style=color:#f92672>.</span>parse(urdf_path)
</span></span><span style=display:flex><span>root <span style=color:#f92672>=</span> tree<span style=color:#f92672>.</span>getroot()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> mesh <span style=color:#f92672>in</span> root<span style=color:#f92672>.</span>findall(<span style=color:#e6db74>&#34;.//mesh&#34;</span>):
</span></span><span style=display:flex><span>    print(mesh<span style=color:#f92672>.</span>attrib<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;filename&#34;</span>))
</span></span></code></pre></div><h3 id=92-由于没有-parent-指针构建-parent_map>9.2 由于没有 parent 指针：构建 parent_map<a hidden class=anchor aria-hidden=true href=#92-由于没有-parent-指针构建-parent_map>#</a></h3><p>ElementTree 的 Element 默认不知道 parent。需要自己建索引：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span>parent_map <span style=color:#f92672>=</span> {child: parent <span style=color:#66d9ef>for</span> parent <span style=color:#f92672>in</span> root<span style=color:#f92672>.</span>iter() <span style=color:#66d9ef>for</span> child <span style=color:#f92672>in</span> parent}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> mesh <span style=color:#f92672>in</span> root<span style=color:#f92672>.</span>findall(<span style=color:#e6db74>&#34;.//mesh&#34;</span>):
</span></span><span style=display:flex><span>    parent <span style=color:#f92672>=</span> parent_map<span style=color:#f92672>.</span>get(mesh)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;mesh parent tag:&#34;</span>, <span style=color:#66d9ef>None</span> <span style=color:#66d9ef>if</span> parent <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span> <span style=color:#66d9ef>else</span> parent<span style=color:#f92672>.</span>tag)
</span></span></code></pre></div><h3 id=93-修改属性并写回>9.3 修改属性并写回<a hidden class=anchor aria-hidden=true href=#93-修改属性并写回>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> mesh <span style=color:#f92672>in</span> root<span style=color:#f92672>.</span>findall(<span style=color:#e6db74>&#34;.//mesh&#34;</span>):
</span></span><span style=display:flex><span>    old <span style=color:#f92672>=</span> mesh<span style=color:#f92672>.</span>attrib<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;filename&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> old:
</span></span><span style=display:flex><span>        mesh<span style=color:#f92672>.</span>attrib[<span style=color:#e6db74>&#34;filename&#34;</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;urdf_</span><span style=color:#e6db74>{</span>old<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>tree<span style=color:#f92672>.</span>write(<span style=color:#e6db74>&#34;robot_out.urdf&#34;</span>, encoding<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;utf-8&#34;</span>, xml_declaration<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span></code></pre></div><hr><h2 id=10-命令行工具快速检查与批处理可选但很实用>10. 命令行工具：快速检查与批处理（可选但很实用）<a hidden class=anchor aria-hidden=true href=#10-命令行工具快速检查与批处理可选但很实用>#</a></h2><h3 id=101-xmllint格式化与校验常见于-linux>10.1 xmllint：格式化与校验（常见于 Linux）<a hidden class=anchor aria-hidden=true href=#101-xmllint格式化与校验常见于-linux>#</a></h3><p>安装（Debian/Ubuntu）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>sudo apt-get update
</span></span><span style=display:flex><span>sudo apt-get install -y libxml2-utils
</span></span></code></pre></div><ul><li><code>apt-get update</code>：更新包索引</li><li><code>install</code>：安装软件</li><li><code>-y</code>：自动确认</li></ul><p>格式化（pretty print）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>xmllint --format robot.urdf &gt; robot.pretty.urdf
</span></span></code></pre></div><ul><li><code>--format</code>：格式化输出</li><li><code>></code>：重定向到文件</li></ul><h3 id=102-xmlstarlet命令行-xpath-查询与编辑更强的批处理>10.2 xmlstarlet：命令行 XPath 查询与编辑（更强的批处理）<a hidden class=anchor aria-hidden=true href=#102-xmlstarlet命令行-xpath-查询与编辑更强的批处理>#</a></h3><p>安装（Debian/Ubuntu）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>sudo apt-get update
</span></span><span style=display:flex><span>sudo apt-get install -y xmlstarlet
</span></span></code></pre></div><p>查询所有 mesh 的 filename：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>xmlstarlet sel -t -m <span style=color:#e6db74>&#34;//mesh&#34;</span> -v <span style=color:#e6db74>&#34;@filename&#34;</span> -n robot.urdf
</span></span></code></pre></div><ul><li><code>sel</code>：select</li><li><code>-t</code>：模板输出</li><li><code>-m "//mesh"</code>：匹配节点集合</li><li><code>-v "@filename"</code>：输出属性</li><li><code>-n</code>：换行</li></ul><hr><h2 id=11-常见坑与最佳实践尤其是-urdf配置类-xml>11. 常见坑与最佳实践（尤其是 URDF/配置类 XML）<a hidden class=anchor aria-hidden=true href=#11-常见坑与最佳实践尤其是-urdf配置类-xml>#</a></h2><ol><li><strong>空白与换行是文本</strong>：不小心会进入 <code>.text</code> / <code>.tail</code>，但 URDF 通常可忽略。</li><li><strong>属性值都是字符串</strong>：比较/计算前自己转类型。</li><li><strong>Namespace 导致 findall 失效</strong>：匹配不到先检查 <code>root.tag</code> 是否带 <code>{...}</code>。</li><li><strong>路径不是“相对文件”的概念</strong>：URDF 的 mesh 路径含义取决于解析器（有的按 URDF 文件目录，有的按 package:// 规则）。</li><li><strong>写回时注意 encoding 与 xml_declaration</strong>：跨平台工具链更稳。</li></ol><hr><h2 id=12-小结>12. 小结<a hidden class=anchor aria-hidden=true href=#12-小结>#</a></h2><ul><li>XML 是<strong>树结构的数据模型</strong>，不是“带尖括号的字符串”。</li><li><code>text/tail</code> 为混合内容服务；结构数据场景多可忽略 tail。</li><li>XPath 是树查询语言，能显著简化定位与批量修改。</li><li>Namespace 解决同名标签冲突，是跨标准组合的基础设施。</li><li>CDATA 用来“关闭解析器”，安全嵌入 <code>&lt;</code>、<code>&</code> 等敏感字符内容。</li><li>ElementTree 实用但不带 parent 指针，常用 <code>parent_map</code> 补齐。</li></ul><hr><h2 id=附速查清单复制即用>附：速查清单（复制即用）<a hidden class=anchor aria-hidden=true href=#附速查清单复制即用>#</a></h2><ul><li>递归找节点：<code>.//tag</code></li><li>过滤属性：<code>.//tag[@attr='value']</code></li><li>取属性：<code>elem.attrib.get("attr")</code></li><li>parent_map：<code>{child: parent for parent in root.iter() for child in parent}</code></li><li>写回：<code>tree.write(..., encoding="utf-8", xml_declaration=True)</code></li><li>发现匹配不到：先检查 namespace（<code>root.tag</code> 是否带 <code>{...}</code>）</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://analyst-huang.github.io/tags/xml/>XML</a></li><li><a href=https://analyst-huang.github.io/tags/urdf/>URDF</a></li><li><a href=https://analyst-huang.github.io/tags/xpath/>XPath</a></li><li><a href=https://analyst-huang.github.io/tags/namespace/>Namespace</a></li><li><a href=https://analyst-huang.github.io/tags/cdata/>CDATA</a></li><li><a href=https://analyst-huang.github.io/tags/python/>Python</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://analyst-huang.github.io/>Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>