<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>从第一性原理理解 CSS：规则系统、约束求解与渲染管线 | Blog</title><meta name=keywords content="CSS,浏览器,前端基础,渲染"><meta name=description content="用第一性原理视角把 CSS 抽象为：树结构上的规则系统与声明式约束语言，并连接到浏览器的渲染管线。"><meta name=author content><link rel=canonical href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/css-first-principles-hugo/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://analyst-huang.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://analyst-huang.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://analyst-huang.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://analyst-huang.github.io/apple-touch-icon.png><link rel=mask-icon href=https://analyst-huang.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/css-first-principles-hugo/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/css-first-principles-hugo/"><meta property="og:site_name" content="Blog"><meta property="og:title" content="从第一性原理理解 CSS：规则系统、约束求解与渲染管线"><meta property="og:description" content="用第一性原理视角把 CSS 抽象为：树结构上的规则系统与声明式约束语言，并连接到浏览器的渲染管线。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-26T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-26T00:00:00+00:00"><meta property="article:tag" content="CSS"><meta property="article:tag" content="浏览器"><meta property="article:tag" content="前端基础"><meta property="article:tag" content="渲染"><meta name=twitter:card content="summary"><meta name=twitter:title content="从第一性原理理解 CSS：规则系统、约束求解与渲染管线"><meta name=twitter:description content="用第一性原理视角把 CSS 抽象为：树结构上的规则系统与声明式约束语言，并连接到浏览器的渲染管线。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://analyst-huang.github.io/posts/"},{"@type":"ListItem","position":3,"name":"从第一性原理理解 CSS：规则系统、约束求解与渲染管线","item":"https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/css-first-principles-hugo/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"从第一性原理理解 CSS：规则系统、约束求解与渲染管线","name":"从第一性原理理解 CSS：规则系统、约束求解与渲染管线","description":"用第一性原理视角把 CSS 抽象为：树结构上的规则系统与声明式约束语言，并连接到浏览器的渲染管线。","keywords":["CSS","浏览器","前端基础","渲染"],"articleBody":"CSS 往往被误解为“调颜色、调间距”的属性集合。但如果从第一性原理出发，CSS 更像一门作用于树结构的数据上的声明式规则系统：它描述约束，浏览器负责求解与渲染。本文尝试用尽可能少的经验主义记忆，构造一个可复用的抽象模型，帮助你在遇到布局、优先级、性能等问题时能“从底层推回去”。\n1. 浏览器到底在做什么 浏览器的核心任务可以拆成三步：\n解析：把 HTML 解析成结构化的树（DOM）。 求解：为树上每个节点求出“最终样式”（computed style），并进一步求出几何信息（layout：位置与尺寸）。 绘制：把几何与视觉属性转成像素（paint），再进行图层合成（composite）。 CSS 处在第 2 步的上游：它提供规则与约束，使浏览器能把“结构树”变成“可布局、可绘制的对象”。\n2. CSS 的本体抽象：规则集合作用于树 把一个 CSS 文件抽象成一堆规则的集合：\n规则（rule） = 选择器（selector） + 声明块（declarations） 选择器：对树节点成立与否的谓词（predicate） 声明：对节点施加的属性约束（property constraints） 最典型的形式：\nselector { property: value; property: value; } 更形式化一点（接近数学/编译器视角）：\n设规则集合 R = {r_1, r_2, ...} 每条规则 r_i = (S_i, D_i) S_i：选择器谓词（对节点及其上下文求值） D_i：一组声明（属性→值） 对任意节点 n，若 n ⊨ S_i（选择器对该节点成立），则 D_i 参与该节点的样式计算。\n这里有一个关键点：CSS 不会“把样式写进节点”。浏览器内部更像维护一张映射：\nnode -\u003e computed_style 样式是派生状态，而非原始数据结构的一部分。\n3. 选择器不是“指针”，而是“逻辑条件” 很多初学者把 selector 理解为“找到某个元素”，但更准确的是：\n选择器是一种对节点与其上下文（父/子/兄弟/状态）成立与否的逻辑条件。\n例如：\ndiv.card \u003e p:first-child:hover { ... } 这条 selector 的语义可以理解为：\n节点标签为 p 父节点为 div 且带 .card p 是父节点的第一个子元素 节点处于 :hover 交互状态 它不是一次性“查找完成就结束”，而是一个可被重复求值的谓词：DOM 结构变化、class 变化、交互状态变化都可能导致该谓词在某个节点上从 false 变 true，或从 true 变 false。\n4. 层叠与归约：不是“命中即生效”，而是“多规则合并” 真正的执行模型并不是：\nselector 命中 → 立刻改样式\n而更接近：\n对每个节点收集所有命中它的规则 按优先级对规则排序 对每个属性进行归约（reduce），得到最终值 可以写成伪代码：\nRules(n) = { r in R | selector(r) matches n } ComputedStyle(n) = reduce_by_property( sort_by_priority(Rules(n)) ) 4.1 优先级（cascade）的直觉模型 排序的关键维度（从常见到少见）：\n来源与层级：用户代理样式（浏览器默认）、作者样式（你写的）、用户样式（辅助功能）等 重要性：!important 会提升权重（不建议滥用） 特异性（specificity）：更“具体”的选择器更优先 声明顺序：同等优先级时，后写的覆盖先写的 你可以把它理解为一个比较器：\n(priority, specificity, order) 越大越赢 4.2 继承：不是“规则继承”，而是“属性级传播” 继承是 CSS 语义中很容易混淆的一点：\n不是某条规则从父节点“继承给子节点” 而是部分属性（如 color, font-family）默认会从父节点的 computed style 传播到子节点 因此继承发生在“computed style 形成”阶段，是属性语义的一部分。\n5. 样式、布局、绘制：三种不同层级的影响 从第一性原理看，CSS 属性并不都属于同一类问题：\nStyle（样式计算）：例如 color, font-family Layout（几何求解）：例如 display, width, margin, position Paint（绘制）：例如 background, border, box-shadow Composite（合成）：例如某些情况下的 transform, opacity 这解释了一个常见现象：\n改 color 可能只需要重绘（repaint） 改 width 往往触发布局（reflow/layout）并连带重绘 改 transform 在很多情况下只需要合成（性能更好） 理解这四层，是你判断性能与“为什么页面抖了一下”的关键。\n6. display 与 position：约束系统的“选择开关” 6.1 display：你选择哪套布局规则 display 决定节点参与哪种布局算法：\nblock：垂直堆叠、通常占满可用宽度 inline：像文本一样流动、换行 flex：一维空间分配与对齐（主轴/交叉轴） grid：二维网格约束求解 从抽象上说：\ndisplay 选择的是“几何求解器”。\n6.2 position：你是否还在“正常约束图”里 static：完全参与正常流（normal flow） relative：参与正常流，但最终位置会产生偏移 absolute：脱离正常流，使用包含块（containing block）定位 fixed：相对视口定位 sticky：在滚动阈值前后切换行为 从约束系统角度：\nabsolute/fixed 近似把节点从“正常布局约束图”中剪出来，单独求坐标。\n7. CSS 是否与 HTML 强绑定 不强绑定。CSS 抽象上作用于“树结构的节点系统”，HTML DOM 只是最常见的宿主。\n在浏览器架构中：\nHTML → DOM Tree CSS → CSSOM（规则对象/样式表对象） DOM + CSSOM → 计算得到 Render Tree（参与渲染的对象集合） CSS 的选择器依赖的是：节点名、属性、层级关系、状态；它不理解 HTML 的语义（比如“这个 div 是导航”），更不包含行为逻辑。\n因此：只要你有一个树结构 + 节点属性集合，就可以套用“selector 谓词 + 声明约束”的思想。这也是为什么很多 UI 框架都有“类 CSS 的样式系统”。\n8. 一个可复用的心智模型（遇到问题时按它排查） 当你遇到“样式不生效 / 布局不对 / 覆盖不了”时，用下面的顺序排查往往最稳：\n匹配：选择器谓词是否成立？（节点是否真的命中） 层叠：是否被更高优先级的规则覆盖？（specificity / order / !important） 继承：该属性是否继承/是否需要显式指定？ 布局求解器：display/position 是否让你处在预期的布局模型里？ 阶段成本：这次改动触发了 layout 还是只触发 paint/composite？ 这套模型的好处是：你不用背“经验口诀”，而是把每个现象归因到渲染管线的某个阶段。\n9. 结语：用“规则系统 + 约束求解”的眼睛看 CSS 一句话总结本文的抽象：\nCSS 是作用在树结构上的声明式规则系统：选择器是谓词，声明是约束；浏览器收集匹配规则并层叠归约成 computed style，再将其作为布局与绘制的输入。\n当你把 CSS 看成“几何约束的 DSL”，你会发现：很多看似诡异的行为（覆盖、继承、布局抖动、性能差异）都变得可推导、可预测。\n附：最小示例（把抽象落回具体） \u003cdiv class=\"card\"\u003e \u003cp\u003eHello\u003c/p\u003e \u003c/div\u003e p { color: blue; } /* 规则 A：命中所有 p */ .card p { color: green; } /* 规则 B：更具体，覆盖 A */ 对 p 节点：\n命中规则集合 = {A, B} 排序后 B 优先 归约结果 color = green 这就是 CSS 在做的事情。\n","wordCount":"332","inLanguage":"en","datePublished":"2026-01-26T00:00:00Z","dateModified":"2026-01-26T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/css-first-principles-hugo/"},"publisher":{"@type":"Organization","name":"Blog","logo":{"@type":"ImageObject","url":"https://analyst-huang.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://analyst-huang.github.io/ accesskey=h title="Blog (Alt + H)">Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://analyst-huang.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://analyst-huang.github.io/about/ title=关于><span>关于</span></a></li><li><a href=https://analyst-huang.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://analyst-huang.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://analyst-huang.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">从第一性原理理解 CSS：规则系统、约束求解与渲染管线</h1><div class=post-description>用第一性原理视角把 CSS 抽象为：树结构上的规则系统与声明式约束语言，并连接到浏览器的渲染管线。</div><div class=post-meta><span title='2026-01-26 00:00:00 +0000 UTC'>January 26, 2026</span>&nbsp;·&nbsp;<span>2 min</span></div></header><div class=post-content><p>CSS 往往被误解为“调颜色、调间距”的属性集合。但如果从第一性原理出发，CSS 更像一门<strong>作用于树结构的数据上的声明式规则系统</strong>：它描述约束，浏览器负责求解与渲染。本文尝试用尽可能少的经验主义记忆，构造一个可复用的抽象模型，帮助你在遇到布局、优先级、性能等问题时能“从底层推回去”。</p><h2 id=1-浏览器到底在做什么>1. 浏览器到底在做什么<a hidden class=anchor aria-hidden=true href=#1-浏览器到底在做什么>#</a></h2><p>浏览器的核心任务可以拆成三步：</p><ol><li><strong>解析</strong>：把 HTML 解析成结构化的树（DOM）。</li><li><strong>求解</strong>：为树上每个节点求出“最终样式”（computed style），并进一步求出几何信息（layout：位置与尺寸）。</li><li><strong>绘制</strong>：把几何与视觉属性转成像素（paint），再进行图层合成（composite）。</li></ol><p>CSS 处在第 2 步的上游：它提供规则与约束，使浏览器能把“结构树”变成“可布局、可绘制的对象”。</p><h2 id=2-css-的本体抽象规则集合作用于树>2. CSS 的本体抽象：规则集合作用于树<a hidden class=anchor aria-hidden=true href=#2-css-的本体抽象规则集合作用于树>#</a></h2><p>把一个 CSS 文件抽象成一堆规则的集合：</p><ul><li><strong>规则（rule）</strong> = 选择器（selector） + 声明块（declarations）</li><li><strong>选择器</strong>：对树节点成立与否的<strong>谓词</strong>（predicate）</li><li><strong>声明</strong>：对节点施加的<strong>属性约束</strong>（property constraints）</li></ul><p>最典型的形式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>selector</span> { property: value; property: value; }
</span></span></code></pre></div><p>更形式化一点（接近数学/编译器视角）：</p><ul><li>设规则集合 <code>R = {r_1, r_2, ...}</code></li><li>每条规则 <code>r_i = (S_i, D_i)</code><ul><li><code>S_i</code>：选择器谓词（对节点及其上下文求值）</li><li><code>D_i</code>：一组声明（属性→值）</li></ul></li></ul><p>对任意节点 <code>n</code>，若 <code>n ⊨ S_i</code>（选择器对该节点成立），则 <code>D_i</code> 参与该节点的样式计算。</p><p>这里有一个关键点：<strong>CSS 不会“把样式写进节点”</strong>。浏览器内部更像维护一张映射：</p><ul><li><code>node -> computed_style</code></li></ul><p>样式是派生状态，而非原始数据结构的一部分。</p><h2 id=3-选择器不是指针而是逻辑条件>3. 选择器不是“指针”，而是“逻辑条件”<a hidden class=anchor aria-hidden=true href=#3-选择器不是指针而是逻辑条件>#</a></h2><p>很多初学者把 selector 理解为“找到某个元素”，但更准确的是：</p><blockquote><p>选择器是一种对节点与其上下文（父/子/兄弟/状态）成立与否的逻辑条件。</p></blockquote><p>例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>div</span>.<span style=color:#a6e22e>card</span> <span style=color:#f92672>&gt;</span> <span style=color:#f92672>p</span>:<span style=color:#a6e22e>first-child</span>:<span style=color:#a6e22e>hover</span> { <span style=color:#960050;background-color:#1e0010>...</span> }
</span></span></code></pre></div><p>这条 selector 的语义可以理解为：</p><ul><li>节点标签为 <code>p</code></li><li>父节点为 <code>div</code> 且带 <code>.card</code></li><li><code>p</code> 是父节点的第一个子元素</li><li>节点处于 <code>:hover</code> 交互状态</li></ul><p>它不是一次性“查找完成就结束”，而是一个<strong>可被重复求值的谓词</strong>：DOM 结构变化、class 变化、交互状态变化都可能导致该谓词在某个节点上从 false 变 true，或从 true 变 false。</p><h2 id=4-层叠与归约不是命中即生效而是多规则合并>4. 层叠与归约：不是“命中即生效”，而是“多规则合并”<a hidden class=anchor aria-hidden=true href=#4-层叠与归约不是命中即生效而是多规则合并>#</a></h2><p>真正的执行模型并不是：</p><blockquote><p>selector 命中 → 立刻改样式</p></blockquote><p>而更接近：</p><ol><li>对每个节点收集所有命中它的规则</li><li>按优先级对规则排序</li><li>对每个属性进行归约（reduce），得到最终值</li></ol><p>可以写成伪代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>Rules(n) = { r in R | selector(r) matches n }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ComputedStyle(n) =
</span></span><span style=display:flex><span>  reduce_by_property(
</span></span><span style=display:flex><span>    sort_by_priority(Rules(n))
</span></span><span style=display:flex><span>  )
</span></span></code></pre></div><h3 id=41-优先级cascade的直觉模型>4.1 优先级（cascade）的直觉模型<a hidden class=anchor aria-hidden=true href=#41-优先级cascade的直觉模型>#</a></h3><p>排序的关键维度（从常见到少见）：</p><ul><li><strong>来源与层级</strong>：用户代理样式（浏览器默认）、作者样式（你写的）、用户样式（辅助功能）等</li><li><strong>重要性</strong>：<code>!important</code> 会提升权重（不建议滥用）</li><li><strong>特异性（specificity）</strong>：更“具体”的选择器更优先</li><li><strong>声明顺序</strong>：同等优先级时，后写的覆盖先写的</li></ul><p>你可以把它理解为一个比较器：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>(priority, specificity, order) 越大越赢
</span></span></code></pre></div><h3 id=42-继承不是规则继承而是属性级传播>4.2 继承：不是“规则继承”，而是“属性级传播”<a hidden class=anchor aria-hidden=true href=#42-继承不是规则继承而是属性级传播>#</a></h3><p>继承是 CSS 语义中很容易混淆的一点：</p><ul><li>不是某条规则从父节点“继承给子节点”</li><li>而是<strong>部分属性</strong>（如 <code>color</code>, <code>font-family</code>）默认会从父节点的 computed style 传播到子节点</li></ul><p>因此继承发生在“computed style 形成”阶段，是属性语义的一部分。</p><h2 id=5-样式布局绘制三种不同层级的影响>5. 样式、布局、绘制：三种不同层级的影响<a hidden class=anchor aria-hidden=true href=#5-样式布局绘制三种不同层级的影响>#</a></h2><p>从第一性原理看，CSS 属性并不都属于同一类问题：</p><ol><li><strong>Style（样式计算）</strong>：例如 <code>color</code>, <code>font-family</code></li><li><strong>Layout（几何求解）</strong>：例如 <code>display</code>, <code>width</code>, <code>margin</code>, <code>position</code></li><li><strong>Paint（绘制）</strong>：例如 <code>background</code>, <code>border</code>, <code>box-shadow</code></li><li><strong>Composite（合成）</strong>：例如某些情况下的 <code>transform</code>, <code>opacity</code></li></ol><p>这解释了一个常见现象：</p><ul><li>改 <code>color</code> 可能只需要重绘（repaint）</li><li>改 <code>width</code> 往往触发布局（reflow/layout）并连带重绘</li><li>改 <code>transform</code> 在很多情况下只需要合成（性能更好）</li></ul><p>理解这四层，是你判断性能与“为什么页面抖了一下”的关键。</p><h2 id=6-display-与-position约束系统的选择开关>6. display 与 position：约束系统的“选择开关”<a hidden class=anchor aria-hidden=true href=#6-display-与-position约束系统的选择开关>#</a></h2><h3 id=61-display你选择哪套布局规则>6.1 <code>display</code>：你选择哪套布局规则<a hidden class=anchor aria-hidden=true href=#61-display你选择哪套布局规则>#</a></h3><p><code>display</code> 决定节点参与哪种布局算法：</p><ul><li><code>block</code>：垂直堆叠、通常占满可用宽度</li><li><code>inline</code>：像文本一样流动、换行</li><li><code>flex</code>：一维空间分配与对齐（主轴/交叉轴）</li><li><code>grid</code>：二维网格约束求解</li></ul><p>从抽象上说：</p><blockquote><p><code>display</code> 选择的是“几何求解器”。</p></blockquote><h3 id=62-position你是否还在正常约束图里>6.2 <code>position</code>：你是否还在“正常约束图”里<a hidden class=anchor aria-hidden=true href=#62-position你是否还在正常约束图里>#</a></h3><ul><li><code>static</code>：完全参与正常流（normal flow）</li><li><code>relative</code>：参与正常流，但最终位置会产生偏移</li><li><code>absolute</code>：脱离正常流，使用包含块（containing block）定位</li><li><code>fixed</code>：相对视口定位</li><li><code>sticky</code>：在滚动阈值前后切换行为</li></ul><p>从约束系统角度：</p><blockquote><p><code>absolute/fixed</code> 近似把节点从“正常布局约束图”中剪出来，单独求坐标。</p></blockquote><h2 id=7-css-是否与-html-强绑定>7. CSS 是否与 HTML 强绑定<a hidden class=anchor aria-hidden=true href=#7-css-是否与-html-强绑定>#</a></h2><p>不强绑定。CSS 抽象上作用于“树结构的节点系统”，HTML DOM 只是最常见的宿主。</p><p>在浏览器架构中：</p><ul><li>HTML → DOM Tree</li><li>CSS → CSSOM（规则对象/样式表对象）</li><li>DOM + CSSOM → 计算得到 Render Tree（参与渲染的对象集合）</li></ul><p>CSS 的选择器依赖的是：节点名、属性、层级关系、状态；它不理解 HTML 的语义（比如“这个 div 是导航”），更不包含行为逻辑。</p><p>因此：只要你有一个树结构 + 节点属性集合，就可以套用“selector 谓词 + 声明约束”的思想。这也是为什么很多 UI 框架都有“类 CSS 的样式系统”。</p><h2 id=8-一个可复用的心智模型遇到问题时按它排查>8. 一个可复用的心智模型（遇到问题时按它排查）<a hidden class=anchor aria-hidden=true href=#8-一个可复用的心智模型遇到问题时按它排查>#</a></h2><p>当你遇到“样式不生效 / 布局不对 / 覆盖不了”时，用下面的顺序排查往往最稳：</p><ol><li><strong>匹配</strong>：选择器谓词是否成立？（节点是否真的命中）</li><li><strong>层叠</strong>：是否被更高优先级的规则覆盖？（specificity / order / !important）</li><li><strong>继承</strong>：该属性是否继承/是否需要显式指定？</li><li><strong>布局求解器</strong>：display/position 是否让你处在预期的布局模型里？</li><li><strong>阶段成本</strong>：这次改动触发了 layout 还是只触发 paint/composite？</li></ol><p>这套模型的好处是：你不用背“经验口诀”，而是把每个现象归因到渲染管线的某个阶段。</p><h2 id=9-结语用规则系统--约束求解的眼睛看-css>9. 结语：用“规则系统 + 约束求解”的眼睛看 CSS<a hidden class=anchor aria-hidden=true href=#9-结语用规则系统--约束求解的眼睛看-css>#</a></h2><p>一句话总结本文的抽象：</p><blockquote><p><strong>CSS 是作用在树结构上的声明式规则系统：选择器是谓词，声明是约束；浏览器收集匹配规则并层叠归约成 computed style，再将其作为布局与绘制的输入。</strong></p></blockquote><p>当你把 CSS 看成“几何约束的 DSL”，你会发现：很多看似诡异的行为（覆盖、继承、布局抖动、性能差异）都变得可推导、可预测。</p><hr><h3 id=附最小示例把抽象落回具体>附：最小示例（把抽象落回具体）<a hidden class=anchor aria-hidden=true href=#附最小示例把抽象落回具体>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>class</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;card&#34;</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#f92672>p</span>&gt;Hello&lt;/<span style=color:#f92672>p</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>div</span>&gt;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-css data-lang=css><span style=display:flex><span><span style=color:#f92672>p</span> { <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>blue</span>; }          <span style=color:#75715e>/* 规则 A：命中所有 p */</span>
</span></span><span style=display:flex><span>.<span style=color:#a6e22e>card</span> <span style=color:#f92672>p</span> { <span style=color:#66d9ef>color</span>: <span style=color:#66d9ef>green</span>; }   <span style=color:#75715e>/* 规则 B：更具体，覆盖 A */</span>
</span></span></code></pre></div><p>对 <code>p</code> 节点：</p><ul><li>命中规则集合 = {A, B}</li><li>排序后 B 优先</li><li>归约结果 <code>color = green</code></li></ul><p>这就是 CSS 在做的事情。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://analyst-huang.github.io/tags/css/>CSS</a></li><li><a href=https://analyst-huang.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/>浏览器</a></li><li><a href=https://analyst-huang.github.io/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/>前端基础</a></li><li><a href=https://analyst-huang.github.io/tags/%E6%B8%B2%E6%9F%93/>渲染</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://analyst-huang.github.io/>Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>