<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>配置RSS reader | Blog</title><meta name=keywords content><meta name=description content='Feed 与 RSS：从信息推送到个人信息流的技术基础
本文从工程与使用两个层面，系统性介绍： 1. Feed 与 RSS 的概念与格式 2.
RSS Reader 的实际好处 3. 如何将邮件转换为 RSS 4. 如何导出与迁移 OPML
配置
适合希望构建个人信息流管道（personal information pipeline）的技术用户。


Feed 与 RSS

1.1 什么是 Feed
Feed 是一种“可被机器订阅的更新流”，本质是： - 按时间排序的条目（items /
entries） - 每条包含：标题、链接、摘要、发布时间等元数据 -
客户端可以周期性拉取并增量更新
Feed 是概念层；RSS / Atom 是实现层的具体协议格式。
1.2 一个最小 RSS 结构
<rss version="2.0">
  <channel>
    <title>Example Feed</title>
    <link>https://example.com</link>
    <item>
      <title>Post Title</title>
      <link>https://example.com/post</link>
      <pubDate>Mon, 12 Jan 2026 12:00:00 GMT</pubDate>
      <description>Summary...</description>
    </item>
  </channel>
</rss>

RSS Reader 的工作本质是： - 周期性 GET - 解析 XML - 去重 -
按时间排序展示'><meta name=author content><link rel=canonical href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/rss_reader/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://analyst-huang.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://analyst-huang.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://analyst-huang.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://analyst-huang.github.io/apple-touch-icon.png><link rel=mask-icon href=https://analyst-huang.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/rss_reader/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\\\(",right:"\\\\)",display:!1},{left:"\\\\[",right:"\\\\]",display:!0}]})})</script><meta property="og:url" content="https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/rss_reader/"><meta property="og:site_name" content="Blog"><meta property="og:title" content="配置RSS reader"><meta property="og:description" content='Feed 与 RSS：从信息推送到个人信息流的技术基础
本文从工程与使用两个层面，系统性介绍： 1. Feed 与 RSS 的概念与格式 2. RSS Reader 的实际好处 3. 如何将邮件转换为 RSS 4. 如何导出与迁移 OPML 配置
适合希望构建个人信息流管道（personal information pipeline）的技术用户。
Feed 与 RSS 1.1 什么是 Feed
Feed 是一种“可被机器订阅的更新流”，本质是： - 按时间排序的条目（items / entries） - 每条包含：标题、链接、摘要、发布时间等元数据 - 客户端可以周期性拉取并增量更新
Feed 是概念层；RSS / Atom 是实现层的具体协议格式。
1.2 一个最小 RSS 结构
<rss version="2.0"> <channel> <title>Example Feed</title> <link>https://example.com</link> <item> <title>Post Title</title> <link>https://example.com/post</link> <pubDate>Mon, 12 Jan 2026 12:00:00 GMT</pubDate> <description>Summary...</description> </item> </channel> </rss> RSS Reader 的工作本质是： - 周期性 GET - 解析 XML - 去重 - 按时间排序展示'><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-11T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-11T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="配置RSS reader"><meta name=twitter:description content='Feed 与 RSS：从信息推送到个人信息流的技术基础
本文从工程与使用两个层面，系统性介绍： 1. Feed 与 RSS 的概念与格式 2.
RSS Reader 的实际好处 3. 如何将邮件转换为 RSS 4. 如何导出与迁移 OPML
配置
适合希望构建个人信息流管道（personal information pipeline）的技术用户。


Feed 与 RSS

1.1 什么是 Feed
Feed 是一种“可被机器订阅的更新流”，本质是： - 按时间排序的条目（items /
entries） - 每条包含：标题、链接、摘要、发布时间等元数据 -
客户端可以周期性拉取并增量更新
Feed 是概念层；RSS / Atom 是实现层的具体协议格式。
1.2 一个最小 RSS 结构
<rss version="2.0">
  <channel>
    <title>Example Feed</title>
    <link>https://example.com</link>
    <item>
      <title>Post Title</title>
      <link>https://example.com/post</link>
      <pubDate>Mon, 12 Jan 2026 12:00:00 GMT</pubDate>
      <description>Summary...</description>
    </item>
  </channel>
</rss>

RSS Reader 的工作本质是： - 周期性 GET - 解析 XML - 去重 -
按时间排序展示'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://analyst-huang.github.io/posts/"},{"@type":"ListItem","position":3,"name":"配置RSS reader","item":"https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/rss_reader/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"配置RSS reader","name":"配置RSS reader","description":"Feed 与 RSS：从信息推送到个人信息流的技术基础\n本文从工程与使用两个层面，系统性介绍： 1. Feed 与 RSS 的概念与格式 2. RSS Reader 的实际好处 3. 如何将邮件转换为 RSS 4. 如何导出与迁移 OPML 配置\n适合希望构建个人信息流管道（personal information pipeline）的技术用户。\nFeed 与 RSS 1.1 什么是 Feed\nFeed 是一种“可被机器订阅的更新流”，本质是： - 按时间排序的条目（items / entries） - 每条包含：标题、链接、摘要、发布时间等元数据 - 客户端可以周期性拉取并增量更新\nFeed 是概念层；RSS / Atom 是实现层的具体协议格式。\n1.2 一个最小 RSS 结构\n\u0026lt;rss version=\u0026quot;2.0\u0026quot;\u0026gt; \u0026lt;channel\u0026gt; \u0026lt;title\u0026gt;Example Feed\u0026lt;/title\u0026gt; \u0026lt;link\u0026gt;https://example.com\u0026lt;/link\u0026gt; \u0026lt;item\u0026gt; \u0026lt;title\u0026gt;Post Title\u0026lt;/title\u0026gt; \u0026lt;link\u0026gt;https://example.com/post\u0026lt;/link\u0026gt; \u0026lt;pubDate\u0026gt;Mon, 12 Jan 2026 12:00:00 GMT\u0026lt;/pubDate\u0026gt; \u0026lt;description\u0026gt;Summary...\u0026lt;/description\u0026gt; \u0026lt;/item\u0026gt; \u0026lt;/channel\u0026gt; \u0026lt;/rss\u0026gt; RSS Reader 的工作本质是： - 周期性 GET - 解析 XML - 去重 - 按时间排序展示\n","keywords":[],"articleBody":"Feed 与 RSS：从信息推送到个人信息流的技术基础\n本文从工程与使用两个层面，系统性介绍： 1. Feed 与 RSS 的概念与格式 2. RSS Reader 的实际好处 3. 如何将邮件转换为 RSS 4. 如何导出与迁移 OPML 配置\n适合希望构建个人信息流管道（personal information pipeline）的技术用户。\nFeed 与 RSS 1.1 什么是 Feed\nFeed 是一种“可被机器订阅的更新流”，本质是： - 按时间排序的条目（items / entries） - 每条包含：标题、链接、摘要、发布时间等元数据 - 客户端可以周期性拉取并增量更新\nFeed 是概念层；RSS / Atom 是实现层的具体协议格式。\n1.2 一个最小 RSS 结构\nExample Feed https://example.com Post Title https://example.com/post Mon, 12 Jan 2026 12:00:00 GMT Summary... RSS Reader 的工作本质是： - 周期性 GET - 解析 XML - 去重 - 按时间排序展示\nRSS Reader 的好处 2.1 与算法推荐的根本区别\n维度 算法流 RSS\n信息来源 平台决定 用户决定 排序逻辑 不透明 时间线 目标函数 留存/点击 信息获取 认知负担 被动刷 主动读\nRSS 是一种反平台中心化的信息消费方式。\n2.2 对研究型用户的实际价值\n对科研与工程用户尤其重要：\n可构建主题订阅池（如 arXiv + GitHub + 博客） 不依赖平台登录状态 可全文本地索引（部分 Reader 支持） 适合与知识管理系统联动（Notion / Obsidian） 例如： - arXiv 关键词 RSS - GitHub Release Feed - Lab 博客 Atom\n可组合为：\n信息获取层 → 阅读层 → 笔记层 → 写作输出层\n形成闭环。\n2.3 RSS Reader 的工程优势\n典型 Reader 支持： - OPML 导入导出 - 本地缓存 - 离线阅读 - 规则过滤 / 标签系统\n本质是一个：多源时间序列聚合系统。\n将邮件转为 RSS 这是一个非常实用但常被忽视的技巧：\n把“推送到邮箱的订阅内容”转成统一的 RSS 信息流。\n3.1 适用场景\nNewsletter arXiv 订阅邮件 CI 通知 监控告警邮件 统一后： - 不污染主邮箱 - 可按时间线批量浏览 - 可全文检索\n3.2 技术方案类型\n方案 A：邮件 → Web 服务 → RSS\n典型服务： - Kill the Newsletter - Mailbrew - Feedrabbit\n流程：\n订阅邮箱 → 服务接收 → 生成 RSS URL → Reader 订阅 优点： - 零维护 - 即开即用\n缺点： - 依赖第三方 - 隐私风险\n方案 B：自建邮件转 RSS\n工程流程：\nIMAP 拉取 → 解析 MIME → 提取正文 → 生成 RSS XML → 本地托管 可用组件： - Python: imaplib + email + feedgen - 定时任务：cron / Windows Task Scheduler - Web：Nginx 或本地文件订阅\n优点： - 数据完全自控 - 可做复杂规则过滤\n缺点： - 初期配置成本高\n3.3 与自动化系统联动\n可进一步扩展：\n邮件 → RSS → Notion API 入库 邮件 → RSS → LLM 自动摘要 邮件 → RSS → 全文向量索引 此时 RSS 成为统一事件总线。\n3.4 RSSHub 可以通过Rsshub的公共实例来对各种网页进行rss化 例如：https://r55hub.zeabur.app/\n导出与迁移 OPML 配置 4.1 什么是 OPML\nOPML = Outline Processor Markup Language\n在 RSS 领域用途非常单一明确：\n用来导出 / 导入订阅列表结构。\n结构示例：\n4.2 为什么一定要定期导出\n实际风险： - Reader 停止维护 - 配置损坏 - 跨设备迁移\nOPML 是： - Reader 无关 - 平台无关 - 唯一可移植格式\n建议： - 与密码管理器同级对待 - 纳入备份系统\n4.3 常见 Reader 的导出位置\n通常在： - Settings → Data → Export - 或 Subscriptions → Export OPML\n导出后可用于： - 导入到 Fluent Reader / Inoreader / Feedly - 版本控制（Git 管理订阅演化）\n4.4 OPML 的高级玩法\n因为是 XML：\n可脚本化生成订阅集 可按项目切分多个 OPML 可与团队共享研究源列表 例如： - RL 论文订阅集 - Robotics 博客订阅集 - 金融宏观订阅集\n本质是：信息源即配置。\n总结\nRSS 并不是过时技术，而是：\n去平台化的信息获取协议 可组合的工程组件 构建个人知识系统的重要基础设施 当你开始： - 精准选择信息源 - 主动构建订阅结构 - 与笔记/研究/写作流程联动\n你实际上是在搭建：\n属于自己的长期可复用信息管道，而不是被动消费流量池。\n","wordCount":"407","inLanguage":"en","datePublished":"2026-01-11T00:00:00Z","dateModified":"2026-01-11T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/rss_reader/"},"publisher":{"@type":"Organization","name":"Blog","logo":{"@type":"ImageObject","url":"https://analyst-huang.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://analyst-huang.github.io/ accesskey=h title="Blog (Alt + H)">Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://analyst-huang.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://analyst-huang.github.io/about/ title=关于><span>关于</span></a></li><li><a href=https://analyst-huang.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://analyst-huang.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://analyst-huang.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">配置RSS reader</h1><div class=post-meta><span title='2026-01-11 00:00:00 +0000 UTC'>January 11, 2026</span>&nbsp;·&nbsp;<span>2 min</span></div></header><div class=post-content><p>Feed 与 RSS：从信息推送到个人信息流的技术基础</p><p>本文从工程与使用两个层面，系统性介绍： 1. Feed 与 RSS 的概念与格式 2.
RSS Reader 的实际好处 3. 如何将邮件转换为 RSS 4. 如何导出与迁移 OPML
配置</p><p>适合希望构建个人信息流管道（personal information pipeline）的技术用户。</p><hr><ol><li>Feed 与 RSS</li></ol><p>1.1 什么是 Feed</p><p>Feed 是一种“可被机器订阅的更新流”，本质是： - 按时间排序的条目（items /
entries） - 每条包含：标题、链接、摘要、发布时间等元数据 -
客户端可以周期性拉取并增量更新</p><p>Feed 是概念层；RSS / Atom 是实现层的具体协议格式。</p><p>1.2 一个最小 RSS 结构</p><pre><code>&lt;rss version=&quot;2.0&quot;&gt;
  &lt;channel&gt;
    &lt;title&gt;Example Feed&lt;/title&gt;
    &lt;link&gt;https://example.com&lt;/link&gt;
    &lt;item&gt;
      &lt;title&gt;Post Title&lt;/title&gt;
      &lt;link&gt;https://example.com/post&lt;/link&gt;
      &lt;pubDate&gt;Mon, 12 Jan 2026 12:00:00 GMT&lt;/pubDate&gt;
      &lt;description&gt;Summary...&lt;/description&gt;
    &lt;/item&gt;
  &lt;/channel&gt;
&lt;/rss&gt;
</code></pre><p>RSS Reader 的工作本质是： - 周期性 GET - 解析 XML - 去重 -
按时间排序展示</p><hr><ol start=2><li>RSS Reader 的好处</li></ol><p>2.1 与算法推荐的根本区别</p><p>维度 算法流 RSS</p><hr><p>信息来源 平台决定 用户决定
排序逻辑 不透明 时间线
目标函数 留存/点击 信息获取
认知负担 被动刷 主动读</p><p>RSS 是一种反平台中心化的信息消费方式。</p><p>2.2 对研究型用户的实际价值</p><p>对科研与工程用户尤其重要：</p><ul><li>可构建主题订阅池（如 arXiv + GitHub + 博客）</li><li>不依赖平台登录状态</li><li>可全文本地索引（部分 Reader 支持）</li><li>适合与知识管理系统联动（Notion / Obsidian）</li></ul><p>例如： - arXiv 关键词 RSS - GitHub Release Feed - Lab 博客 Atom</p><p>可组合为：</p><p>信息获取层 → 阅读层 → 笔记层 → 写作输出层</p><p>形成闭环。</p><p>2.3 RSS Reader 的工程优势</p><p>典型 Reader 支持： - OPML 导入导出 - 本地缓存 - 离线阅读 - 规则过滤 /
标签系统</p><p>本质是一个：多源时间序列聚合系统。</p><hr><ol start=3><li>将邮件转为 RSS</li></ol><p>这是一个非常实用但常被忽视的技巧：</p><p>把“推送到邮箱的订阅内容”转成统一的 RSS 信息流。</p><p>3.1 适用场景</p><ul><li>Newsletter</li><li>arXiv 订阅邮件</li><li>CI 通知</li><li>监控告警邮件</li></ul><p>统一后： - 不污染主邮箱 - 可按时间线批量浏览 - 可全文检索</p><p>3.2 技术方案类型</p><p>方案 A：邮件 → Web 服务 → RSS</p><p>典型服务： - Kill the Newsletter - Mailbrew - Feedrabbit</p><p>流程：</p><pre><code>订阅邮箱 → 服务接收 → 生成 RSS URL → Reader 订阅
</code></pre><p>优点： - 零维护 - 即开即用</p><p>缺点： - 依赖第三方 - 隐私风险</p><p>方案 B：自建邮件转 RSS</p><p>工程流程：</p><pre><code>IMAP 拉取 → 解析 MIME → 提取正文 → 生成 RSS XML → 本地托管
</code></pre><p>可用组件： - Python: imaplib + email + feedgen - 定时任务：cron /
Windows Task Scheduler - Web：Nginx 或本地文件订阅</p><p>优点： - 数据完全自控 - 可做复杂规则过滤</p><p>缺点： - 初期配置成本高</p><p>3.3 与自动化系统联动</p><p>可进一步扩展：</p><ul><li>邮件 → RSS → Notion API 入库</li><li>邮件 → RSS → LLM 自动摘要</li><li>邮件 → RSS → 全文向量索引</li></ul><p>此时 RSS 成为统一事件总线。</p><p>3.4 RSSHub
可以通过Rsshub的公共实例来对各种网页进行rss化
例如：https://r55hub.zeabur.app/</p><hr><ol start=4><li>导出与迁移 OPML 配置</li></ol><p>4.1 什么是 OPML</p><p>OPML = Outline Processor Markup Language</p><p>在 RSS 领域用途非常单一明确：</p><p>用来导出 / 导入订阅列表结构。</p><p>结构示例：</p><pre><code>&lt;opml&gt;
  &lt;body&gt;
    &lt;outline text=&quot;AI&quot;&gt;
      &lt;outline text=&quot;arXiv AI&quot; xmlUrl=&quot;https://arxiv.org/rss/cs.AI&quot;/&gt;
    &lt;/outline&gt;
  &lt;/body&gt;
&lt;/opml&gt;
</code></pre><p>4.2 为什么一定要定期导出</p><p>实际风险： - Reader 停止维护 - 配置损坏 - 跨设备迁移</p><p>OPML 是： - Reader 无关 - 平台无关 - 唯一可移植格式</p><p>建议： - 与密码管理器同级对待 - 纳入备份系统</p><p>4.3 常见 Reader 的导出位置</p><p>通常在： - Settings → Data → Export - 或 Subscriptions → Export OPML</p><p>导出后可用于： - 导入到 Fluent Reader / Inoreader / Feedly -
版本控制（Git 管理订阅演化）</p><p>4.4 OPML 的高级玩法</p><p>因为是 XML：</p><ul><li>可脚本化生成订阅集</li><li>可按项目切分多个 OPML</li><li>可与团队共享研究源列表</li></ul><p>例如： - RL 论文订阅集 - Robotics 博客订阅集 - 金融宏观订阅集</p><p>本质是：信息源即配置。</p><hr><p>总结</p><p>RSS 并不是过时技术，而是：</p><ul><li>去平台化的信息获取协议</li><li>可组合的工程组件</li><li>构建个人知识系统的重要基础设施</li></ul><p>当你开始： - 精准选择信息源 - 主动构建订阅结构 -
与笔记/研究/写作流程联动</p><p>你实际上是在搭建：</p><p>属于自己的长期可复用信息管道，而不是被动消费流量池。</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://analyst-huang.github.io/>Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>