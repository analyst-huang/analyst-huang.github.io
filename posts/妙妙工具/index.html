<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>妙妙工具 | Blog</title><meta name=keywords content><meta name=description content="妙妙工具 - Blog"><meta name=author content><link rel=canonical href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://analyst-huang.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://analyst-huang.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://analyst-huang.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://analyst-huang.github.io/apple-touch-icon.png><link rel=mask-icon href=https://analyst-huang.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/index.xml title=rss><link rel=alternate hreflang=en href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\\\(",right:"\\\\)",display:!1},{left:"\\\\[",right:"\\\\]",display:!0}]})})</script><meta property="og:url" content="https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/"><meta property="og:site_name" content="Blog"><meta property="og:title" content="妙妙工具"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="妙妙工具"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://analyst-huang.github.io/posts/"},{"@type":"ListItem","position":2,"name":"妙妙工具","item":"https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/"}]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://analyst-huang.github.io/ accesskey=h title="Blog (Alt + H)">Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://analyst-huang.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://analyst-huang.github.io/about/ title=关于><span>关于</span></a></li><li><a href=https://analyst-huang.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://analyst-huang.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://analyst-huang.github.io/posts/>Posts</a></div><h1>妙妙工具</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>globbing and regex</h2></header><div class=entry-content><p>Globbing vs Regex：为什么会有两种“匹配语言”？ 在日常开发里，我们经常把“模式匹配”混为一谈：
ls *.urdf、rm mesh_* 这类 globbing（通配/路径匹配） grep -E 'urdf_[0-9]+\.obj'、re.match(r'^urdf_\d+\.obj$') 这类 regex（正则/文本匹配） 它们看起来都在“匹配”，但诞生目的、执行位置、工程约束完全不同，因此长期并存，且不可互相取代。
1. 一句话结论 Globbing 是为“选择文件集合”而生的路径匹配语言；Regex 是为“识别字符串结构”而生的通用文本匹配语言。
这不是历史包袱，而是系统边界的理性分工：
glob：快、可预测、安全，适配 shell 的交互与文件系统 regex：表达力强，适配应用内部的字符串解析与结构约束 2. 两者解决的是不同问题域 2.1 Globbing：人机交互中的“文件集合选择” 典型需求：
删除所有 .log 文件：rm *.log 复制所有 urdf_ 前缀文件：cp urdf_* /dst 批量处理当前目录某类资产 关键约束：
必须很快：每条 shell 命令都可能触发 必须可预测：用户要一眼知道会匹配哪些文件 必须安全：不能因为一个模式导致卡死或难以理解的误删 必须能在 exec 之前展开：shell 需要先把参数展开成文件列表再调用程序 因此 glob 的表达能力刻意保持在一个“甜点区间”：够用，但不会失控。
2.2 Regex：计算中的“字符串结构识别” 典型需求：
从日志中抽取时间戳、ID、字段 校验格式（IP、UUID、版本号） 解析协议文本、配置文本 关键目标：
表达能力最大化：分组、捕获、重复次数、断言、替换 允许复杂约束：结构、边界、条件 在程序内部执行：对性能风险、可读性风险的容忍度更高（可控） 3. 语法与能力：差异从根上决定了“不会统一” 3.1 Globbing 的常见语法（有限但高频） 写法 含义 示例 * 任意长度字符 *.urdf ? 单个字符 file?.txt [abc] 任意一个字符 mesh_[ab].obj [a-z] 范围 [0-9]*.log {a,b} brace expansion（shell 特性） file.{png,jpg} 注：{a,b} 属于 shell 的 brace expansion；它不是 POSIX glob 的核心，但在 bash/zsh 中非常常见。
...</p></div><footer class=entry-footer><span title='2026-01-20 00:00:00 +0000 UTC'>January 20, 2026</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to globbing and regex" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/globbing_and_regex/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>xargs</h2></header><div class=entry-content><p>xargs -I 的读取模型与分隔符机制详解 在日常 Linux 批处理管道中，xargs 经常被用于把标准输入转换为命令参数。其中，-I 模式与默认模式在 输入切分（tokenization / record parsing） 上存在本质差异。理解这一点，对于安全处理文件名、构造复杂命令模板以及性能优化非常关键。
本文系统整理以下问题：
使用 -I 时是否只能一行一行读取？ 是否可以自定义分隔符？ -I 与默认模式在行为与性能上的核心区别 实战建议与最佳实践 1. xargs -I 的基本语义 使用 -I 时，xargs 进入 模板替换模式（template substitution mode）：
xargs -I{} command "{}" 含义是：
对每一条输入记录，将其替换到模板中的 {} 位置，然后执行一次命令。
示例：
printf '%s ' a b c | xargs -I{} echo "item={}" # 输出： # item=a # item=b # item=c 核心特征：
每条输入 → 一次命令执行 输入内容整体保留，不再按空格拆分 适合需要把输入插入到命令中间或多处的位置 2. 是否只能"一行一行读取"？ 默认行为：按"行"读取 当启用 -I 时，xargs 默认以 换行符 (\n) 作为记录分隔符。
...</p></div><footer class=entry-footer><span title='2026-01-20 00:00:00 +0000 UTC'>January 20, 2026</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to xargs" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/xargs/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>XML 语法与工程实践：从树模型到 XPath、Namespace 与 CDATA</h2></header><div class=entry-content><p>0. 这篇文章解决什么问题 XML（eXtensible Markup Language）经常被当作“带尖括号的文本”。但在工程场景（URDF、USD/Omniverse 配置、各种工具链描述文件）里，理解 XML 的关键并不是记住几个标签写法，而是把它当成：
一棵“有序树 + 属性 + 文本”的数据结构
程序读的不是字符流，而是结构。
本文从这个树模型出发，系统整理 XML 的核心语法与常见机制：text/tail、XPath、Namespace、CDATA，并给出 Python（ElementTree）与命令行工具的可用做法。
1. Markup Language 是什么：用“标记”把文本变成结构 Markup Language（标记语言）的本质：用标签（tag）给文本加上边界、层级与语义。
&lt;robot name="taco"> &lt;link name="base_link"/> &lt;/robot> 这不是“字符串里夹标签”，而是树：
robot (name="taco") └── link (name="base_link") 标签名是“语义”，属性是“参数”，嵌套是“结构”。
因此 XML 的强项是：跨系统传递结构化语义（而不是仅仅渲染）。
2. XML 的基本语法（严格规则） XML 比 HTML 严格得多。常见约束如下：
2.1 标签必须闭合 ✅ 正确：
&lt;mesh>&lt;/mesh> &lt;mesh /> ❌ 错误：
&lt;mesh> 2.2 区分大小写 &lt;Mesh> ≠ &lt;mesh> 2.3 属性必须加引号 ✅
&lt;link name="base_link"/> ❌
&lt;link name=base_link/> 2.4 必须正确嵌套，且只有一个根节点 ✅
&lt;a>&lt;b/>&lt;/a> ❌
&lt;a>&lt;b>&lt;/a>&lt;/b> 3. Element / Attribute / Text：把 XML 当成对象模型 一个元素（Element）由：
...</p></div><footer class=entry-footer><span title='2026-01-19 00:00:00 +0000 UTC'>January 19, 2026</span>&nbsp;·&nbsp;<span>3 min</span></footer><a class=entry-link aria-label="post link to XML 语法与工程实践：从树模型到 XPath、Namespace 与 CDATA" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/xml/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>利用大模型读论文</h2></header><div class=entry-content><p>之前用大模型看论文总觉得没有用对，因为效率不高，有各种繁琐的操作，并且理解的程度也不够。
今天发现，最后的拼图其实是记事本，因为模型因为system prompt或者其他的原因，可能回复的很长，如果在当前页面问某个细节，就完全打乱了思路，但是如果把问题全部记录在记事本里面，然后一下子问，反复迭代，问题就会变少，理解也会变清晰。
以及要一个一个模块问，比如说“详细介绍方法，不要漏掉一个细节”，必须一个模块一个模块过，才不会不理解，细节也不能错过。</p></div><footer class=entry-footer><span title='2026-01-13 00:00:00 +0000 UTC'>January 13, 2026</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to 利用大模型读论文" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E8%AF%BB%E8%AE%BA%E6%96%87/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>zmq</h2></header><div class=entry-content><p>最近在做机器人遥操，所以需要在多进程之间交换数据。直接用socket来写就太底层了，所以就研究了一下封装库zmq怎么用。结果出了一个延迟的bug，特此记录zmq的用法。
ZeroMQ PUB-SUB 总结（代码导向）
一、角色职责（Role Semantics）
Publisher（PUB）
职责：只负责发送消息（广播），不接收任何数据。
import zmq ctx = zmq.Context() pub = ctx.socket(zmq.PUB) pub.bind("tcp://*:5555") while True: pub.send(b"state robot_pose=...") 特点： - 只能 send()，不能 recv() - 不知道是否有订阅者 - 不关心订阅者订了什么
Subscriber（SUB）
职责：只负责接收并按 topic 过滤消息，不发送任何数据。
import zmq ctx = zmq.Context() sub = ctx.socket(zmq.SUB) sub.connect("tcp://localhost:5555") # 订阅前缀为 b"state" 的消息 sub.setsockopt(zmq.SUBSCRIBE, b"state") while True: msg = sub.recv() print(msg) 特点： - 只能 recv()，不能 send() - 必须显式设置订阅规则 - 只能收到匹配前缀的消息
二、连接方式（Connection Pattern）
语义与 bind / connect 无关，只是部署方式不同。
...</p></div><footer class=entry-footer><span title='2026-01-11 00:00:00 +0000 UTC'>January 11, 2026</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to zmq" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/zmq/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>配置RSS reader</h2></header><div class=entry-content><p>Feed 与 RSS：从信息推送到个人信息流的技术基础
本文从工程与使用两个层面，系统性介绍： 1. Feed 与 RSS 的概念与格式 2. RSS Reader 的实际好处 3. 如何将邮件转换为 RSS 4. 如何导出与迁移 OPML 配置
适合希望构建个人信息流管道（personal information pipeline）的技术用户。
Feed 与 RSS 1.1 什么是 Feed
Feed 是一种“可被机器订阅的更新流”，本质是： - 按时间排序的条目（items / entries） - 每条包含：标题、链接、摘要、发布时间等元数据 - 客户端可以周期性拉取并增量更新
Feed 是概念层；RSS / Atom 是实现层的具体协议格式。
1.2 一个最小 RSS 结构
&lt;rss version="2.0"> &lt;channel> &lt;title>Example Feed&lt;/title> &lt;link>https://example.com&lt;/link> &lt;item> &lt;title>Post Title&lt;/title> &lt;link>https://example.com/post&lt;/link> &lt;pubDate>Mon, 12 Jan 2026 12:00:00 GMT&lt;/pubDate> &lt;description>Summary...&lt;/description> &lt;/item> &lt;/channel> &lt;/rss> RSS Reader 的工作本质是： - 周期性 GET - 解析 XML - 去重 - 按时间排序展示
...</p></div><footer class=entry-footer><span title='2026-01-11 00:00:00 +0000 UTC'>January 11, 2026</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to 配置RSS reader" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/rss_reader/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>uv</h2></header><div class=entry-content><p>最近又在配一个环境，所以想到了之前被同事推荐过的uv。因为发现在conda环境中也可以用，而且比pip快很多，所以记录一下uv的用法。
看了一下，发现和科研需求并没有那么重合，记录一下和GPT的几个问题：
Conda vs uv：科研工作流下依赖管理的真实差异（Q&amp;A） 面向读者：长期使用 conda + pip 的科研/工程混合用户（如深度学习、机器人、CUDA 相关项目），在接触 uv / poetry 等“项目化依赖管理工具”时感到困惑的人。
Q1：我一直用 conda 建环境 + pip / conda install 装包，这样有什么问题吗？ A：没有问题，而且这是科研圈的主流做法。
你的典型流程是：
conda create -n xxx python=3.10 conda activate xxx pip install ... 或 conda install ... 稳定后：conda env export > env.yaml 这个流程的特点是：
环境层面高度可控 CUDA / PyTorch / 编译依赖更容易处理 适合频繁试错和快速实验 在深度学习与机器人领域，这种方式依然是现实最优解之一。
Q2：那 uv 到底在解决什么问题？为什么工程界很推它？ A：uv 的核心目标不是“更好地装包”，而是“让项目自带可复现环境定义”。
uv 想解决的是这些问题：
clone 一个 repo 后，一条命令就能得到一致环境 CI / 多人协作环境一致 依赖升级过程可审计、可回滚 因此它强调：
...</p></div><footer class=entry-footer><span title='2026-01-08 00:00:00 +0000 UTC'>January 8, 2026</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to uv" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/uv/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Codex</h2></header><div class=entry-content><p>由于最近发现Codex非常好用，并且众多业界大牛一起指出Vibe Coding是未来的趋势，所以系统学习一下Codex。或许人类真的已经来到了理解复杂系统的时候了。
感觉总体来说使用方法是相当自然的，唯一需要注意的是最近新增加的skill功能。原来是anthropic提出的标准，现在被大量采纳，估计会是一个会持续很多年的标准，值得学习。
Agent Skills 基本格式 官网与完整规范：https://agentskills.io/
1) 目录结构 一个 Skill 就是一个文件夹，至少包含一个 SKILL.md：
skill-name/ └── SKILL.md 可选：
scripts/：可执行脚本 references/：参考文档 assets/：模板或资源 2) SKILL.md 格式 SKILL.md 分为两部分：
(A) YAML Frontmatter（必需） --- name: skill-name description: 该技能做什么，以及在什么情况下使用 --- 约束：
name 必须与文件夹名一致 仅允许小写字母、数字、连字符 - 1–64 字符，不能以 - 开头或结尾，不能有连续 -- description 为 1–1024 字符 (B) Markdown 正文（指令内容） Frontmatter 之后是普通 Markdown，用来写操作步骤、示例、注意事项等，结构不强制。
3) 最小示例 --- name: pdf-processing description: 提取 PDF 文本与表格，用于后续分析或填表。 --- # PDF Processing ## When to use 当用户需要处理 PDF 文件时。 ## Procedure 1. 读取 PDF 2. 提取文本与表格 3. 输出结构化结果 这就是 Agent Skill 的基本格式。更多细节见官网：https://agentskills.io/
...</p></div><footer class=entry-footer><span title='2026-01-07 00:00:00 +0000 UTC'>January 7, 2026</span>&nbsp;·&nbsp;<span>3 min</span></footer><a class=entry-link aria-label="post link to Codex" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/codex/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>bubblewrap</h2></header><div class=entry-content><p>Bubblewrap 的功能与 GPU 隔离用法 Bubblewrap 是做什么的 Bubblewrap（bwrap） 是一个基于 Linux namespaces 的进程级 sandbox 工具，核心功能只有一件事：
在系统层面为“单个进程”构造一个最小可见、白名单式的运行环境。
从工程角度看，它提供的能力非常集中：
创建独立的 mount namespace 默认使用 空的根文件系统（tmpfs） 仅通过 --bind / --dev-bind 暴露显式允许的路径与设备 精确控制 /dev 下可见的设备节点 进程退出即销毁，无任何残留状态 它不负责：
镜像构建 服务部署 长期运行 资源调度 Bubblewrap 能解决什么 GPU 问题 在 Isaac Lab / Omniverse 场景中：
CUDA_VISIBLE_DEVICES 只影响 CUDA Vulkan / RTX / NVML 仍可能枚举宿主机全部 GPU 根因是：系统设备节点未被隔离 Bubblewrap 的作用是：
从 /dev 与文件系统层面，让“不该存在的 GPU 真的不存在”。
最小示例：用 Bubblewrap 屏蔽 GPU 下面示例中，进程只能看到 GPU 0，其余 GPU 在系统层面不可见。
...</p></div><footer class=entry-footer><span title='2025-12-24 00:00:00 +0000 UTC'>December 24, 2025</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to bubblewrap" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/bubblewrap/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Python 中的 pickle：对象序列化的原理与使用
在 Python 中，pickle 是标准库提供的一种对象序列化（serialization）与反序列化（deserialization）机制。它可以将内存中的 Python 对象转换为字节流保存到文件或通过网络传输，并在之后将这些字节流还原为等价的 Python 对象。
本文将从概念、使用方式、工作机制、常见问题与安全性等方面系统介绍 pickle。
一、什么是序列化？
程序运行时的对象存在于内存中，包含复杂的结构与指针关系，例如嵌套的列表、字典、对象之间的引用等。这些结构：
依赖进程内存地址 不能直接写入磁盘 不能直接通过网络发送 序列化的目标，就是把这种 “对象图结构” 转换为：
一段连续的字节序列（byte stream）
这样才能：
写入文件 通过 socket 发送 作为缓存保存 反过来，从字节流恢复对象结构的过程称为反序列化。
二、pickle 的基本用法
序列化到文件
import pickle
data = {“a”: 1, “b”: [1, 2, 3]}
with open(“data.pkl”, “wb”) as f: pickle.dump(data, f)
注意：必须使用二进制模式 “wb”。
从文件反序列化
with open(“data.pkl”, “rb”) as f: data2 = pickle.load(f)
print(data2)
同样必须使用 “rb” 二进制模式，否则会出现 UnicodeDecodeError。
直接在内存中序列化
bytes_data = pickle.dumps(data) data3 = pickle.loads(bytes_data)
...</p></div><footer class=entry-footer><span>2 min</span></footer><a class=entry-link aria-label="post link to " href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/pickle/></a></article></main><footer class=footer><span>&copy; 2026 <a href=https://analyst-huang.github.io/>Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>