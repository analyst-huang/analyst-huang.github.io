<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>妙妙工具 on Blog</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/</link><description>Recent content in 妙妙工具 on Blog</description><generator>Hugo -- 0.154.5</generator><language>zh-cn</language><lastBuildDate>Sun, 11 Jan 2026 00:00:00 +0000</lastBuildDate><atom:link href="https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/index.xml" rel="self" type="application/rss+xml"/><item><title>zmq</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/zmq/</link><pubDate>Sun, 11 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/zmq/</guid><description>&lt;p&gt;最近在做机器人遥操，所以需要在多进程之间交换数据。直接用socket来写就太底层了，所以就研究了一下封装库zmq怎么用。结果出了一个延迟的bug，特此记录zmq的用法。&lt;/p&gt;
&lt;p&gt;ZeroMQ PUB-SUB 总结（代码导向）&lt;/p&gt;
&lt;p&gt;一、角色职责（Role Semantics）&lt;/p&gt;
&lt;p&gt;Publisher（PUB）&lt;/p&gt;
&lt;p&gt;职责：只负责发送消息（广播），不接收任何数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import zmq
ctx = zmq.Context()
pub = ctx.socket(zmq.PUB)
pub.bind(&amp;quot;tcp://*:5555&amp;quot;)
while True:
pub.send(b&amp;quot;state robot_pose=...&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;特点： - 只能 send()，不能 recv() - 不知道是否有订阅者 -
不关心订阅者订了什么&lt;/p&gt;
&lt;p&gt;Subscriber（SUB）&lt;/p&gt;
&lt;p&gt;职责：只负责接收并按 topic 过滤消息，不发送任何数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import zmq
ctx = zmq.Context()
sub = ctx.socket(zmq.SUB)
sub.connect(&amp;quot;tcp://localhost:5555&amp;quot;)
# 订阅前缀为 b&amp;quot;state&amp;quot; 的消息
sub.setsockopt(zmq.SUBSCRIBE, b&amp;quot;state&amp;quot;)
while True:
msg = sub.recv()
print(msg)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;特点： - 只能 recv()，不能 send() - 必须显式设置订阅规则 -
只能收到匹配前缀的消息&lt;/p&gt;
&lt;p&gt;二、连接方式（Connection Pattern）&lt;/p&gt;
&lt;p&gt;语义与 bind / connect 无关，只是部署方式不同。&lt;/p&gt;</description></item><item><title>uv</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/uv/</link><pubDate>Thu, 08 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/uv/</guid><description>&lt;p&gt;最近又在配一个环境，所以想到了之前被同事推荐过的&lt;em&gt;uv&lt;/em&gt;。因为发现在conda环境中也可以用，而且比pip快很多，所以记录一下&lt;em&gt;uv&lt;/em&gt;的用法。&lt;/p&gt;
&lt;p&gt;看了一下，发现和科研需求并没有那么重合，记录一下和GPT的几个问题：&lt;/p&gt;
&lt;h1 id="conda-vs-uv科研工作流下依赖管理的真实差异qa"&gt;Conda vs uv：科研工作流下依赖管理的真实差异（Q&amp;amp;A）&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;面向读者：长期使用 conda + pip 的科研/工程混合用户（如深度学习、机器人、CUDA 相关项目），在接触 uv / poetry 等“项目化依赖管理工具”时感到困惑的人。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="q1我一直用-conda-建环境--pip--conda-install-装包这样有什么问题吗"&gt;Q1：我一直用 conda 建环境 + pip / conda install 装包，这样有什么问题吗？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;A：没有问题，而且这是科研圈的主流做法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你的典型流程是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;conda create -n xxx python=3.10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;conda activate xxx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pip install ...&lt;/code&gt; 或 &lt;code&gt;conda install ...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;稳定后：&lt;code&gt;conda env export &amp;gt; env.yaml&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个流程的特点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;环境层面高度可控&lt;/li&gt;
&lt;li&gt;CUDA / PyTorch / 编译依赖更容易处理&lt;/li&gt;
&lt;li&gt;适合频繁试错和快速实验&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在深度学习与机器人领域，这种方式依然是现实最优解之一。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="q2那-uv-到底在解决什么问题为什么工程界很推它"&gt;Q2：那 uv 到底在解决什么问题？为什么工程界很推它？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;A：uv 的核心目标不是“更好地装包”，而是“让项目自带可复现环境定义”。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;uv 想解决的是这些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clone 一个 repo 后，一条命令就能得到一致环境&lt;/li&gt;
&lt;li&gt;CI / 多人协作环境一致&lt;/li&gt;
&lt;li&gt;依赖升级过程可审计、可回滚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此它强调：&lt;/p&gt;</description></item><item><title>Codex</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/codex/</link><pubDate>Wed, 07 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/codex/</guid><description>&lt;p&gt;由于最近发现Codex非常好用，并且众多业界大牛一起指出Vibe Coding是未来的趋势，所以系统学习一下Codex。或许人类真的已经来到了理解&lt;em&gt;复杂系统&lt;/em&gt;的时候了。&lt;/p&gt;
&lt;p&gt;感觉总体来说使用方法是相当自然的，唯一需要注意的是最近新增加的&lt;em&gt;skill&lt;/em&gt;功能。原来是anthropic提出的标准，现在被大量采纳，估计会是一个会持续很多年的标准，值得学习。&lt;/p&gt;
&lt;h1 id="agent-skills-基本格式"&gt;Agent Skills 基本格式&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;官网与完整规范：https://agentskills.io/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="1-目录结构"&gt;1) 目录结构&lt;/h2&gt;
&lt;p&gt;一个 Skill 就是一个文件夹，至少包含一个 &lt;code&gt;SKILL.md&lt;/code&gt;：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;
skill-name/
└── SKILL.md
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可选：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;scripts/&lt;/code&gt;：可执行脚本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;references/&lt;/code&gt;：参考文档&lt;/li&gt;
&lt;li&gt;&lt;code&gt;assets/&lt;/code&gt;：模板或资源&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-skillmd-格式"&gt;2) SKILL.md 格式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SKILL.md&lt;/code&gt; 分为两部分：&lt;/p&gt;
&lt;h3 id="a-yaml-frontmatter必需"&gt;(A) YAML Frontmatter（必需）&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-yaml" data-lang="yaml"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;name&lt;/span&gt;: &lt;span style="color:#ae81ff"&gt;skill-name&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;description&lt;/span&gt;: &lt;span style="color:#ae81ff"&gt;该技能做什么，以及在什么情况下使用&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;约束：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt; 必须与文件夹名一致&lt;/li&gt;
&lt;li&gt;仅允许小写字母、数字、连字符 &lt;code&gt;-&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;1–64 字符，不能以 &lt;code&gt;-&lt;/code&gt; 开头或结尾，不能有连续 &lt;code&gt;--&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;description&lt;/code&gt; 为 1–1024 字符&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="b-markdown-正文指令内容"&gt;(B) Markdown 正文（指令内容）&lt;/h3&gt;
&lt;p&gt;Frontmatter 之后是普通 Markdown，用来写操作步骤、示例、注意事项等，结构不强制。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="3-最小示例"&gt;3) 最小示例&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-md" data-lang="md"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;name: pdf-processing
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;description: 提取 PDF 文本与表格，用于后续分析或填表。
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;# PDF Processing
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;## When to use
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;当用户需要处理 PDF 文件时。
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;## Procedure
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;1.&lt;/span&gt; 读取 PDF
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;2.&lt;/span&gt; 提取文本与表格
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;3.&lt;/span&gt; 输出结构化结果
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;这就是 Agent Skill 的基本格式。更多细节见官网：&lt;a href="https://agentskills.io/"&gt;https://agentskills.io/&lt;/a&gt;&lt;/p&gt;</description></item><item><title>bubblewrap</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/bubblewrap/</link><pubDate>Wed, 24 Dec 2025 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/bubblewrap/</guid><description>&lt;h1 id="bubblewrap-的功能与-gpu-隔离用法"&gt;Bubblewrap 的功能与 GPU 隔离用法&lt;/h1&gt;
&lt;h2 id="bubblewrap-是做什么的"&gt;Bubblewrap 是做什么的&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Bubblewrap（bwrap）&lt;/strong&gt; 是一个基于 Linux namespaces 的&lt;strong&gt;进程级 sandbox 工具&lt;/strong&gt;，核心功能只有一件事：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;在系统层面为“单个进程”构造一个最小可见、白名单式的运行环境。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从工程角度看，它提供的能力非常集中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建独立的 &lt;strong&gt;mount namespace&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;默认使用 &lt;strong&gt;空的根文件系统（tmpfs）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;仅通过 &lt;code&gt;--bind / --dev-bind&lt;/code&gt; 暴露&lt;strong&gt;显式允许的路径与设备&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;精确控制 &lt;code&gt;/dev&lt;/code&gt; 下可见的设备节点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程退出即销毁&lt;/strong&gt;，无任何残留状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它&lt;strong&gt;不负责&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;镜像构建&lt;/li&gt;
&lt;li&gt;服务部署&lt;/li&gt;
&lt;li&gt;长期运行&lt;/li&gt;
&lt;li&gt;资源调度&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="bubblewrap-能解决什么-gpu-问题"&gt;Bubblewrap 能解决什么 GPU 问题&lt;/h2&gt;
&lt;p&gt;在 Isaac Lab / Omniverse 场景中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CUDA_VISIBLE_DEVICES&lt;/code&gt; 只影响 &lt;strong&gt;CUDA&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Vulkan / RTX / NVML 仍可能枚举&lt;strong&gt;宿主机全部 GPU&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;根因是：&lt;strong&gt;系统设备节点未被隔离&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Bubblewrap 的作用是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;从 &lt;code&gt;/dev&lt;/code&gt; 与文件系统层面，让“不该存在的 GPU 真的不存在”。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="最小示例用-bubblewrap-屏蔽-gpu"&gt;最小示例：用 Bubblewrap 屏蔽 GPU&lt;/h2&gt;
&lt;p&gt;下面示例中，&lt;strong&gt;进程只能看到 GPU 0&lt;/strong&gt;，其余 GPU 在系统层面不可见。&lt;/p&gt;</description></item><item><title/><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/pickle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/pickle/</guid><description>&lt;p&gt;Python 中的 pickle：对象序列化的原理与使用&lt;/p&gt;
&lt;p&gt;在 Python 中，pickle
是标准库提供的一种对象序列化（serialization）与反序列化（deserialization）机制。它可以将内存中的
Python
对象转换为字节流保存到文件或通过网络传输，并在之后将这些字节流还原为等价的
Python 对象。&lt;/p&gt;
&lt;p&gt;本文将从概念、使用方式、工作机制、常见问题与安全性等方面系统介绍
pickle。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;一、什么是序列化？&lt;/p&gt;
&lt;p&gt;程序运行时的对象存在于内存中，包含复杂的结构与指针关系，例如嵌套的列表、字典、对象之间的引用等。这些结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;依赖进程内存地址&lt;/li&gt;
&lt;li&gt;不能直接写入磁盘&lt;/li&gt;
&lt;li&gt;不能直接通过网络发送&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;序列化的目标，就是把这种 &lt;strong&gt;“对象图结构”&lt;/strong&gt; 转换为：&lt;/p&gt;
&lt;p&gt;一段连续的字节序列（byte stream）&lt;/p&gt;
&lt;p&gt;这样才能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写入文件&lt;/li&gt;
&lt;li&gt;通过 socket 发送&lt;/li&gt;
&lt;li&gt;作为缓存保存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;反过来，从字节流恢复对象结构的过程称为反序列化。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;二、pickle 的基本用法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;序列化到文件&lt;/p&gt;
&lt;p&gt;import pickle&lt;/p&gt;
&lt;p&gt;data = {&amp;ldquo;a&amp;rdquo;: 1, &amp;ldquo;b&amp;rdquo;: [1, 2, 3]}&lt;/p&gt;
&lt;p&gt;with open(&amp;ldquo;data.pkl&amp;rdquo;, &amp;ldquo;wb&amp;rdquo;) as f:
pickle.dump(data, f)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：必须使用二进制模式 &amp;ldquo;wb&amp;rdquo;。&lt;/p&gt;
&lt;hr&gt;
&lt;ol start="2"&gt;
&lt;li&gt;
&lt;p&gt;从文件反序列化&lt;/p&gt;
&lt;p&gt;with open(&amp;ldquo;data.pkl&amp;rdquo;, &amp;ldquo;rb&amp;rdquo;) as f:
data2 = pickle.load(f)&lt;/p&gt;
&lt;p&gt;print(data2)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同样必须使用 &amp;ldquo;rb&amp;rdquo; 二进制模式，否则会出现 UnicodeDecodeError。&lt;/p&gt;
&lt;hr&gt;
&lt;ol start="3"&gt;
&lt;li&gt;
&lt;p&gt;直接在内存中序列化&lt;/p&gt;
&lt;p&gt;bytes_data = pickle.dumps(data)
data3 = pickle.loads(bytes_data)&lt;/p&gt;</description></item></channel></rss>