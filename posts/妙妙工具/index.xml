<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>妙妙工具 on Blog</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/</link><description>Recent content in 妙妙工具 on Blog</description><generator>Hugo -- 0.154.3</generator><language>zh-cn</language><lastBuildDate>Wed, 07 Jan 2026 00:00:00 +0000</lastBuildDate><atom:link href="https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/index.xml" rel="self" type="application/rss+xml"/><item><title>Codex</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/codex/</link><pubDate>Wed, 07 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/codex/</guid><description>&lt;p&gt;由于最近发现Codex非常好用，并且众多业界大牛一起指出Vibe Coding是未来的趋势，所以系统学习一下Codex。或许人类真的已经来到了理解&lt;em&gt;复杂系统&lt;/em&gt;的时候了。&lt;/p&gt;
&lt;p&gt;感觉总体来说使用方法是相当自然的，唯一需要注意的是最近新增加的&lt;em&gt;skill&lt;/em&gt;功能。原来是anthropic提出的标准，现在被大量采纳，估计会是一个会持续很多年的标准，值得学习。&lt;/p&gt;
&lt;h1 id="agent-skills-基本格式"&gt;Agent Skills 基本格式&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;官网与完整规范：https://agentskills.io/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="1-目录结构"&gt;1) 目录结构&lt;/h2&gt;
&lt;p&gt;一个 Skill 就是一个文件夹，至少包含一个 &lt;code&gt;SKILL.md&lt;/code&gt;：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;
skill-name/
└── SKILL.md
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可选：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;scripts/&lt;/code&gt;：可执行脚本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;references/&lt;/code&gt;：参考文档&lt;/li&gt;
&lt;li&gt;&lt;code&gt;assets/&lt;/code&gt;：模板或资源&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-skillmd-格式"&gt;2) SKILL.md 格式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SKILL.md&lt;/code&gt; 分为两部分：&lt;/p&gt;
&lt;h3 id="a-yaml-frontmatter必需"&gt;(A) YAML Frontmatter（必需）&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-yaml" data-lang="yaml"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;name&lt;/span&gt;: &lt;span style="color:#ae81ff"&gt;skill-name&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;description&lt;/span&gt;: &lt;span style="color:#ae81ff"&gt;该技能做什么，以及在什么情况下使用&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;约束：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt; 必须与文件夹名一致&lt;/li&gt;
&lt;li&gt;仅允许小写字母、数字、连字符 &lt;code&gt;-&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;1–64 字符，不能以 &lt;code&gt;-&lt;/code&gt; 开头或结尾，不能有连续 &lt;code&gt;--&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;description&lt;/code&gt; 为 1–1024 字符&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="b-markdown-正文指令内容"&gt;(B) Markdown 正文（指令内容）&lt;/h3&gt;
&lt;p&gt;Frontmatter 之后是普通 Markdown，用来写操作步骤、示例、注意事项等，结构不强制。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="3-最小示例"&gt;3) 最小示例&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-md" data-lang="md"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;name: pdf-processing
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;description: 提取 PDF 文本与表格，用于后续分析或填表。
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;# PDF Processing
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;## When to use
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;当用户需要处理 PDF 文件时。
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;## Procedure
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;1.&lt;/span&gt; 读取 PDF
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;2.&lt;/span&gt; 提取文本与表格
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;3.&lt;/span&gt; 输出结构化结果
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;这就是 Agent Skill 的基本格式。更多细节见官网：&lt;a href="https://agentskills.io/"&gt;https://agentskills.io/&lt;/a&gt;&lt;/p&gt;</description></item><item><title>bubblewrap</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/bubblewrap/</link><pubDate>Wed, 24 Dec 2025 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/bubblewrap/</guid><description>&lt;h1 id="bubblewrap-的功能与-gpu-隔离用法"&gt;Bubblewrap 的功能与 GPU 隔离用法&lt;/h1&gt;
&lt;h2 id="bubblewrap-是做什么的"&gt;Bubblewrap 是做什么的&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Bubblewrap（bwrap）&lt;/strong&gt; 是一个基于 Linux namespaces 的&lt;strong&gt;进程级 sandbox 工具&lt;/strong&gt;，核心功能只有一件事：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;在系统层面为“单个进程”构造一个最小可见、白名单式的运行环境。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从工程角度看，它提供的能力非常集中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建独立的 &lt;strong&gt;mount namespace&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;默认使用 &lt;strong&gt;空的根文件系统（tmpfs）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;仅通过 &lt;code&gt;--bind / --dev-bind&lt;/code&gt; 暴露&lt;strong&gt;显式允许的路径与设备&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;精确控制 &lt;code&gt;/dev&lt;/code&gt; 下可见的设备节点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程退出即销毁&lt;/strong&gt;，无任何残留状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它&lt;strong&gt;不负责&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;镜像构建&lt;/li&gt;
&lt;li&gt;服务部署&lt;/li&gt;
&lt;li&gt;长期运行&lt;/li&gt;
&lt;li&gt;资源调度&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="bubblewrap-能解决什么-gpu-问题"&gt;Bubblewrap 能解决什么 GPU 问题&lt;/h2&gt;
&lt;p&gt;在 Isaac Lab / Omniverse 场景中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CUDA_VISIBLE_DEVICES&lt;/code&gt; 只影响 &lt;strong&gt;CUDA&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Vulkan / RTX / NVML 仍可能枚举&lt;strong&gt;宿主机全部 GPU&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;根因是：&lt;strong&gt;系统设备节点未被隔离&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Bubblewrap 的作用是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;从 &lt;code&gt;/dev&lt;/code&gt; 与文件系统层面，让“不该存在的 GPU 真的不存在”。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="最小示例用-bubblewrap-屏蔽-gpu"&gt;最小示例：用 Bubblewrap 屏蔽 GPU&lt;/h2&gt;
&lt;p&gt;下面示例中，&lt;strong&gt;进程只能看到 GPU 0&lt;/strong&gt;，其余 GPU 在系统层面不可见。&lt;/p&gt;</description></item></channel></rss>