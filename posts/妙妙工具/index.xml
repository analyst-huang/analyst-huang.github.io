<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>妙妙工具 on Blog</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/</link><description>Recent content in 妙妙工具 on Blog</description><generator>Hugo -- 0.154.5</generator><language>zh-cn</language><lastBuildDate>Mon, 26 Jan 2026 00:00:00 +0000</lastBuildDate><atom:link href="https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/index.xml" rel="self" type="application/rss+xml"/><item><title>从第一性原理理解 CSS：规则系统、约束求解与渲染管线</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/css-first-principles-hugo/</link><pubDate>Mon, 26 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/css-first-principles-hugo/</guid><description>用第一性原理视角把 CSS 抽象为：树结构上的规则系统与声明式约束语言，并连接到浏览器的渲染管线。</description></item><item><title>Tailscale + VS Code Remote-SSH 故障排查复盘</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/tailscale_remote_ssh_debug_summary/</link><pubDate>Fri, 23 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/tailscale_remote_ssh_debug_summary/</guid><description>&lt;h1 id="从原理到实战tailscale-在校园网环境下的连接机制与排障记录"&gt;从原理到实战：Tailscale 在校园网环境下的连接机制与排障记录&lt;/h1&gt;
&lt;h2 id="1-背景与问题陈述"&gt;1. 背景与问题陈述&lt;/h2&gt;
&lt;p&gt;我希望用 Tailscale 让两台处于不同网络环境（不同 NAT/不同局域网）的机器互相访问。实际使用/调试中遇到典型问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tailscale netcheck&lt;/code&gt; 有时显示 IPv6 可用、有时不可用；&lt;/li&gt;
&lt;li&gt;关闭路由器 UPnP 后，&lt;code&gt;PortMapping&lt;/code&gt; 变为空，但依旧无法 &lt;code&gt;ping&lt;/code&gt; 对端；&lt;/li&gt;
&lt;li&gt;路由器后台显示 WAN 口拿到了公网 IPv6，但内网主机 &lt;code&gt;ipconfig&lt;/code&gt; 只有 &lt;code&gt;fe80::&lt;/code&gt;（link-local）而没有公网 IPv6；&lt;/li&gt;
&lt;li&gt;最终定位：&lt;strong&gt;校园网策略限制&lt;/strong&gt;导致“路由器能拿到 IPv6，但无法向 LAN 下发前缀（Prefix Delegation/RA）”，从而使内网终端 IPv6 不可用；Tailscale 在纯 IPv4 + 多级 NAT 环境下直连成功率显著下降，表现为 ping 不通或频繁退化到 DERP 中继。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-tailscale-是什么控制面与数据面"&gt;2. Tailscale 是什么：控制面与数据面&lt;/h2&gt;
&lt;p&gt;一句话概括：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tailscale = &lt;strong&gt;WireGuard 数据面&lt;/strong&gt; + &lt;strong&gt;云端控制面（身份/公钥/节点发现/路由下发）&lt;/strong&gt; 的自动化 Overlay Network。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="21-控制面control-plane做什么"&gt;2.1 控制面（Control Plane）做什么&lt;/h3&gt;
&lt;p&gt;控制面通过 HTTPS 与每个节点通信，负责：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;身份认证（SSO/OAuth 等）与设备注册&lt;/li&gt;
&lt;li&gt;节点公钥分发（谁是谁的 peer）&lt;/li&gt;
&lt;li&gt;节点地址发现与“可达性信息”交换（NAT 映射、候选 endpoint）&lt;/li&gt;
&lt;li&gt;ACL/路由策略下发（谁可以访问谁）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;控制面&lt;strong&gt;不承载你的业务数据&lt;/strong&gt;（除非走 DERP 时需要中继服务，见下文）。&lt;/p&gt;</description></item><item><title>globbing and regex</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/globbing_and_regex/</link><pubDate>Tue, 20 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/globbing_and_regex/</guid><description>&lt;h1 id="globbing-vs-regex为什么会有两种匹配语言"&gt;Globbing vs Regex：为什么会有两种“匹配语言”？&lt;/h1&gt;
&lt;p&gt;在日常开发里，我们经常把“模式匹配”混为一谈：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ls *.urdf&lt;/code&gt;、&lt;code&gt;rm mesh_*&lt;/code&gt; 这类 &lt;strong&gt;globbing&lt;/strong&gt;（通配/路径匹配）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;grep -E 'urdf_[0-9]+\.obj'&lt;/code&gt;、&lt;code&gt;re.match(r'^urdf_\d+\.obj$')&lt;/code&gt; 这类 &lt;strong&gt;regex&lt;/strong&gt;（正则/文本匹配）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它们看起来都在“匹配”，但&lt;strong&gt;诞生目的、执行位置、工程约束&lt;/strong&gt;完全不同，因此长期并存，且不可互相取代。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="1-一句话结论"&gt;1. 一句话结论&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Globbing 是为“选择文件集合”而生的路径匹配语言；Regex 是为“识别字符串结构”而生的通用文本匹配语言。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这不是历史包袱，而是系统边界的理性分工：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;glob：快、可预测、安全，适配 shell 的交互与文件系统&lt;/li&gt;
&lt;li&gt;regex：表达力强，适配应用内部的字符串解析与结构约束&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-两者解决的是不同问题域"&gt;2. 两者解决的是不同问题域&lt;/h2&gt;
&lt;h3 id="21-globbing人机交互中的文件集合选择"&gt;2.1 Globbing：人机交互中的“文件集合选择”&lt;/h3&gt;
&lt;p&gt;典型需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除所有 &lt;code&gt;.log&lt;/code&gt; 文件：&lt;code&gt;rm *.log&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;复制所有 &lt;code&gt;urdf_&lt;/code&gt; 前缀文件：&lt;code&gt;cp urdf_* /dst&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;批量处理当前目录某类资产&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关键约束：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;必须很快&lt;/strong&gt;：每条 shell 命令都可能触发&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;必须可预测&lt;/strong&gt;：用户要一眼知道会匹配哪些文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;必须安全&lt;/strong&gt;：不能因为一个模式导致卡死或难以理解的误删&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;必须能在 exec 之前展开&lt;/strong&gt;：shell 需要先把参数展开成文件列表再调用程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此 glob 的表达能力刻意保持在一个“甜点区间”：够用，但不会失控。&lt;/p&gt;
&lt;h3 id="22-regex计算中的字符串结构识别"&gt;2.2 Regex：计算中的“字符串结构识别”&lt;/h3&gt;
&lt;p&gt;典型需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从日志中抽取时间戳、ID、字段&lt;/li&gt;
&lt;li&gt;校验格式（IP、UUID、版本号）&lt;/li&gt;
&lt;li&gt;解析协议文本、配置文本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关键目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;表达能力最大化&lt;/strong&gt;：分组、捕获、重复次数、断言、替换&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;允许复杂约束&lt;/strong&gt;：结构、边界、条件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在程序内部执行&lt;/strong&gt;：对性能风险、可读性风险的容忍度更高（可控）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="3-语法与能力差异从根上决定了不会统一"&gt;3. 语法与能力：差异从根上决定了“不会统一”&lt;/h2&gt;
&lt;h3 id="31-globbing-的常见语法有限但高频"&gt;3.1 Globbing 的常见语法（有限但高频）&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;写法&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任意长度字符&lt;/td&gt;
&lt;td&gt;&lt;code&gt;*.urdf&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;?&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;单个字符&lt;/td&gt;
&lt;td&gt;&lt;code&gt;file?.txt&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[abc]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任意一个字符&lt;/td&gt;
&lt;td&gt;&lt;code&gt;mesh_[ab].obj&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[a-z]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;范围&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[0-9]*.log&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;{a,b}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;brace expansion（shell 特性）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;file.{png,jpg}&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;注：&lt;code&gt;{a,b}&lt;/code&gt; 属于 shell 的 brace expansion；它不是 POSIX glob 的核心，但在 bash/zsh 中非常常见。&lt;/p&gt;</description></item><item><title>xargs</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/xargs/</link><pubDate>Tue, 20 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/xargs/</guid><description>&lt;h1 id="xargs--i-的读取模型与分隔符机制详解"&gt;xargs -I 的读取模型与分隔符机制详解&lt;/h1&gt;
&lt;p&gt;在日常 Linux 批处理管道中，&lt;code&gt;xargs&lt;/code&gt;
经常被用于把标准输入转换为命令参数。其中，&lt;code&gt;-I&lt;/code&gt; 模式与默认模式在
&lt;strong&gt;输入切分（tokenization / record parsing）&lt;/strong&gt;
上存在本质差异。理解这一点，对于安全处理文件名、构造复杂命令模板以及性能优化非常关键。&lt;/p&gt;
&lt;p&gt;本文系统整理以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;-I&lt;/code&gt; 时是否只能一行一行读取？&lt;/li&gt;
&lt;li&gt;是否可以自定义分隔符？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-I&lt;/code&gt; 与默认模式在行为与性能上的核心区别&lt;/li&gt;
&lt;li&gt;实战建议与最佳实践&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="1-xargs--i-的基本语义"&gt;1. &lt;code&gt;xargs -I&lt;/code&gt; 的基本语义&lt;/h2&gt;
&lt;p&gt;使用 &lt;code&gt;-I&lt;/code&gt; 时，&lt;code&gt;xargs&lt;/code&gt; 进入 &lt;strong&gt;模板替换模式（template substitution
mode）&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;xargs -I&lt;span style="color:#f92672"&gt;{}&lt;/span&gt; command &lt;span style="color:#e6db74"&gt;&amp;#34;{}&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;含义是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对每一条输入记录，将其替换到模板中的 &lt;code&gt;{}&lt;/code&gt; 位置，然后执行一次命令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;printf &lt;span style="color:#e6db74"&gt;&amp;#39;%s
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#e6db74"&gt;&amp;#39;&lt;/span&gt; a b c | xargs -I&lt;span style="color:#f92672"&gt;{}&lt;/span&gt; echo &lt;span style="color:#e6db74"&gt;&amp;#34;item={}&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;# 输出：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;# item=a&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;# item=b&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;# item=c&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;核心特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每条输入 → 一次命令执行&lt;/li&gt;
&lt;li&gt;输入内容整体保留，不再按空格拆分&lt;/li&gt;
&lt;li&gt;适合需要把输入插入到命令中间或多处的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-是否只能一行一行读取"&gt;2. 是否只能&amp;quot;一行一行读取&amp;quot;？&lt;/h2&gt;
&lt;h3 id="默认行为按行读取"&gt;默认行为：按&amp;quot;行&amp;quot;读取&lt;/h3&gt;
&lt;p&gt;当启用 &lt;code&gt;-I&lt;/code&gt; 时，&lt;code&gt;xargs&lt;/code&gt; 默认以 &lt;strong&gt;换行符 (&lt;code&gt;\n&lt;/code&gt;) 作为记录分隔符&lt;/strong&gt;。&lt;/p&gt;</description></item><item><title>XML 语法与工程实践：从树模型到 XPath、Namespace 与 CDATA</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/xml/</link><pubDate>Mon, 19 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/xml/</guid><description>&lt;h2 id="0-这篇文章解决什么问题"&gt;0. 这篇文章解决什么问题&lt;/h2&gt;
&lt;p&gt;XML（eXtensible Markup Language）经常被当作“带尖括号的文本”。但在工程场景（URDF、USD/Omniverse 配置、各种工具链描述文件）里，理解 XML 的关键并不是记住几个标签写法，而是把它当成：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;一棵“有序树 + 属性 + 文本”的数据结构&lt;/strong&gt;&lt;br&gt;
程序读的不是字符流，而是结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文从这个树模型出发，系统整理 XML 的核心语法与常见机制：&lt;code&gt;text/tail&lt;/code&gt;、XPath、Namespace、CDATA，并给出 Python（ElementTree）与命令行工具的可用做法。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="1-markup-language-是什么用标记把文本变成结构"&gt;1. Markup Language 是什么：用“标记”把文本变成结构&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Markup Language（标记语言）&lt;strong&gt;的本质：用标签（tag）给文本加上&lt;/strong&gt;边界、层级与语义&lt;/strong&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-xml" data-lang="xml"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;robot&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;name=&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#34;taco&amp;#34;&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;&amp;lt;link&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;name=&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#34;base_link&amp;#34;&lt;/span&gt;&lt;span style="color:#f92672"&gt;/&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;/robot&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这不是“字符串里夹标签”，而是树：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;robot (name=&amp;#34;taco&amp;#34;)
└── link (name=&amp;#34;base_link&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;标签名是“语义”，属性是“参数”，嵌套是“结构”。&lt;br&gt;
因此 XML 的强项是：&lt;strong&gt;跨系统传递结构化语义&lt;/strong&gt;（而不是仅仅渲染）。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="2-xml-的基本语法严格规则"&gt;2. XML 的基本语法（严格规则）&lt;/h2&gt;
&lt;p&gt;XML 比 HTML 严格得多。常见约束如下：&lt;/p&gt;
&lt;h3 id="21-标签必须闭合"&gt;2.1 标签必须闭合&lt;/h3&gt;
&lt;p&gt;✅ 正确：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-xml" data-lang="xml"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;mesh&amp;gt;&amp;lt;/mesh&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;mesh&lt;/span&gt; &lt;span style="color:#f92672"&gt;/&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;❌ 错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-xml" data-lang="xml"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;mesh&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="22-区分大小写"&gt;2.2 区分大小写&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-xml" data-lang="xml"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;Mesh&amp;gt;&lt;/span&gt; ≠ &lt;span style="color:#f92672"&gt;&amp;lt;mesh&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="23-属性必须加引号"&gt;2.3 属性必须加引号&lt;/h3&gt;
&lt;p&gt;✅&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-xml" data-lang="xml"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;link&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;name=&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#34;base_link&amp;#34;&lt;/span&gt;&lt;span style="color:#f92672"&gt;/&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;❌&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-xml" data-lang="xml"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;link&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;name=&lt;/span&gt;&lt;span style="color:#e6db74"&gt;base_link/&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="24-必须正确嵌套且只有一个根节点"&gt;2.4 必须正确嵌套，且只有一个根节点&lt;/h3&gt;
&lt;p&gt;✅&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-xml" data-lang="xml"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;a&amp;gt;&amp;lt;b/&amp;gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;❌&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-xml" data-lang="xml"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;a&amp;gt;&amp;lt;b&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/b&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id="3-element--attribute--text把-xml-当成对象模型"&gt;3. Element / Attribute / Text：把 XML 当成对象模型&lt;/h2&gt;
&lt;p&gt;一个元素（Element）由：&lt;/p&gt;</description></item><item><title>利用大模型读论文</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E8%AF%BB%E8%AE%BA%E6%96%87/</link><pubDate>Tue, 13 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E8%AF%BB%E8%AE%BA%E6%96%87/</guid><description>&lt;p&gt;之前用大模型看论文总觉得没有用对，因为效率不高，有各种繁琐的操作，并且理解的程度也不够。&lt;/p&gt;
&lt;p&gt;今天发现，最后的拼图其实是&lt;strong&gt;记事本&lt;/strong&gt;，因为模型因为system prompt或者其他的原因，可能回复的很长，如果在当前页面问某个细节，就完全打乱了思路，但是如果把问题全部记录在记事本里面，然后一下子问，反复迭代，问题就会变少，理解也会变清晰。&lt;/p&gt;
&lt;p&gt;以及要一个一个模块问，比如说“详细介绍方法，不要漏掉一个细节”，必须一个模块一个模块过，才不会不理解，细节也不能错过。&lt;/p&gt;</description></item><item><title>zmq</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/zmq/</link><pubDate>Sun, 11 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/zmq/</guid><description>&lt;p&gt;最近在做机器人遥操，所以需要在多进程之间交换数据。直接用socket来写就太底层了，所以就研究了一下封装库zmq怎么用。结果出了一个延迟的bug，特此记录zmq的用法。&lt;/p&gt;
&lt;p&gt;ZeroMQ PUB-SUB 总结（代码导向）&lt;/p&gt;
&lt;p&gt;一、角色职责（Role Semantics）&lt;/p&gt;
&lt;p&gt;Publisher（PUB）&lt;/p&gt;
&lt;p&gt;职责：只负责发送消息（广播），不接收任何数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import zmq
ctx = zmq.Context()
pub = ctx.socket(zmq.PUB)
pub.bind(&amp;quot;tcp://*:5555&amp;quot;)
while True:
pub.send(b&amp;quot;state robot_pose=...&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;特点： - 只能 send()，不能 recv() - 不知道是否有订阅者 -
不关心订阅者订了什么&lt;/p&gt;
&lt;p&gt;Subscriber（SUB）&lt;/p&gt;
&lt;p&gt;职责：只负责接收并按 topic 过滤消息，不发送任何数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import zmq
ctx = zmq.Context()
sub = ctx.socket(zmq.SUB)
sub.connect(&amp;quot;tcp://localhost:5555&amp;quot;)
# 订阅前缀为 b&amp;quot;state&amp;quot; 的消息
sub.setsockopt(zmq.SUBSCRIBE, b&amp;quot;state&amp;quot;)
while True:
msg = sub.recv()
print(msg)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;特点： - 只能 recv()，不能 send() - 必须显式设置订阅规则 -
只能收到匹配前缀的消息&lt;/p&gt;
&lt;p&gt;二、连接方式（Connection Pattern）&lt;/p&gt;
&lt;p&gt;语义与 bind / connect 无关，只是部署方式不同。&lt;/p&gt;</description></item><item><title>配置RSS reader</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/rss_reader/</link><pubDate>Sun, 11 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/rss_reader/</guid><description>&lt;p&gt;Feed 与 RSS：从信息推送到个人信息流的技术基础&lt;/p&gt;
&lt;p&gt;本文从工程与使用两个层面，系统性介绍： 1. Feed 与 RSS 的概念与格式 2.
RSS Reader 的实际好处 3. 如何将邮件转换为 RSS 4. 如何导出与迁移 OPML
配置&lt;/p&gt;
&lt;p&gt;适合希望构建个人信息流管道（personal information pipeline）的技术用户。&lt;/p&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;Feed 与 RSS&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1.1 什么是 Feed&lt;/p&gt;
&lt;p&gt;Feed 是一种“可被机器订阅的更新流”，本质是： - 按时间排序的条目（items /
entries） - 每条包含：标题、链接、摘要、发布时间等元数据 -
客户端可以周期性拉取并增量更新&lt;/p&gt;
&lt;p&gt;Feed 是概念层；RSS / Atom 是实现层的具体协议格式。&lt;/p&gt;
&lt;p&gt;1.2 一个最小 RSS 结构&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;rss version=&amp;quot;2.0&amp;quot;&amp;gt;
&amp;lt;channel&amp;gt;
&amp;lt;title&amp;gt;Example Feed&amp;lt;/title&amp;gt;
&amp;lt;link&amp;gt;https://example.com&amp;lt;/link&amp;gt;
&amp;lt;item&amp;gt;
&amp;lt;title&amp;gt;Post Title&amp;lt;/title&amp;gt;
&amp;lt;link&amp;gt;https://example.com/post&amp;lt;/link&amp;gt;
&amp;lt;pubDate&amp;gt;Mon, 12 Jan 2026 12:00:00 GMT&amp;lt;/pubDate&amp;gt;
&amp;lt;description&amp;gt;Summary...&amp;lt;/description&amp;gt;
&amp;lt;/item&amp;gt;
&amp;lt;/channel&amp;gt;
&amp;lt;/rss&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;RSS Reader 的工作本质是： - 周期性 GET - 解析 XML - 去重 -
按时间排序展示&lt;/p&gt;</description></item><item><title>uv</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/uv/</link><pubDate>Thu, 08 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/uv/</guid><description>&lt;p&gt;最近又在配一个环境，所以想到了之前被同事推荐过的&lt;em&gt;uv&lt;/em&gt;。因为发现在conda环境中也可以用，而且比pip快很多，所以记录一下&lt;em&gt;uv&lt;/em&gt;的用法。&lt;/p&gt;
&lt;p&gt;看了一下，发现和科研需求并没有那么重合，记录一下和GPT的几个问题：&lt;/p&gt;
&lt;h1 id="conda-vs-uv科研工作流下依赖管理的真实差异qa"&gt;Conda vs uv：科研工作流下依赖管理的真实差异（Q&amp;amp;A）&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;面向读者：长期使用 conda + pip 的科研/工程混合用户（如深度学习、机器人、CUDA 相关项目），在接触 uv / poetry 等“项目化依赖管理工具”时感到困惑的人。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="q1我一直用-conda-建环境--pip--conda-install-装包这样有什么问题吗"&gt;Q1：我一直用 conda 建环境 + pip / conda install 装包，这样有什么问题吗？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;A：没有问题，而且这是科研圈的主流做法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你的典型流程是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;conda create -n xxx python=3.10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;conda activate xxx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pip install ...&lt;/code&gt; 或 &lt;code&gt;conda install ...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;稳定后：&lt;code&gt;conda env export &amp;gt; env.yaml&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个流程的特点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;环境层面高度可控&lt;/li&gt;
&lt;li&gt;CUDA / PyTorch / 编译依赖更容易处理&lt;/li&gt;
&lt;li&gt;适合频繁试错和快速实验&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在深度学习与机器人领域，这种方式依然是现实最优解之一。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="q2那-uv-到底在解决什么问题为什么工程界很推它"&gt;Q2：那 uv 到底在解决什么问题？为什么工程界很推它？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;A：uv 的核心目标不是“更好地装包”，而是“让项目自带可复现环境定义”。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;uv 想解决的是这些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clone 一个 repo 后，一条命令就能得到一致环境&lt;/li&gt;
&lt;li&gt;CI / 多人协作环境一致&lt;/li&gt;
&lt;li&gt;依赖升级过程可审计、可回滚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此它强调：&lt;/p&gt;</description></item><item><title>Codex</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/codex/</link><pubDate>Wed, 07 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/codex/</guid><description>&lt;p&gt;由于最近发现Codex非常好用，并且众多业界大牛一起指出Vibe Coding是未来的趋势，所以系统学习一下Codex。或许人类真的已经来到了理解&lt;em&gt;复杂系统&lt;/em&gt;的时候了。&lt;/p&gt;
&lt;p&gt;感觉总体来说使用方法是相当自然的，唯一需要注意的是最近新增加的&lt;em&gt;skill&lt;/em&gt;功能。原来是anthropic提出的标准，现在被大量采纳，估计会是一个会持续很多年的标准，值得学习。&lt;/p&gt;
&lt;h1 id="agent-skills-基本格式"&gt;Agent Skills 基本格式&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;官网与完整规范：https://agentskills.io/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="1-目录结构"&gt;1) 目录结构&lt;/h2&gt;
&lt;p&gt;一个 Skill 就是一个文件夹，至少包含一个 &lt;code&gt;SKILL.md&lt;/code&gt;：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;
skill-name/
└── SKILL.md
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可选：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;scripts/&lt;/code&gt;：可执行脚本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;references/&lt;/code&gt;：参考文档&lt;/li&gt;
&lt;li&gt;&lt;code&gt;assets/&lt;/code&gt;：模板或资源&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-skillmd-格式"&gt;2) SKILL.md 格式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SKILL.md&lt;/code&gt; 分为两部分：&lt;/p&gt;
&lt;h3 id="a-yaml-frontmatter必需"&gt;(A) YAML Frontmatter（必需）&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-yaml" data-lang="yaml"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;name&lt;/span&gt;: &lt;span style="color:#ae81ff"&gt;skill-name&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;description&lt;/span&gt;: &lt;span style="color:#ae81ff"&gt;该技能做什么，以及在什么情况下使用&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;约束：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt; 必须与文件夹名一致&lt;/li&gt;
&lt;li&gt;仅允许小写字母、数字、连字符 &lt;code&gt;-&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;1–64 字符，不能以 &lt;code&gt;-&lt;/code&gt; 开头或结尾，不能有连续 &lt;code&gt;--&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;description&lt;/code&gt; 为 1–1024 字符&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="b-markdown-正文指令内容"&gt;(B) Markdown 正文（指令内容）&lt;/h3&gt;
&lt;p&gt;Frontmatter 之后是普通 Markdown，用来写操作步骤、示例、注意事项等，结构不强制。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="3-最小示例"&gt;3) 最小示例&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-md" data-lang="md"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;name: pdf-processing
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;description: 提取 PDF 文本与表格，用于后续分析或填表。
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;# PDF Processing
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;## When to use
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;当用户需要处理 PDF 文件时。
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;## Procedure
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;1.&lt;/span&gt; 读取 PDF
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;2.&lt;/span&gt; 提取文本与表格
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;3.&lt;/span&gt; 输出结构化结果
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;这就是 Agent Skill 的基本格式。更多细节见官网：&lt;a href="https://agentskills.io/"&gt;https://agentskills.io/&lt;/a&gt;&lt;/p&gt;</description></item><item><title>bubblewrap</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/bubblewrap/</link><pubDate>Wed, 24 Dec 2025 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/bubblewrap/</guid><description>&lt;h1 id="bubblewrap-的功能与-gpu-隔离用法"&gt;Bubblewrap 的功能与 GPU 隔离用法&lt;/h1&gt;
&lt;h2 id="bubblewrap-是做什么的"&gt;Bubblewrap 是做什么的&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Bubblewrap（bwrap）&lt;/strong&gt; 是一个基于 Linux namespaces 的&lt;strong&gt;进程级 sandbox 工具&lt;/strong&gt;，核心功能只有一件事：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;在系统层面为“单个进程”构造一个最小可见、白名单式的运行环境。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从工程角度看，它提供的能力非常集中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建独立的 &lt;strong&gt;mount namespace&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;默认使用 &lt;strong&gt;空的根文件系统（tmpfs）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;仅通过 &lt;code&gt;--bind / --dev-bind&lt;/code&gt; 暴露&lt;strong&gt;显式允许的路径与设备&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;精确控制 &lt;code&gt;/dev&lt;/code&gt; 下可见的设备节点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程退出即销毁&lt;/strong&gt;，无任何残留状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它&lt;strong&gt;不负责&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;镜像构建&lt;/li&gt;
&lt;li&gt;服务部署&lt;/li&gt;
&lt;li&gt;长期运行&lt;/li&gt;
&lt;li&gt;资源调度&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="bubblewrap-能解决什么-gpu-问题"&gt;Bubblewrap 能解决什么 GPU 问题&lt;/h2&gt;
&lt;p&gt;在 Isaac Lab / Omniverse 场景中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CUDA_VISIBLE_DEVICES&lt;/code&gt; 只影响 &lt;strong&gt;CUDA&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Vulkan / RTX / NVML 仍可能枚举&lt;strong&gt;宿主机全部 GPU&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;根因是：&lt;strong&gt;系统设备节点未被隔离&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Bubblewrap 的作用是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;从 &lt;code&gt;/dev&lt;/code&gt; 与文件系统层面，让“不该存在的 GPU 真的不存在”。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="最小示例用-bubblewrap-屏蔽-gpu"&gt;最小示例：用 Bubblewrap 屏蔽 GPU&lt;/h2&gt;
&lt;p&gt;下面示例中，&lt;strong&gt;进程只能看到 GPU 0&lt;/strong&gt;，其余 GPU 在系统层面不可见。&lt;/p&gt;</description></item><item><title/><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/pickle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/pickle/</guid><description>&lt;p&gt;Python 中的 pickle：对象序列化的原理与使用&lt;/p&gt;
&lt;p&gt;在 Python 中，pickle
是标准库提供的一种对象序列化（serialization）与反序列化（deserialization）机制。它可以将内存中的
Python
对象转换为字节流保存到文件或通过网络传输，并在之后将这些字节流还原为等价的
Python 对象。&lt;/p&gt;
&lt;p&gt;本文将从概念、使用方式、工作机制、常见问题与安全性等方面系统介绍
pickle。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;一、什么是序列化？&lt;/p&gt;
&lt;p&gt;程序运行时的对象存在于内存中，包含复杂的结构与指针关系，例如嵌套的列表、字典、对象之间的引用等。这些结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;依赖进程内存地址&lt;/li&gt;
&lt;li&gt;不能直接写入磁盘&lt;/li&gt;
&lt;li&gt;不能直接通过网络发送&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;序列化的目标，就是把这种 &lt;strong&gt;“对象图结构”&lt;/strong&gt; 转换为：&lt;/p&gt;
&lt;p&gt;一段连续的字节序列（byte stream）&lt;/p&gt;
&lt;p&gt;这样才能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写入文件&lt;/li&gt;
&lt;li&gt;通过 socket 发送&lt;/li&gt;
&lt;li&gt;作为缓存保存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;反过来，从字节流恢复对象结构的过程称为反序列化。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;二、pickle 的基本用法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;序列化到文件&lt;/p&gt;
&lt;p&gt;import pickle&lt;/p&gt;
&lt;p&gt;data = {&amp;ldquo;a&amp;rdquo;: 1, &amp;ldquo;b&amp;rdquo;: [1, 2, 3]}&lt;/p&gt;
&lt;p&gt;with open(&amp;ldquo;data.pkl&amp;rdquo;, &amp;ldquo;wb&amp;rdquo;) as f:
pickle.dump(data, f)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：必须使用二进制模式 &amp;ldquo;wb&amp;rdquo;。&lt;/p&gt;
&lt;hr&gt;
&lt;ol start="2"&gt;
&lt;li&gt;
&lt;p&gt;从文件反序列化&lt;/p&gt;
&lt;p&gt;with open(&amp;ldquo;data.pkl&amp;rdquo;, &amp;ldquo;rb&amp;rdquo;) as f:
data2 = pickle.load(f)&lt;/p&gt;
&lt;p&gt;print(data2)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同样必须使用 &amp;ldquo;rb&amp;rdquo; 二进制模式，否则会出现 UnicodeDecodeError。&lt;/p&gt;
&lt;hr&gt;
&lt;ol start="3"&gt;
&lt;li&gt;
&lt;p&gt;直接在内存中序列化&lt;/p&gt;
&lt;p&gt;bytes_data = pickle.dumps(data)
data3 = pickle.loads(bytes_data)&lt;/p&gt;</description></item></channel></rss>