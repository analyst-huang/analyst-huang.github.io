<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>globbing and regex | Blog</title><meta name=keywords content><meta name=description content="Globbing vs Regex：为什么会有两种“匹配语言”？
在日常开发里，我们经常把“模式匹配”混为一谈：

ls *.urdf、rm mesh_* 这类 globbing（通配/路径匹配）
grep -E 'urdf_[0-9]+\.obj'、re.match(r'^urdf_\d+\.obj$') 这类 regex（正则/文本匹配）

它们看起来都在“匹配”，但诞生目的、执行位置、工程约束完全不同，因此长期并存，且不可互相取代。

1. 一句话结论

Globbing 是为“选择文件集合”而生的路径匹配语言；Regex 是为“识别字符串结构”而生的通用文本匹配语言。

这不是历史包袱，而是系统边界的理性分工：

glob：快、可预测、安全，适配 shell 的交互与文件系统
regex：表达力强，适配应用内部的字符串解析与结构约束


2. 两者解决的是不同问题域
2.1 Globbing：人机交互中的“文件集合选择”
典型需求：

删除所有 .log 文件：rm *.log
复制所有 urdf_ 前缀文件：cp urdf_* /dst
批量处理当前目录某类资产

关键约束：

必须很快：每条 shell 命令都可能触发
必须可预测：用户要一眼知道会匹配哪些文件
必须安全：不能因为一个模式导致卡死或难以理解的误删
必须能在 exec 之前展开：shell 需要先把参数展开成文件列表再调用程序

因此 glob 的表达能力刻意保持在一个“甜点区间”：够用，但不会失控。
2.2 Regex：计算中的“字符串结构识别”
典型需求：

从日志中抽取时间戳、ID、字段
校验格式（IP、UUID、版本号）
解析协议文本、配置文本

关键目标：

表达能力最大化：分组、捕获、重复次数、断言、替换
允许复杂约束：结构、边界、条件
在程序内部执行：对性能风险、可读性风险的容忍度更高（可控）


3. 语法与能力：差异从根上决定了“不会统一”
3.1 Globbing 的常见语法（有限但高频）

  
      
          写法
          含义
          示例
      
  
  
      
          *
          任意长度字符
          *.urdf
      
      
          ?
          单个字符
          file?.txt
      
      
          [abc]
          任意一个字符
          mesh_[ab].obj
      
      
          [a-z]
          范围
          [0-9]*.log
      
      
          {a,b}
          brace expansion（shell 特性）
          file.{png,jpg}
      
  


注：{a,b} 属于 shell 的 brace expansion；它不是 POSIX glob 的核心，但在 bash/zsh 中非常常见。"><meta name=author content><link rel=canonical href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/globbing_and_regex/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://analyst-huang.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://analyst-huang.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://analyst-huang.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://analyst-huang.github.io/apple-touch-icon.png><link rel=mask-icon href=https://analyst-huang.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/globbing_and_regex/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/globbing_and_regex/"><meta property="og:site_name" content="Blog"><meta property="og:title" content="globbing and regex"><meta property="og:description" content="Globbing vs Regex：为什么会有两种“匹配语言”？ 在日常开发里，我们经常把“模式匹配”混为一谈：
ls *.urdf、rm mesh_* 这类 globbing（通配/路径匹配） grep -E 'urdf_[0-9]+\.obj'、re.match(r'^urdf_\d+\.obj$') 这类 regex（正则/文本匹配） 它们看起来都在“匹配”，但诞生目的、执行位置、工程约束完全不同，因此长期并存，且不可互相取代。
1. 一句话结论 Globbing 是为“选择文件集合”而生的路径匹配语言；Regex 是为“识别字符串结构”而生的通用文本匹配语言。
这不是历史包袱，而是系统边界的理性分工：
glob：快、可预测、安全，适配 shell 的交互与文件系统 regex：表达力强，适配应用内部的字符串解析与结构约束 2. 两者解决的是不同问题域 2.1 Globbing：人机交互中的“文件集合选择” 典型需求：
删除所有 .log 文件：rm *.log 复制所有 urdf_ 前缀文件：cp urdf_* /dst 批量处理当前目录某类资产 关键约束：
必须很快：每条 shell 命令都可能触发 必须可预测：用户要一眼知道会匹配哪些文件 必须安全：不能因为一个模式导致卡死或难以理解的误删 必须能在 exec 之前展开：shell 需要先把参数展开成文件列表再调用程序 因此 glob 的表达能力刻意保持在一个“甜点区间”：够用，但不会失控。
2.2 Regex：计算中的“字符串结构识别” 典型需求：
从日志中抽取时间戳、ID、字段 校验格式（IP、UUID、版本号） 解析协议文本、配置文本 关键目标：
表达能力最大化：分组、捕获、重复次数、断言、替换 允许复杂约束：结构、边界、条件 在程序内部执行：对性能风险、可读性风险的容忍度更高（可控） 3. 语法与能力：差异从根上决定了“不会统一” 3.1 Globbing 的常见语法（有限但高频） 写法 含义 示例 * 任意长度字符 *.urdf ? 单个字符 file?.txt [abc] 任意一个字符 mesh_[ab].obj [a-z] 范围 [0-9]*.log {a,b} brace expansion（shell 特性） file.{png,jpg} 注：{a,b} 属于 shell 的 brace expansion；它不是 POSIX glob 的核心，但在 bash/zsh 中非常常见。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-01-20T00:00:00+00:00"><meta property="article:modified_time" content="2026-01-20T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="globbing and regex"><meta name=twitter:description content="Globbing vs Regex：为什么会有两种“匹配语言”？
在日常开发里，我们经常把“模式匹配”混为一谈：

ls *.urdf、rm mesh_* 这类 globbing（通配/路径匹配）
grep -E 'urdf_[0-9]+\.obj'、re.match(r'^urdf_\d+\.obj$') 这类 regex（正则/文本匹配）

它们看起来都在“匹配”，但诞生目的、执行位置、工程约束完全不同，因此长期并存，且不可互相取代。

1. 一句话结论

Globbing 是为“选择文件集合”而生的路径匹配语言；Regex 是为“识别字符串结构”而生的通用文本匹配语言。

这不是历史包袱，而是系统边界的理性分工：

glob：快、可预测、安全，适配 shell 的交互与文件系统
regex：表达力强，适配应用内部的字符串解析与结构约束


2. 两者解决的是不同问题域
2.1 Globbing：人机交互中的“文件集合选择”
典型需求：

删除所有 .log 文件：rm *.log
复制所有 urdf_ 前缀文件：cp urdf_* /dst
批量处理当前目录某类资产

关键约束：

必须很快：每条 shell 命令都可能触发
必须可预测：用户要一眼知道会匹配哪些文件
必须安全：不能因为一个模式导致卡死或难以理解的误删
必须能在 exec 之前展开：shell 需要先把参数展开成文件列表再调用程序

因此 glob 的表达能力刻意保持在一个“甜点区间”：够用，但不会失控。
2.2 Regex：计算中的“字符串结构识别”
典型需求：

从日志中抽取时间戳、ID、字段
校验格式（IP、UUID、版本号）
解析协议文本、配置文本

关键目标：

表达能力最大化：分组、捕获、重复次数、断言、替换
允许复杂约束：结构、边界、条件
在程序内部执行：对性能风险、可读性风险的容忍度更高（可控）


3. 语法与能力：差异从根上决定了“不会统一”
3.1 Globbing 的常见语法（有限但高频）

  
      
          写法
          含义
          示例
      
  
  
      
          *
          任意长度字符
          *.urdf
      
      
          ?
          单个字符
          file?.txt
      
      
          [abc]
          任意一个字符
          mesh_[ab].obj
      
      
          [a-z]
          范围
          [0-9]*.log
      
      
          {a,b}
          brace expansion（shell 特性）
          file.{png,jpg}
      
  


注：{a,b} 属于 shell 的 brace expansion；它不是 POSIX glob 的核心，但在 bash/zsh 中非常常见。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://analyst-huang.github.io/posts/"},{"@type":"ListItem","position":3,"name":"globbing and regex","item":"https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/globbing_and_regex/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"globbing and regex","name":"globbing and regex","description":"Globbing vs Regex：为什么会有两种“匹配语言”？ 在日常开发里，我们经常把“模式匹配”混为一谈：\nls *.urdf、rm mesh_* 这类 globbing（通配/路径匹配） grep -E 'urdf_[0-9]+\\.obj'、re.match(r'^urdf_\\d+\\.obj$') 这类 regex（正则/文本匹配） 它们看起来都在“匹配”，但诞生目的、执行位置、工程约束完全不同，因此长期并存，且不可互相取代。\n1. 一句话结论 Globbing 是为“选择文件集合”而生的路径匹配语言；Regex 是为“识别字符串结构”而生的通用文本匹配语言。\n这不是历史包袱，而是系统边界的理性分工：\nglob：快、可预测、安全，适配 shell 的交互与文件系统 regex：表达力强，适配应用内部的字符串解析与结构约束 2. 两者解决的是不同问题域 2.1 Globbing：人机交互中的“文件集合选择” 典型需求：\n删除所有 .log 文件：rm *.log 复制所有 urdf_ 前缀文件：cp urdf_* /dst 批量处理当前目录某类资产 关键约束：\n必须很快：每条 shell 命令都可能触发 必须可预测：用户要一眼知道会匹配哪些文件 必须安全：不能因为一个模式导致卡死或难以理解的误删 必须能在 exec 之前展开：shell 需要先把参数展开成文件列表再调用程序 因此 glob 的表达能力刻意保持在一个“甜点区间”：够用，但不会失控。\n2.2 Regex：计算中的“字符串结构识别” 典型需求：\n从日志中抽取时间戳、ID、字段 校验格式（IP、UUID、版本号） 解析协议文本、配置文本 关键目标：\n表达能力最大化：分组、捕获、重复次数、断言、替换 允许复杂约束：结构、边界、条件 在程序内部执行：对性能风险、可读性风险的容忍度更高（可控） 3. 语法与能力：差异从根上决定了“不会统一” 3.1 Globbing 的常见语法（有限但高频） 写法 含义 示例 * 任意长度字符 *.urdf ? 单个字符 file?.txt [abc] 任意一个字符 mesh_[ab].obj [a-z] 范围 [0-9]*.log {a,b} brace expansion（shell 特性） file.{png,jpg} 注：{a,b} 属于 shell 的 brace expansion；它不是 POSIX glob 的核心，但在 bash/zsh 中非常常见。\n","keywords":[],"articleBody":"Globbing vs Regex：为什么会有两种“匹配语言”？ 在日常开发里，我们经常把“模式匹配”混为一谈：\nls *.urdf、rm mesh_* 这类 globbing（通配/路径匹配） grep -E 'urdf_[0-9]+\\.obj'、re.match(r'^urdf_\\d+\\.obj$') 这类 regex（正则/文本匹配） 它们看起来都在“匹配”，但诞生目的、执行位置、工程约束完全不同，因此长期并存，且不可互相取代。\n1. 一句话结论 Globbing 是为“选择文件集合”而生的路径匹配语言；Regex 是为“识别字符串结构”而生的通用文本匹配语言。\n这不是历史包袱，而是系统边界的理性分工：\nglob：快、可预测、安全，适配 shell 的交互与文件系统 regex：表达力强，适配应用内部的字符串解析与结构约束 2. 两者解决的是不同问题域 2.1 Globbing：人机交互中的“文件集合选择” 典型需求：\n删除所有 .log 文件：rm *.log 复制所有 urdf_ 前缀文件：cp urdf_* /dst 批量处理当前目录某类资产 关键约束：\n必须很快：每条 shell 命令都可能触发 必须可预测：用户要一眼知道会匹配哪些文件 必须安全：不能因为一个模式导致卡死或难以理解的误删 必须能在 exec 之前展开：shell 需要先把参数展开成文件列表再调用程序 因此 glob 的表达能力刻意保持在一个“甜点区间”：够用，但不会失控。\n2.2 Regex：计算中的“字符串结构识别” 典型需求：\n从日志中抽取时间戳、ID、字段 校验格式（IP、UUID、版本号） 解析协议文本、配置文本 关键目标：\n表达能力最大化：分组、捕获、重复次数、断言、替换 允许复杂约束：结构、边界、条件 在程序内部执行：对性能风险、可读性风险的容忍度更高（可控） 3. 语法与能力：差异从根上决定了“不会统一” 3.1 Globbing 的常见语法（有限但高频） 写法 含义 示例 * 任意长度字符 *.urdf ? 单个字符 file?.txt [abc] 任意一个字符 mesh_[ab].obj [a-z] 范围 [0-9]*.log {a,b} brace expansion（shell 特性） file.{png,jpg} 注：{a,b} 属于 shell 的 brace expansion；它不是 POSIX glob 的核心，但在 bash/zsh 中非常常见。\n3.2 Regex 的关键能力（强表达） 能力 示例 分组/捕获 (\\d+) 或逻辑 `a 重复次数 {2,5}、+、* 边界 ^、$、\\b 断言 (?=...)、(?!...) 4. 为什么 shell 不直接用 regex 来匹配文件？ 表面上看，把 glob 升级成 regex 似乎能“一统天下”，但工程上会引发三类灾难。\n4.1 性能与实时性：regex 的最坏情况不可控 许多 regex 引擎采用回溯模型，存在最坏情况指数级的模式（典型“灾难回溯”）。\n如果 shell 在每次命令执行前都要对目录内容跑 regex：\n目录大时交互卡死 自动补全（tab completion）失效 脚本性能与稳定性不可预测 glob 的匹配模型简单，可严格控制上界复杂度，更符合 shell 的实时交互要求。\n4.2 安全与可预期性：文件操作需要“所见即所得” 考虑：\nrm -rf 如果 pattern 是复杂 regex：\n用户很难凭直觉判断匹配集合 误删风险上升 展开结果难以提前验证 glob 则更接近“视觉直觉”：*.log、mesh_* 的含义足够清晰。\n4.3 兼容性与工具链：quoting/escaping 规则会爆炸 shell 的展开链路通常类似：\n变量展开 → 引号规则 → glob 展开 → exec\n如果 glob 改成 regex：\n需要引入更复杂的转义、引用规则 不同 shell 之间不可避免地产生不兼容 脚本可移植性下降 Unix 体系长期强调“稳定的小语言 + 组合”，而不是“单一万能语法”。\n5. 反过来：为什么 regex 也不能取代 glob？ 用 regex 做文件选择通常意味着：\nls | grep -E '...' 代价是：\n多出额外进程（grep/awk） 组合管道更复杂、可读性下降 regex 本质上只看字符串，不理解文件系统层级、路径语义、链接等 交互体验差（补全、错误提示等） 换句话说：regex 适合“在已有文本上做识别”，而 glob 适合“在文件系统上做选择”。\n6. 一个对比例子：为什么 glob 做不到 regex 的精确性 目标：匹配 urdf_12_v3.obj、urdf_99_v10.obj。\n6.1 glob 只能模糊 urdf_*_v*.obj 它无法表达：\n_ 后必须是数字 v 后必须是数字 版本号位数约束 6.2 regex 可以精确表达 ^urdf_\\d+_v\\d+\\.obj$ 7. 工程实践：什么时候用哪一个？ 7.1 优先用 glob 的场景 前缀/后缀批量处理 按扩展名筛选 文件集合规模不大或可控 Python 示例：\nfrom glob import glob files = glob('urdf_*.obj') 7.2 使用 regex 的场景 文件名包含语义结构（编号、版本、参数） 需要校验命名合法性 需要从名称中提取字段 Python 示例：\nimport re pat = re.compile(r'^urdf_(\\d+)_v(\\d+)\\.obj$') 7.3 推荐的混合策略（常用且高效） 先用 glob 缩小候选集，再用 regex 精确筛选与抽取。\nfrom glob import glob import os, re pat = re.compile(r'^urdf_(\\d+)_v(\\d+)\\.obj$') for path in glob('urdf_*.obj'): name = os.path.basename(path) m = pat.match(name) if not m: continue obj_id, ver = map(int, m.groups()) # ...处理... 8. 与 rm 相关的常见误区（快速排雷） rm / ls / cp 本身通常不解析 regex；它们接收到的是 shell 已展开后的参数 rm urdf_[0-9]+.obj 会错，因为 + 不是 glob 语法 如果你确实需要“按 regex 删除”，常见做法是 find -regex ... -delete 或管道筛选后再删除。\n9. 总结 两种匹配语言并存的根因，是它们站在不同的系统层级、服务不同的工程目标：\nglob：为 shell 的交互与文件系统“选对象集合”优化——快、安全、可预测 regex：为应用中的字符串结构识别优化——表达力强、可抽取、可替换 试图用单一语言统一两者，要么牺牲交互安全与确定性，要么牺牲表达能力。这种分层不是偶然，而是系统设计中常见的“边界不可塌缩”。\n","wordCount":"336","inLanguage":"en","datePublished":"2026-01-20T00:00:00Z","dateModified":"2026-01-20T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/globbing_and_regex/"},"publisher":{"@type":"Organization","name":"Blog","logo":{"@type":"ImageObject","url":"https://analyst-huang.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://analyst-huang.github.io/ accesskey=h title="Blog (Alt + H)">Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://analyst-huang.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://analyst-huang.github.io/about/ title=关于><span>关于</span></a></li><li><a href=https://analyst-huang.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://analyst-huang.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://analyst-huang.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">globbing and regex</h1><div class=post-meta><span title='2026-01-20 00:00:00 +0000 UTC'>January 20, 2026</span>&nbsp;·&nbsp;<span>2 min</span></div></header><div class=post-content><h1 id=globbing-vs-regex为什么会有两种匹配语言>Globbing vs Regex：为什么会有两种“匹配语言”？<a hidden class=anchor aria-hidden=true href=#globbing-vs-regex为什么会有两种匹配语言>#</a></h1><p>在日常开发里，我们经常把“模式匹配”混为一谈：</p><ul><li><code>ls *.urdf</code>、<code>rm mesh_*</code> 这类 <strong>globbing</strong>（通配/路径匹配）</li><li><code>grep -E 'urdf_[0-9]+\.obj'</code>、<code>re.match(r'^urdf_\d+\.obj$')</code> 这类 <strong>regex</strong>（正则/文本匹配）</li></ul><p>它们看起来都在“匹配”，但<strong>诞生目的、执行位置、工程约束</strong>完全不同，因此长期并存，且不可互相取代。</p><hr><h2 id=1-一句话结论>1. 一句话结论<a hidden class=anchor aria-hidden=true href=#1-一句话结论>#</a></h2><blockquote><p><strong>Globbing 是为“选择文件集合”而生的路径匹配语言；Regex 是为“识别字符串结构”而生的通用文本匹配语言。</strong></p></blockquote><p>这不是历史包袱，而是系统边界的理性分工：</p><ul><li>glob：快、可预测、安全，适配 shell 的交互与文件系统</li><li>regex：表达力强，适配应用内部的字符串解析与结构约束</li></ul><hr><h2 id=2-两者解决的是不同问题域>2. 两者解决的是不同问题域<a hidden class=anchor aria-hidden=true href=#2-两者解决的是不同问题域>#</a></h2><h3 id=21-globbing人机交互中的文件集合选择>2.1 Globbing：人机交互中的“文件集合选择”<a hidden class=anchor aria-hidden=true href=#21-globbing人机交互中的文件集合选择>#</a></h3><p>典型需求：</p><ul><li>删除所有 <code>.log</code> 文件：<code>rm *.log</code></li><li>复制所有 <code>urdf_</code> 前缀文件：<code>cp urdf_* /dst</code></li><li>批量处理当前目录某类资产</li></ul><p>关键约束：</p><ul><li><strong>必须很快</strong>：每条 shell 命令都可能触发</li><li><strong>必须可预测</strong>：用户要一眼知道会匹配哪些文件</li><li><strong>必须安全</strong>：不能因为一个模式导致卡死或难以理解的误删</li><li><strong>必须能在 exec 之前展开</strong>：shell 需要先把参数展开成文件列表再调用程序</li></ul><p>因此 glob 的表达能力刻意保持在一个“甜点区间”：够用，但不会失控。</p><h3 id=22-regex计算中的字符串结构识别>2.2 Regex：计算中的“字符串结构识别”<a hidden class=anchor aria-hidden=true href=#22-regex计算中的字符串结构识别>#</a></h3><p>典型需求：</p><ul><li>从日志中抽取时间戳、ID、字段</li><li>校验格式（IP、UUID、版本号）</li><li>解析协议文本、配置文本</li></ul><p>关键目标：</p><ul><li><strong>表达能力最大化</strong>：分组、捕获、重复次数、断言、替换</li><li><strong>允许复杂约束</strong>：结构、边界、条件</li><li><strong>在程序内部执行</strong>：对性能风险、可读性风险的容忍度更高（可控）</li></ul><hr><h2 id=3-语法与能力差异从根上决定了不会统一>3. 语法与能力：差异从根上决定了“不会统一”<a hidden class=anchor aria-hidden=true href=#3-语法与能力差异从根上决定了不会统一>#</a></h2><h3 id=31-globbing-的常见语法有限但高频>3.1 Globbing 的常见语法（有限但高频）<a hidden class=anchor aria-hidden=true href=#31-globbing-的常见语法有限但高频>#</a></h3><table><thead><tr><th>写法</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td><code>*</code></td><td>任意长度字符</td><td><code>*.urdf</code></td></tr><tr><td><code>?</code></td><td>单个字符</td><td><code>file?.txt</code></td></tr><tr><td><code>[abc]</code></td><td>任意一个字符</td><td><code>mesh_[ab].obj</code></td></tr><tr><td><code>[a-z]</code></td><td>范围</td><td><code>[0-9]*.log</code></td></tr><tr><td><code>{a,b}</code></td><td>brace expansion（shell 特性）</td><td><code>file.{png,jpg}</code></td></tr></tbody></table><blockquote><p>注：<code>{a,b}</code> 属于 shell 的 brace expansion；它不是 POSIX glob 的核心，但在 bash/zsh 中非常常见。</p></blockquote><h3 id=32-regex-的关键能力强表达>3.2 Regex 的关键能力（强表达）<a hidden class=anchor aria-hidden=true href=#32-regex-的关键能力强表达>#</a></h3><table><thead><tr><th>能力</th><th>示例</th></tr></thead><tbody><tr><td>分组/捕获</td><td><code>(\d+)</code></td></tr><tr><td>或逻辑</td><td>`a</td></tr><tr><td>重复次数</td><td><code>{2,5}</code>、<code>+</code>、<code>*</code></td></tr><tr><td>边界</td><td><code>^</code>、<code>$</code>、<code>\b</code></td></tr><tr><td>断言</td><td><code>(?=...)</code>、<code>(?!...)</code></td></tr></tbody></table><hr><h2 id=4-为什么-shell-不直接用-regex-来匹配文件>4. 为什么 shell 不直接用 regex 来匹配文件？<a hidden class=anchor aria-hidden=true href=#4-为什么-shell-不直接用-regex-来匹配文件>#</a></h2><p>表面上看，把 glob 升级成 regex 似乎能“一统天下”，但工程上会引发三类灾难。</p><h3 id=41-性能与实时性regex-的最坏情况不可控>4.1 性能与实时性：regex 的最坏情况不可控<a hidden class=anchor aria-hidden=true href=#41-性能与实时性regex-的最坏情况不可控>#</a></h3><p>许多 regex 引擎采用回溯模型，存在<strong>最坏情况指数级</strong>的模式（典型“灾难回溯”）。</p><p>如果 shell 在每次命令执行前都要对目录内容跑 regex：</p><ul><li>目录大时交互卡死</li><li>自动补全（tab completion）失效</li><li>脚本性能与稳定性不可预测</li></ul><p>glob 的匹配模型简单，可严格控制上界复杂度，更符合 shell 的实时交互要求。</p><h3 id=42-安全与可预期性文件操作需要所见即所得>4.2 安全与可预期性：文件操作需要“所见即所得”<a hidden class=anchor aria-hidden=true href=#42-安全与可预期性文件操作需要所见即所得>#</a></h3><p>考虑：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>rm -rf &lt;pattern&gt;
</span></span></code></pre></div><p>如果 pattern 是复杂 regex：</p><ul><li>用户很难凭直觉判断匹配集合</li><li>误删风险上升</li><li>展开结果难以提前验证</li></ul><p>glob 则更接近“视觉直觉”：<code>*.log</code>、<code>mesh_*</code> 的含义足够清晰。</p><h3 id=43-兼容性与工具链quotingescaping-规则会爆炸>4.3 兼容性与工具链：quoting/escaping 规则会爆炸<a hidden class=anchor aria-hidden=true href=#43-兼容性与工具链quotingescaping-规则会爆炸>#</a></h3><p>shell 的展开链路通常类似：</p><blockquote><p>变量展开 → 引号规则 → glob 展开 → exec</p></blockquote><p>如果 glob 改成 regex：</p><ul><li>需要引入更复杂的转义、引用规则</li><li>不同 shell 之间不可避免地产生不兼容</li><li>脚本可移植性下降</li></ul><p>Unix 体系长期强调“稳定的小语言 + 组合”，而不是“单一万能语法”。</p><hr><h2 id=5-反过来为什么-regex-也不能取代-glob>5. 反过来：为什么 regex 也不能取代 glob？<a hidden class=anchor aria-hidden=true href=#5-反过来为什么-regex-也不能取代-glob>#</a></h2><p>用 regex 做文件选择通常意味着：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>ls | grep -E <span style=color:#e6db74>&#39;...&#39;</span>
</span></span></code></pre></div><p>代价是：</p><ul><li>多出额外进程（<code>grep</code>/<code>awk</code>）</li><li>组合管道更复杂、可读性下降</li><li>regex 本质上只看字符串，不理解文件系统层级、路径语义、链接等</li><li>交互体验差（补全、错误提示等）</li></ul><p>换句话说：regex 适合“在已有文本上做识别”，而 glob 适合“在文件系统上做选择”。</p><hr><h2 id=6-一个对比例子为什么-glob-做不到-regex-的精确性>6. 一个对比例子：为什么 glob 做不到 regex 的精确性<a hidden class=anchor aria-hidden=true href=#6-一个对比例子为什么-glob-做不到-regex-的精确性>#</a></h2><p>目标：匹配 <code>urdf_12_v3.obj</code>、<code>urdf_99_v10.obj</code>。</p><h3 id=61-glob-只能模糊>6.1 glob 只能模糊<a hidden class=anchor aria-hidden=true href=#61-glob-只能模糊>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>urdf_*_v*.obj
</span></span></code></pre></div><p>它无法表达：</p><ul><li><code>_</code> 后必须是数字</li><li><code>v</code> 后必须是数字</li><li>版本号位数约束</li></ul><h3 id=62-regex-可以精确表达>6.2 regex 可以精确表达<a hidden class=anchor aria-hidden=true href=#62-regex-可以精确表达>#</a></h3><pre tabindex=0><code class=language-regex data-lang=regex>^urdf_\d+_v\d+\.obj$
</code></pre><hr><h2 id=7-工程实践什么时候用哪一个>7. 工程实践：什么时候用哪一个？<a hidden class=anchor aria-hidden=true href=#7-工程实践什么时候用哪一个>#</a></h2><h3 id=71-优先用-glob-的场景>7.1 优先用 glob 的场景<a hidden class=anchor aria-hidden=true href=#71-优先用-glob-的场景>#</a></h3><ul><li>前缀/后缀批量处理</li><li>按扩展名筛选</li><li>文件集合规模不大或可控</li></ul><p>Python 示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> glob <span style=color:#f92672>import</span> glob
</span></span><span style=display:flex><span>files <span style=color:#f92672>=</span> glob(<span style=color:#e6db74>&#39;urdf_*.obj&#39;</span>)
</span></span></code></pre></div><h3 id=72-使用-regex-的场景>7.2 使用 regex 的场景<a hidden class=anchor aria-hidden=true href=#72-使用-regex-的场景>#</a></h3><ul><li>文件名包含语义结构（编号、版本、参数）</li><li>需要校验命名合法性</li><li>需要从名称中提取字段</li></ul><p>Python 示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> re
</span></span><span style=display:flex><span>pat <span style=color:#f92672>=</span> re<span style=color:#f92672>.</span>compile(<span style=color:#e6db74>r</span><span style=color:#e6db74>&#39;^urdf_(\d+)_v(\d+)\.obj$&#39;</span>)
</span></span></code></pre></div><h3 id=73-推荐的混合策略常用且高效>7.3 推荐的混合策略（常用且高效）<a hidden class=anchor aria-hidden=true href=#73-推荐的混合策略常用且高效>#</a></h3><blockquote><p><strong>先用 glob 缩小候选集，再用 regex 精确筛选与抽取。</strong></p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> glob <span style=color:#f92672>import</span> glob
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> os<span style=color:#f92672>,</span> re
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pat <span style=color:#f92672>=</span> re<span style=color:#f92672>.</span>compile(<span style=color:#e6db74>r</span><span style=color:#e6db74>&#39;^urdf_(\d+)_v(\d+)\.obj$&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> path <span style=color:#f92672>in</span> glob(<span style=color:#e6db74>&#39;urdf_*.obj&#39;</span>):
</span></span><span style=display:flex><span>    name <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>path<span style=color:#f92672>.</span>basename(path)
</span></span><span style=display:flex><span>    m <span style=color:#f92672>=</span> pat<span style=color:#f92672>.</span><span style=color:#66d9ef>match</span>(name)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> m:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>    obj_id, ver <span style=color:#f92672>=</span> map(int, m<span style=color:#f92672>.</span>groups())
</span></span><span style=display:flex><span>    <span style=color:#75715e># ...处理...</span>
</span></span></code></pre></div><hr><h2 id=8-与-rm-相关的常见误区快速排雷>8. 与 <code>rm</code> 相关的常见误区（快速排雷）<a hidden class=anchor aria-hidden=true href=#8-与-rm-相关的常见误区快速排雷>#</a></h2><ul><li><code>rm</code> / <code>ls</code> / <code>cp</code> 本身通常<strong>不解析 regex</strong>；它们接收到的是 shell 已展开后的参数</li><li><code>rm urdf_[0-9]+.obj</code> 会错，因为 <code>+</code> 不是 glob 语法</li></ul><p>如果你确实需要“按 regex 删除”，常见做法是 <code>find -regex ... -delete</code> 或管道筛选后再删除。</p><hr><h2 id=9-总结>9. 总结<a hidden class=anchor aria-hidden=true href=#9-总结>#</a></h2><p>两种匹配语言并存的根因，是它们站在不同的系统层级、服务不同的工程目标：</p><ul><li><strong>glob</strong>：为 shell 的交互与文件系统“选对象集合”优化——快、安全、可预测</li><li><strong>regex</strong>：为应用中的字符串结构识别优化——表达力强、可抽取、可替换</li></ul><p>试图用单一语言统一两者，要么牺牲交互安全与确定性，要么牺牲表达能力。这种分层不是偶然，而是系统设计中常见的“边界不可塌缩”。</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://analyst-huang.github.io/>Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>