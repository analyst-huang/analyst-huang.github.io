<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Blog</title><link>https://analyst-huang.github.io/</link><description>Recent content on Blog</description><generator>Hugo -- 0.154.5</generator><language>zh-cn</language><lastBuildDate>Tue, 20 Jan 2026 00:00:00 +0000</lastBuildDate><atom:link href="https://analyst-huang.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Elementary Calculus: An Infinitesimal Approach: Chapter 1</title><link>https://analyst-huang.github.io/posts/math/elementary_calculus_an_infinitesimal_approach_chapter_1/</link><pubDate>Tue, 20 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/math/elementary_calculus_an_infinitesimal_approach_chapter_1/</guid><description>&lt;h2 id="前言"&gt;前言&lt;/h2&gt;
&lt;p&gt;在大一的时候就在高数的书上看到了对非标准分析的科普，当时就找来了Robinson的大部头来看，结果当然是看不懂了，毕竟当时的数学基础很差。最近有空，而且LLM也发展的很好，很多问题都不用自己一个人苦思冥想，还不知道对不对了。所以挑了一本先把模型论等等的知识作直觉把握，然后重写微积分（严谨地）的书。&lt;/p&gt;
&lt;h1 id="tldr"&gt;TLDR;&lt;/h1&gt;
&lt;p&gt;非标准分析之所以在某些方面比$\delta-\epsilon$语言清晰和简明，是因为通过将$\mathbb{R}$扩张为$\mathbb{R}^*$（超实数），将$\delta-\epsilon$语言的外在的量词压缩到了无穷小这个超实数的定义中。例如f(x)在a处的极限：&lt;/p&gt;
&lt;div align="center"&gt;
∀ε&gt;0∃δ&gt;0(∀x,∣x−a∣&lt;δ⇒∣f(x)−f(a)∣&lt;ε)
&lt;/div&gt;
如果我们用非标准分析的语言来写，那么这个命题可以写成：
&lt;div align="center"&gt;
∀x≈a,f(x)≈f(a)
&lt;/div&gt;
其中 x≈a的定义是 x-a是无穷小（指的是超实数，不是原来$\delta-\epsilon$语言的无穷小）。换言之，"对于任意的epsilon"在这里已经被作为*超实数*的无穷小这个概念所覆盖了。
&lt;h2 id="超实数轴the-hyperreal-line"&gt;超实数轴(The Hyperreal Line)&lt;/h2&gt;
&lt;p&gt;超实数是对实数的扩展：两端的无穷大，原点附近的无穷小，以及每个实数附近的超实数。通过模型论，可以严格保证——所有关于实数的标准一阶命题，在超实数体系中仍然成立。如果不深入模型论，只需要记住几个principle就可以了。&lt;/p&gt;
&lt;h3 id="the-extension-principle"&gt;THE EXTENSION PRINCIPLE&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The real numbers from a subset of the hyperreal numbers, and the order relation of x &amp;lt; y for the real numbers is a subset of the order relation for the hyperreal numbers.&lt;/li&gt;
&lt;li&gt;There is a hyperreal number that is greater than zero but less than every positive real number.&lt;/li&gt;
&lt;li&gt;For every real function of one or more variable we are given a corresponding hyperreal function f* of the same number of variables. f* is called the natural extension of f.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="remark"&gt;Remark&lt;/h4&gt;
&lt;p&gt;这条准则给出了超实数的扩展方式。这里的natural extension并不是说给超实数来了一个函数的映射关系，而是说，这个延拓出来的函数，保持实数集上的性质，并且将会满足TRANSFER PRINCIPLE(见下)。&lt;/p&gt;</description></item><item><title>globbing and regex</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/globbing_and_regex/</link><pubDate>Tue, 20 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/globbing_and_regex/</guid><description>&lt;h1 id="globbing-vs-regex为什么会有两种匹配语言"&gt;Globbing vs Regex：为什么会有两种“匹配语言”？&lt;/h1&gt;
&lt;p&gt;在日常开发里，我们经常把“模式匹配”混为一谈：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ls *.urdf&lt;/code&gt;、&lt;code&gt;rm mesh_*&lt;/code&gt; 这类 &lt;strong&gt;globbing&lt;/strong&gt;（通配/路径匹配）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;grep -E 'urdf_[0-9]+\.obj'&lt;/code&gt;、&lt;code&gt;re.match(r'^urdf_\d+\.obj$')&lt;/code&gt; 这类 &lt;strong&gt;regex&lt;/strong&gt;（正则/文本匹配）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它们看起来都在“匹配”，但&lt;strong&gt;诞生目的、执行位置、工程约束&lt;/strong&gt;完全不同，因此长期并存，且不可互相取代。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="1-一句话结论"&gt;1. 一句话结论&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Globbing 是为“选择文件集合”而生的路径匹配语言；Regex 是为“识别字符串结构”而生的通用文本匹配语言。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这不是历史包袱，而是系统边界的理性分工：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;glob：快、可预测、安全，适配 shell 的交互与文件系统&lt;/li&gt;
&lt;li&gt;regex：表达力强，适配应用内部的字符串解析与结构约束&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-两者解决的是不同问题域"&gt;2. 两者解决的是不同问题域&lt;/h2&gt;
&lt;h3 id="21-globbing人机交互中的文件集合选择"&gt;2.1 Globbing：人机交互中的“文件集合选择”&lt;/h3&gt;
&lt;p&gt;典型需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除所有 &lt;code&gt;.log&lt;/code&gt; 文件：&lt;code&gt;rm *.log&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;复制所有 &lt;code&gt;urdf_&lt;/code&gt; 前缀文件：&lt;code&gt;cp urdf_* /dst&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;批量处理当前目录某类资产&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关键约束：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;必须很快&lt;/strong&gt;：每条 shell 命令都可能触发&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;必须可预测&lt;/strong&gt;：用户要一眼知道会匹配哪些文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;必须安全&lt;/strong&gt;：不能因为一个模式导致卡死或难以理解的误删&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;必须能在 exec 之前展开&lt;/strong&gt;：shell 需要先把参数展开成文件列表再调用程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此 glob 的表达能力刻意保持在一个“甜点区间”：够用，但不会失控。&lt;/p&gt;
&lt;h3 id="22-regex计算中的字符串结构识别"&gt;2.2 Regex：计算中的“字符串结构识别”&lt;/h3&gt;
&lt;p&gt;典型需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从日志中抽取时间戳、ID、字段&lt;/li&gt;
&lt;li&gt;校验格式（IP、UUID、版本号）&lt;/li&gt;
&lt;li&gt;解析协议文本、配置文本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关键目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;表达能力最大化&lt;/strong&gt;：分组、捕获、重复次数、断言、替换&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;允许复杂约束&lt;/strong&gt;：结构、边界、条件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在程序内部执行&lt;/strong&gt;：对性能风险、可读性风险的容忍度更高（可控）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="3-语法与能力差异从根上决定了不会统一"&gt;3. 语法与能力：差异从根上决定了“不会统一”&lt;/h2&gt;
&lt;h3 id="31-globbing-的常见语法有限但高频"&gt;3.1 Globbing 的常见语法（有限但高频）&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;写法&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任意长度字符&lt;/td&gt;
&lt;td&gt;&lt;code&gt;*.urdf&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;?&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;单个字符&lt;/td&gt;
&lt;td&gt;&lt;code&gt;file?.txt&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[abc]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任意一个字符&lt;/td&gt;
&lt;td&gt;&lt;code&gt;mesh_[ab].obj&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[a-z]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;范围&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[0-9]*.log&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;{a,b}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;brace expansion（shell 特性）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;file.{png,jpg}&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;注：&lt;code&gt;{a,b}&lt;/code&gt; 属于 shell 的 brace expansion；它不是 POSIX glob 的核心，但在 bash/zsh 中非常常见。&lt;/p&gt;</description></item><item><title>xargs</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/xargs/</link><pubDate>Tue, 20 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/xargs/</guid><description>&lt;h1 id="xargs--i-的读取模型与分隔符机制详解"&gt;xargs -I 的读取模型与分隔符机制详解&lt;/h1&gt;
&lt;p&gt;在日常 Linux 批处理管道中，&lt;code&gt;xargs&lt;/code&gt;
经常被用于把标准输入转换为命令参数。其中，&lt;code&gt;-I&lt;/code&gt; 模式与默认模式在
&lt;strong&gt;输入切分（tokenization / record parsing）&lt;/strong&gt;
上存在本质差异。理解这一点，对于安全处理文件名、构造复杂命令模板以及性能优化非常关键。&lt;/p&gt;
&lt;p&gt;本文系统整理以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;-I&lt;/code&gt; 时是否只能一行一行读取？&lt;/li&gt;
&lt;li&gt;是否可以自定义分隔符？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-I&lt;/code&gt; 与默认模式在行为与性能上的核心区别&lt;/li&gt;
&lt;li&gt;实战建议与最佳实践&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="1-xargs--i-的基本语义"&gt;1. &lt;code&gt;xargs -I&lt;/code&gt; 的基本语义&lt;/h2&gt;
&lt;p&gt;使用 &lt;code&gt;-I&lt;/code&gt; 时，&lt;code&gt;xargs&lt;/code&gt; 进入 &lt;strong&gt;模板替换模式（template substitution
mode）&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;xargs -I&lt;span style="color:#f92672"&gt;{}&lt;/span&gt; command &lt;span style="color:#e6db74"&gt;&amp;#34;{}&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;含义是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对每一条输入记录，将其替换到模板中的 &lt;code&gt;{}&lt;/code&gt; 位置，然后执行一次命令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;printf &lt;span style="color:#e6db74"&gt;&amp;#39;%s
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#e6db74"&gt;&amp;#39;&lt;/span&gt; a b c | xargs -I&lt;span style="color:#f92672"&gt;{}&lt;/span&gt; echo &lt;span style="color:#e6db74"&gt;&amp;#34;item={}&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;# 输出：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;# item=a&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;# item=b&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;# item=c&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;核心特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每条输入 → 一次命令执行&lt;/li&gt;
&lt;li&gt;输入内容整体保留，不再按空格拆分&lt;/li&gt;
&lt;li&gt;适合需要把输入插入到命令中间或多处的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-是否只能一行一行读取"&gt;2. 是否只能&amp;quot;一行一行读取&amp;quot;？&lt;/h2&gt;
&lt;h3 id="默认行为按行读取"&gt;默认行为：按&amp;quot;行&amp;quot;读取&lt;/h3&gt;
&lt;p&gt;当启用 &lt;code&gt;-I&lt;/code&gt; 时，&lt;code&gt;xargs&lt;/code&gt; 默认以 &lt;strong&gt;换行符 (&lt;code&gt;\n&lt;/code&gt;) 作为记录分隔符&lt;/strong&gt;。&lt;/p&gt;</description></item><item><title>XML 语法与工程实践：从树模型到 XPath、Namespace 与 CDATA</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/xml/</link><pubDate>Mon, 19 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/xml/</guid><description>&lt;h2 id="0-这篇文章解决什么问题"&gt;0. 这篇文章解决什么问题&lt;/h2&gt;
&lt;p&gt;XML（eXtensible Markup Language）经常被当作“带尖括号的文本”。但在工程场景（URDF、USD/Omniverse 配置、各种工具链描述文件）里，理解 XML 的关键并不是记住几个标签写法，而是把它当成：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;一棵“有序树 + 属性 + 文本”的数据结构&lt;/strong&gt;&lt;br&gt;
程序读的不是字符流，而是结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文从这个树模型出发，系统整理 XML 的核心语法与常见机制：&lt;code&gt;text/tail&lt;/code&gt;、XPath、Namespace、CDATA，并给出 Python（ElementTree）与命令行工具的可用做法。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="1-markup-language-是什么用标记把文本变成结构"&gt;1. Markup Language 是什么：用“标记”把文本变成结构&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Markup Language（标记语言）&lt;strong&gt;的本质：用标签（tag）给文本加上&lt;/strong&gt;边界、层级与语义&lt;/strong&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-xml" data-lang="xml"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;robot&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;name=&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#34;taco&amp;#34;&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#f92672"&gt;&amp;lt;link&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;name=&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#34;base_link&amp;#34;&lt;/span&gt;&lt;span style="color:#f92672"&gt;/&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;/robot&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这不是“字符串里夹标签”，而是树：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;robot (name=&amp;#34;taco&amp;#34;)
└── link (name=&amp;#34;base_link&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;标签名是“语义”，属性是“参数”，嵌套是“结构”。&lt;br&gt;
因此 XML 的强项是：&lt;strong&gt;跨系统传递结构化语义&lt;/strong&gt;（而不是仅仅渲染）。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="2-xml-的基本语法严格规则"&gt;2. XML 的基本语法（严格规则）&lt;/h2&gt;
&lt;p&gt;XML 比 HTML 严格得多。常见约束如下：&lt;/p&gt;
&lt;h3 id="21-标签必须闭合"&gt;2.1 标签必须闭合&lt;/h3&gt;
&lt;p&gt;✅ 正确：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-xml" data-lang="xml"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;mesh&amp;gt;&amp;lt;/mesh&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;mesh&lt;/span&gt; &lt;span style="color:#f92672"&gt;/&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;❌ 错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-xml" data-lang="xml"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;mesh&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="22-区分大小写"&gt;2.2 区分大小写&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-xml" data-lang="xml"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;Mesh&amp;gt;&lt;/span&gt; ≠ &lt;span style="color:#f92672"&gt;&amp;lt;mesh&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="23-属性必须加引号"&gt;2.3 属性必须加引号&lt;/h3&gt;
&lt;p&gt;✅&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-xml" data-lang="xml"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;link&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;name=&lt;/span&gt;&lt;span style="color:#e6db74"&gt;&amp;#34;base_link&amp;#34;&lt;/span&gt;&lt;span style="color:#f92672"&gt;/&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;❌&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-xml" data-lang="xml"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;link&lt;/span&gt; &lt;span style="color:#a6e22e"&gt;name=&lt;/span&gt;&lt;span style="color:#e6db74"&gt;base_link/&lt;/span&gt;&lt;span style="color:#f92672"&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="24-必须正确嵌套且只有一个根节点"&gt;2.4 必须正确嵌套，且只有一个根节点&lt;/h3&gt;
&lt;p&gt;✅&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-xml" data-lang="xml"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;a&amp;gt;&amp;lt;b/&amp;gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;❌&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-xml" data-lang="xml"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;&amp;lt;a&amp;gt;&amp;lt;b&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/b&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id="3-element--attribute--text把-xml-当成对象模型"&gt;3. Element / Attribute / Text：把 XML 当成对象模型&lt;/h2&gt;
&lt;p&gt;一个元素（Element）由：&lt;/p&gt;</description></item><item><title>爬虫爬取淘股吧</title><link>https://analyst-huang.github.io/posts/%E6%9D%82%E8%B0%88/%E7%88%AC%E8%99%AB%E5%88%9D%E6%8E%A2/</link><pubDate>Fri, 16 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E6%9D%82%E8%B0%88/%E7%88%AC%E8%99%AB%E5%88%9D%E6%8E%A2/</guid><description>&lt;p&gt;因为之前公众号封过一次，所以当时将近一个月的复盘笔记全部拿不回来了。所以又过了半年，写了一个爬虫把tgb的帖子全部爬下来。上次写爬虫还是大一的时候的课程作业。
不得不说还是有点烦的。要存state，要用devtool，要看css selector。这玩意真是纯粹的工程了。
本来还说要不要记录什么东西。后来发现，没什么好记录的，用的熟当然厉害，但是我也不是干这个的，所以记录几个关键词得了（&lt;/p&gt;</description></item><item><title>利用大模型读论文</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E8%AF%BB%E8%AE%BA%E6%96%87/</link><pubDate>Tue, 13 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E8%AF%BB%E8%AE%BA%E6%96%87/</guid><description>&lt;p&gt;之前用大模型看论文总觉得没有用对，因为效率不高，有各种繁琐的操作，并且理解的程度也不够。&lt;/p&gt;
&lt;p&gt;今天发现，最后的拼图其实是&lt;strong&gt;记事本&lt;/strong&gt;，因为模型因为system prompt或者其他的原因，可能回复的很长，如果在当前页面问某个细节，就完全打乱了思路，但是如果把问题全部记录在记事本里面，然后一下子问，反复迭代，问题就会变少，理解也会变清晰。&lt;/p&gt;
&lt;p&gt;以及要一个一个模块问，比如说“详细介绍方法，不要漏掉一个细节”，必须一个模块一个模块过，才不会不理解，细节也不能错过。&lt;/p&gt;</description></item><item><title>在 .bashrc 设置 LD_LIBRARY_PATH 导致 bash 提示 libtinfo.so.6: no version information available 的原因与影响</title><link>https://analyst-huang.github.io/posts/%E6%9D%82%E8%B0%88/ld_library_path_libtinfo_bash_warning/</link><pubDate>Tue, 13 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E6%9D%82%E8%B0%88/ld_library_path_libtinfo_bash_warning/</guid><description>&lt;h2 id="现象"&gt;现象&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;~/.bashrc&lt;/code&gt; 中全局设置了类似下面的环境变量后：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;export LD_LIBRARY_PATH&lt;span style="color:#f92672"&gt;=&lt;/span&gt;/home/ziye_huang/anaconda3/envs/isaacgym/lib:$LD_LIBRARY_PATH
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;启动新的终端或执行 &lt;code&gt;/bin/bash&lt;/code&gt; 时会出现警告：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-text" data-lang="text"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;/home/ziye_huang/anaconda3/envs/isaacgym/lib/libtinfo.so.6: no version information available (required by /bin/bash)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这通常发生在 &lt;strong&gt;Conda 环境的动态库优先级&lt;/strong&gt; 覆盖了系统库之后。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="背景bash-为什么会碰到-libtinfo"&gt;背景：bash 为什么会碰到 libtinfo&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bash&lt;/code&gt; 在很多发行版上会链接到 &lt;code&gt;readline&lt;/code&gt;/&lt;code&gt;ncurses&lt;/code&gt; 相关库（交互式编辑、历史记录、终端能力等）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ncurses&lt;/code&gt; 的一部分拆分为 &lt;code&gt;libtinfo&lt;/code&gt;（terminfo 数据与接口）。&lt;/li&gt;
&lt;li&gt;因此，&lt;code&gt;/bin/bash&lt;/code&gt; 在启动时会通过动态链接器加载 &lt;code&gt;libtinfo.so.6&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关键点在于：&lt;strong&gt;动态链接器会按搜索顺序选择要加载的 &lt;code&gt;libtinfo.so.6&lt;/code&gt; 的“具体文件”。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="根因ld_library_path-让-bash-先加载了-conda-里的-libtinfo"&gt;根因：LD_LIBRARY_PATH 让 bash 先加载了 Conda 里的 libtinfo&lt;/h2&gt;
&lt;h3 id="1-动态链接器的常见搜索顺序简化版"&gt;1) 动态链接器的常见搜索顺序（简化版）&lt;/h3&gt;
&lt;p&gt;通常会按优先级从高到低搜索：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可执行文件的 &lt;code&gt;RPATH/RUNPATH&lt;/code&gt;（如果存在）&lt;/li&gt;
&lt;li&gt;系统缓存 &lt;code&gt;/etc/ld.so.cache&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;默认系统目录（如 &lt;code&gt;/lib/x86_64-linux-gnu&lt;/code&gt;、&lt;code&gt;/usr/lib/x86_64-linux-gnu&lt;/code&gt; 等）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你在 &lt;code&gt;.bashrc&lt;/code&gt; 里 &lt;strong&gt;全局&lt;/strong&gt; 把：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;/home/ziye_huang/anaconda3/envs/isaacgym/lib
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;放到了 &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; 的最前面，使得启动 &lt;code&gt;/bin/bash&lt;/code&gt; 时，动态链接器优先选择了 Conda 环境中的：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;.../envs/isaacgym/lib/libtinfo.so.6
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而不是系统自带的 &lt;code&gt;libtinfo.so.6&lt;/code&gt;。&lt;/p&gt;</description></item><item><title>windows ctrl v 失效</title><link>https://analyst-huang.github.io/posts/%E6%9D%82%E8%B0%88/windows_ctrl_v/</link><pubDate>Sun, 11 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E6%9D%82%E8%B0%88/windows_ctrl_v/</guid><description>&lt;p&gt;搞了半天，原来是被向日葵这个进程阻碍了剪切板的正常使用，把向日葵关掉就能正常使用了。&lt;/p&gt;</description></item><item><title>zmq</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/zmq/</link><pubDate>Sun, 11 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/zmq/</guid><description>&lt;p&gt;最近在做机器人遥操，所以需要在多进程之间交换数据。直接用socket来写就太底层了，所以就研究了一下封装库zmq怎么用。结果出了一个延迟的bug，特此记录zmq的用法。&lt;/p&gt;
&lt;p&gt;ZeroMQ PUB-SUB 总结（代码导向）&lt;/p&gt;
&lt;p&gt;一、角色职责（Role Semantics）&lt;/p&gt;
&lt;p&gt;Publisher（PUB）&lt;/p&gt;
&lt;p&gt;职责：只负责发送消息（广播），不接收任何数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import zmq
ctx = zmq.Context()
pub = ctx.socket(zmq.PUB)
pub.bind(&amp;quot;tcp://*:5555&amp;quot;)
while True:
pub.send(b&amp;quot;state robot_pose=...&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;特点： - 只能 send()，不能 recv() - 不知道是否有订阅者 -
不关心订阅者订了什么&lt;/p&gt;
&lt;p&gt;Subscriber（SUB）&lt;/p&gt;
&lt;p&gt;职责：只负责接收并按 topic 过滤消息，不发送任何数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import zmq
ctx = zmq.Context()
sub = ctx.socket(zmq.SUB)
sub.connect(&amp;quot;tcp://localhost:5555&amp;quot;)
# 订阅前缀为 b&amp;quot;state&amp;quot; 的消息
sub.setsockopt(zmq.SUBSCRIBE, b&amp;quot;state&amp;quot;)
while True:
msg = sub.recv()
print(msg)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;特点： - 只能 recv()，不能 send() - 必须显式设置订阅规则 -
只能收到匹配前缀的消息&lt;/p&gt;
&lt;p&gt;二、连接方式（Connection Pattern）&lt;/p&gt;
&lt;p&gt;语义与 bind / connect 无关，只是部署方式不同。&lt;/p&gt;</description></item><item><title>精神分析与社交</title><link>https://analyst-huang.github.io/posts/%E6%9D%82%E8%B0%88/%E7%B2%BE%E7%A5%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%A4%BE%E4%BA%A4/</link><pubDate>Sun, 11 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E6%9D%82%E8%B0%88/%E7%B2%BE%E7%A5%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%A4%BE%E4%BA%A4/</guid><description>&lt;p&gt;三种读取基本幻想结构的方法（总—分结构）&lt;/p&gt;
&lt;p&gt;目标：在最短时间内，从话语与互动中判断主体的基本幻想结构，而非停留在性格或态度层面的印象。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;总论：三界协同下的幻想读取框架&lt;/p&gt;
&lt;p&gt;在拉康理论中，基本幻想并不是内心图像，而是主体在以下三个层面上的稳定配置：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;象征界（Symbolic）：主体如何获得话语与身份的合法性（大他者假设）&lt;/li&gt;
&lt;li&gt;实在界（Real）：主体在防御哪种作为 objet petit a
的坠落位置（核心恐惧）&lt;/li&gt;
&lt;li&gt;想象界（Imaginary）：主体如何在关系中重演并维持这一防御（互动脚本）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对应到实践中的三种读取方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法一：读语言中的合法性来源（象征层）&lt;/li&gt;
&lt;li&gt;方法二：读被遮蔽的 objet a 位置（实在层）&lt;/li&gt;
&lt;li&gt;方法三：读关系中的角色分配（想象层）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三者共同指向同一件事：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主体如何回答“我在他者欲望中是什么”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;方法一：通过语言判断合法性来源（象征界 / 大他者假设）&lt;/p&gt;
&lt;p&gt;核心问题&lt;/p&gt;
&lt;p&gt;主体在说话时，默认谁拥有裁决其话语与价值的权力？&lt;/p&gt;
&lt;p&gt;这对应的是主体对大他者位置的假设方式。&lt;/p&gt;
&lt;p&gt;可观察信号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;频繁引用：规则、制度、专家、行业共识&lt;/li&gt;
&lt;li&gt;强调：正常人、大家都觉得、社会现实&lt;/li&gt;
&lt;li&gt;道德化表达：应该、不应该、对与错&lt;/li&gt;
&lt;li&gt;清醒话语：别人都被洗脑了、只有少数人明白&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结构判断&lt;/p&gt;
&lt;p&gt;通过这些线索可以判断主体：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是依附稳定的大他者（规则 / 权威）&lt;/li&gt;
&lt;li&gt;还是依附社会共识（群体承认）&lt;/li&gt;
&lt;li&gt;还是依附道德正当性&lt;/li&gt;
&lt;li&gt;或是占据“去他者化”的清醒位置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该方法用于快速定位：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主体如何在象征秩序中获得自我合法性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;方法二：通过防御与贬斥判断 objet a 的恐惧位置（实在界 / 核心缺失）&lt;/p&gt;
&lt;p&gt;核心问题&lt;/p&gt;
&lt;p&gt;主体最无法承受自己在他者欲望中处于哪种位置？&lt;/p&gt;
&lt;p&gt;objet petit a 在这里不作为对象，而作为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主体可能坠入的“多余之物 / 被使用之物 / 被忽视之物”的位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可观察信号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对某类人或状态的高强度贬低&lt;/li&gt;
&lt;li&gt;对某些评价极端敏感&lt;/li&gt;
&lt;li&gt;反复自我辩护：“我其实不是那样的人”&lt;/li&gt;
&lt;li&gt;在特定话题上情绪迅速升级&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结构反推原则&lt;/p&gt;
&lt;p&gt;通常可以进行结构翻转：&lt;/p&gt;
&lt;p&gt;被强烈排斥的位置 ≈ 主体最恐惧坠入的位置&lt;/p&gt;
&lt;p&gt;常见对应关系&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;恐惧被抛弃 → 幻想为“我被需要”&lt;/li&gt;
&lt;li&gt;恐惧无价值 → 幻想为“我必须成功”&lt;/li&gt;
&lt;li&gt;恐惧被看穿 → 幻想为“我更清醒 / 更掌控”&lt;/li&gt;
&lt;li&gt;恐惧被忽视 → 幻想为“我必须占据中心”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该方法用于定位：&lt;/p&gt;</description></item><item><title>配置RSS reader</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/rss_reader/</link><pubDate>Sun, 11 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/rss_reader/</guid><description>&lt;p&gt;Feed 与 RSS：从信息推送到个人信息流的技术基础&lt;/p&gt;
&lt;p&gt;本文从工程与使用两个层面，系统性介绍： 1. Feed 与 RSS 的概念与格式 2.
RSS Reader 的实际好处 3. 如何将邮件转换为 RSS 4. 如何导出与迁移 OPML
配置&lt;/p&gt;
&lt;p&gt;适合希望构建个人信息流管道（personal information pipeline）的技术用户。&lt;/p&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;Feed 与 RSS&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1.1 什么是 Feed&lt;/p&gt;
&lt;p&gt;Feed 是一种“可被机器订阅的更新流”，本质是： - 按时间排序的条目（items /
entries） - 每条包含：标题、链接、摘要、发布时间等元数据 -
客户端可以周期性拉取并增量更新&lt;/p&gt;
&lt;p&gt;Feed 是概念层；RSS / Atom 是实现层的具体协议格式。&lt;/p&gt;
&lt;p&gt;1.2 一个最小 RSS 结构&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;rss version=&amp;quot;2.0&amp;quot;&amp;gt;
&amp;lt;channel&amp;gt;
&amp;lt;title&amp;gt;Example Feed&amp;lt;/title&amp;gt;
&amp;lt;link&amp;gt;https://example.com&amp;lt;/link&amp;gt;
&amp;lt;item&amp;gt;
&amp;lt;title&amp;gt;Post Title&amp;lt;/title&amp;gt;
&amp;lt;link&amp;gt;https://example.com/post&amp;lt;/link&amp;gt;
&amp;lt;pubDate&amp;gt;Mon, 12 Jan 2026 12:00:00 GMT&amp;lt;/pubDate&amp;gt;
&amp;lt;description&amp;gt;Summary...&amp;lt;/description&amp;gt;
&amp;lt;/item&amp;gt;
&amp;lt;/channel&amp;gt;
&amp;lt;/rss&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;RSS Reader 的工作本质是： - 周期性 GET - 解析 XML - 去重 -
按时间排序展示&lt;/p&gt;</description></item><item><title>Socket</title><link>https://analyst-huang.github.io/posts/system/socket/</link><pubDate>Fri, 09 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/system/socket/</guid><description>&lt;h1 id="进程内核与-socket通信机制要点"&gt;进程、内核与 Socket：通信机制要点&lt;/h1&gt;
&lt;h2 id="一每个进程都有哪些是独立的"&gt;一、每个进程都有哪些是“独立的”？&lt;/h2&gt;
&lt;p&gt;每个进程有独立的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虚拟地址空间&lt;/li&gt;
&lt;li&gt;寄存器上下文&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内核用&lt;strong&gt;时间片轮转&lt;/strong&gt;在同一颗物理 CPU 上切换它们。&lt;/p&gt;
&lt;p&gt;但有一件事是&lt;strong&gt;不虚拟的&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所有进程共享同一个操作系统内核。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而 &lt;strong&gt;socket 属于&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核对象（kernel object）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当你在用户态调用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-text" data-lang="text"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;sock.send(...)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;实际上发生的是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;触发系统调用（syscall）&lt;/li&gt;
&lt;li&gt;CPU 切到内核态&lt;/li&gt;
&lt;li&gt;内核代表你这个进程去执行真正的发送逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以通信的“公共场所”不是 CPU，而是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;内核里的网络协议栈 + 内核缓冲区&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="二socket-在内核里到底是什么"&gt;二、Socket 在内核里到底是什么？&lt;/h2&gt;
&lt;p&gt;从内核视角看，一个 socket 大致包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;socket 结构体&lt;/li&gt;
&lt;li&gt;接收缓冲区（recv buffer）&lt;/li&gt;
&lt;li&gt;发送缓冲区（send buffer）&lt;/li&gt;
&lt;li&gt;协议状态机（TCP 状态、序列号等）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个进程持有的其实只是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个文件描述符 &lt;code&gt;fd&lt;/code&gt; → 指向内核里的 socket 对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;两个进程可以分别持有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指向&lt;strong&gt;同一个 socket 对象&lt;/strong&gt;的 fd（例如通过 &lt;code&gt;fork&lt;/code&gt; 继承）&lt;/li&gt;
&lt;li&gt;或一对&lt;strong&gt;互相关联的 socket&lt;/strong&gt;（TCP 连接两端）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="socket-与-tcp-出现之前的通信历史极简时间线"&gt;Socket 与 TCP 出现之前的通信历史（极简时间线）&lt;/h1&gt;
&lt;h2 id="一最早期只有物理通信无协议"&gt;一、最早期：只有物理通信（无协议）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;串口、并口、专用总线&lt;/li&gt;
&lt;li&gt;直接发送电信号&lt;/li&gt;
&lt;li&gt;特点：
&lt;ul&gt;
&lt;li&gt;无地址&lt;/li&gt;
&lt;li&gt;无连接&lt;/li&gt;
&lt;li&gt;无可靠性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;本质：硬件层通信，没有操作系统抽象&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="二分组交换网络只有包没有连接"&gt;二、分组交换网络：只有“包”，没有“连接”&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ARPANET / 早期 IP 思想&lt;/li&gt;
&lt;li&gt;通信模型：
&lt;ul&gt;
&lt;li&gt;send(packet)&lt;/li&gt;
&lt;li&gt;网络尽力投递&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;特点：
&lt;ul&gt;
&lt;li&gt;无连接&lt;/li&gt;
&lt;li&gt;可能丢包 / 乱序 / 重复&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接近今天的：IP / UDP 语义&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="三应用自己实现可靠性应用层协议时代"&gt;三、应用自己实现可靠性（应用层协议时代）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;FTP / Telnet 等早期协议&lt;/li&gt;
&lt;li&gt;每个应用自己实现：
&lt;ul&gt;
&lt;li&gt;序号&lt;/li&gt;
&lt;li&gt;ACK&lt;/li&gt;
&lt;li&gt;重传&lt;/li&gt;
&lt;li&gt;流控&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;问题：
&lt;ul&gt;
&lt;li&gt;重复造轮子&lt;/li&gt;
&lt;li&gt;质量不可控&lt;/li&gt;
&lt;li&gt;网络整体容易拥塞&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="四tcp-的出现把可靠流下沉到内核"&gt;四、TCP 的出现：把“可靠流”下沉到内核&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;TCP 抽象：
&lt;ul&gt;
&lt;li&gt;可靠&lt;/li&gt;
&lt;li&gt;有序&lt;/li&gt;
&lt;li&gt;字节流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;协议状态必须长期维护：
&lt;ul&gt;
&lt;li&gt;状态机&lt;/li&gt;
&lt;li&gt;缓冲区&lt;/li&gt;
&lt;li&gt;拥塞控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;结果：
&lt;ul&gt;
&lt;li&gt;状态进入操作系统内核&lt;/li&gt;
&lt;li&gt;通信关系成为内核对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="五socket-的诞生进程访问内核协议栈的统一接口"&gt;五、Socket 的诞生：进程访问内核协议栈的统一接口&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;BSD Unix 引入 socket API&lt;/li&gt;
&lt;li&gt;设计目标：
&lt;ul&gt;
&lt;li&gt;用 fd 表示通信端点&lt;/li&gt;
&lt;li&gt;统一 TCP / UDP / 本地域通信&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;本质：
&lt;ul&gt;
&lt;li&gt;socket = 协议状态 + 缓冲区 + 控制逻辑 的内核对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="一句话总结"&gt;一句话总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TCP 之前：&lt;br&gt;
→ 要么无连接无可靠性（只发包）&lt;br&gt;
→ 要么可靠性由应用自己实现&lt;/p&gt;</description></item><item><title>DexMachina and Deus ex machina</title><link>https://analyst-huang.github.io/posts/%E6%9D%82%E8%B0%88/dexmachina/</link><pubDate>Thu, 08 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E6%9D%82%E8%B0%88/dexmachina/</guid><description>&lt;p&gt;在Google Scholar搜索DexMachina的时候，发现好几篇署名缩写是“Dex Machina”的文章，各种语言的都有，所以发现了一个有趣的关于 &lt;em&gt;Deus Ex Machina&lt;/em&gt;的知识。&lt;/p&gt;
&lt;p&gt;(generated by chatgpt)&lt;/p&gt;
&lt;h1 id="deus-ex-machina-作为署名与修辞一则19世纪期刊中的机械音乐评论"&gt;Deus Ex Machina 作为署名与修辞：一则19世纪期刊中的机械音乐评论&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;起点：在一篇 19 世纪音乐期刊短文《Mechanical Music》文末，作者署名为 &lt;strong&gt;“Deus ex machina”&lt;/strong&gt;。这并不是一个人的名字，而是一种极具历史意味的修辞性署名。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="一deus-ex-machina从舞台装置到叙事术语"&gt;一、Deus ex machina：从舞台装置到叙事术语&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Deus ex machina&lt;/strong&gt; 是拉丁语短语，字面意思是“从机器中降下的神”。它来自古希腊戏剧的舞台实践：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当剧情陷入无解困境时，&lt;/li&gt;
&lt;li&gt;通过机械装置（machina）把扮演神的演员吊到舞台上，&lt;/li&gt;
&lt;li&gt;由“神”直接裁决冲突、给出结局。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从亚里士多德开始，这种做法就被视为一种&lt;strong&gt;叙事上的取巧手段&lt;/strong&gt;：不是从情节内在因果推出结局，而是引入外在权威强行收束。&lt;/p&gt;
&lt;p&gt;因此在现代叙事学中，&lt;em&gt;deus ex machina&lt;/em&gt; 通常带有负面或讽刺意味：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指突兀的外力解决方案&lt;/li&gt;
&lt;li&gt;指不由人物行动或情节逻辑自然导出的结局&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="二为什么会被用作署名"&gt;二、为什么会被用作“署名”&lt;/h2&gt;
&lt;p&gt;在 19 世纪期刊文化中，尤其是评论、随笔、短评栏目里，&lt;strong&gt;使用假名、拉丁短语或概念性署名非常常见&lt;/strong&gt;。目的通常不是隐藏身份，而是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;标记文本体裁&lt;/strong&gt;：提示读者这是观点性、讽刺性或机智短评&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;制造修辞效果&lt;/strong&gt;：署名本身就是文章的一部分&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;弱化作者个体性&lt;/strong&gt;：强调观点而非作者权威&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;常见的类似署名包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拉丁格言&lt;/li&gt;
&lt;li&gt;神话人物&lt;/li&gt;
&lt;li&gt;抽象概念（如 Truth, Observer, Spectator 等）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这种传统下，“Deus ex machina”更像是一个&lt;strong&gt;带立场的栏目签名&lt;/strong&gt;，而非真实作者。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="三与mechanical-music的语义互文"&gt;三、与“Mechanical Music”的语义互文&lt;/h2&gt;
&lt;p&gt;在讨论**机械音乐（Mechanical Music）**时使用“Deus ex machina”署名，本身构成了一层明显的语义叠加：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;machina&lt;/em&gt; 同时指舞台机械装置&lt;/li&gt;
&lt;li&gt;也指工业时代的物理机器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这使得署名产生双重讽刺效果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一方面指向戏剧中“靠机器把神吊下来解决问题”的老套路&lt;/li&gt;
&lt;li&gt;另一方面暗示现代社会中“靠机器解决艺术与情感问题”的幻想&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 19 世纪末期，自动演奏装置（音乐盒、自动钢琴、风琴机械系统等）迅速普及，评论界普遍存在以下张力：&lt;/p&gt;</description></item><item><title>Diffusion</title><link>https://analyst-huang.github.io/posts/ai/diffusion/</link><pubDate>Thu, 08 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/ai/diffusion/</guid><description>&lt;p&gt;t步加噪可以写成如下形式：&lt;/p&gt;
&lt;span class="math" style="display: block; text-align: center;"&gt;
$x_t = \sqrt{\bar{\alpha}_t}\, x_0 + \sqrt{1 - \bar{\alpha}_t}\, \varepsilon,\quad \varepsilon \sim \mathcal{N}(0, I)$
&lt;/span&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;span class="math" style="display: block; text-align: center;"&gt;
$\alpha_t = 1 - \beta_t,\quad \bar{\alpha}_t = \prod_{s=1}^{t} \alpha_s, \alpha_t \in [0,1] $
&lt;/span&gt;
&lt;h2 id="二严格推导用贝叶斯公式forward-后验"&gt;二、严格推导：用贝叶斯公式（forward 后验）&lt;/h2&gt;
&lt;h3 id="1-概率图结构与贝叶斯展开"&gt;1) 概率图结构与贝叶斯展开&lt;/h3&gt;
&lt;p&gt;从概率图（forward 链）：
&lt;span class="math" style="display: block; text-align: center;"&gt;
$
x_0 \rightarrow x_{t-1} \rightarrow x_t
$
&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;由贝叶斯公式：
&lt;span class="math" style="display: block; text-align: center;"&gt;
$
q(x_{t-1}\mid x_t, x_0)
=
\frac{q(x_t\mid x_{t-1}, x_0)\,q(x_{t-1}\mid x_0)}{q(x_t\mid x_0)}.
$
&lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;由于 forward 过程的马尔可夫性：
&lt;span class="math" style="display: block; text-align: center;"&gt;
$
q(x_t\mid x_{t-1}, x_0)=q(x_t\mid x_{t-1}),
$
&lt;/span&gt;
因此：
&lt;span class="math" style="display: block; text-align: center;"&gt;
$
q(x_{t-1}\mid x_t, x_0)
=
\frac{q(x_t\mid x_{t-1})\,q(x_{t-1}\mid x_0)}{q(x_t\mid x_0)}.
$
&lt;/span&gt;
&lt;/p&gt;</description></item><item><title>uv</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/uv/</link><pubDate>Thu, 08 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/uv/</guid><description>&lt;p&gt;最近又在配一个环境，所以想到了之前被同事推荐过的&lt;em&gt;uv&lt;/em&gt;。因为发现在conda环境中也可以用，而且比pip快很多，所以记录一下&lt;em&gt;uv&lt;/em&gt;的用法。&lt;/p&gt;
&lt;p&gt;看了一下，发现和科研需求并没有那么重合，记录一下和GPT的几个问题：&lt;/p&gt;
&lt;h1 id="conda-vs-uv科研工作流下依赖管理的真实差异qa"&gt;Conda vs uv：科研工作流下依赖管理的真实差异（Q&amp;amp;A）&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;面向读者：长期使用 conda + pip 的科研/工程混合用户（如深度学习、机器人、CUDA 相关项目），在接触 uv / poetry 等“项目化依赖管理工具”时感到困惑的人。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="q1我一直用-conda-建环境--pip--conda-install-装包这样有什么问题吗"&gt;Q1：我一直用 conda 建环境 + pip / conda install 装包，这样有什么问题吗？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;A：没有问题，而且这是科研圈的主流做法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你的典型流程是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;conda create -n xxx python=3.10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;conda activate xxx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pip install ...&lt;/code&gt; 或 &lt;code&gt;conda install ...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;稳定后：&lt;code&gt;conda env export &amp;gt; env.yaml&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个流程的特点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;环境层面高度可控&lt;/li&gt;
&lt;li&gt;CUDA / PyTorch / 编译依赖更容易处理&lt;/li&gt;
&lt;li&gt;适合频繁试错和快速实验&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在深度学习与机器人领域，这种方式依然是现实最优解之一。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="q2那-uv-到底在解决什么问题为什么工程界很推它"&gt;Q2：那 uv 到底在解决什么问题？为什么工程界很推它？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;A：uv 的核心目标不是“更好地装包”，而是“让项目自带可复现环境定义”。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;uv 想解决的是这些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clone 一个 repo 后，一条命令就能得到一致环境&lt;/li&gt;
&lt;li&gt;CI / 多人协作环境一致&lt;/li&gt;
&lt;li&gt;依赖升级过程可审计、可回滚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此它强调：&lt;/p&gt;</description></item><item><title>Codex</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/codex/</link><pubDate>Wed, 07 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/codex/</guid><description>&lt;p&gt;由于最近发现Codex非常好用，并且众多业界大牛一起指出Vibe Coding是未来的趋势，所以系统学习一下Codex。或许人类真的已经来到了理解&lt;em&gt;复杂系统&lt;/em&gt;的时候了。&lt;/p&gt;
&lt;p&gt;感觉总体来说使用方法是相当自然的，唯一需要注意的是最近新增加的&lt;em&gt;skill&lt;/em&gt;功能。原来是anthropic提出的标准，现在被大量采纳，估计会是一个会持续很多年的标准，值得学习。&lt;/p&gt;
&lt;h1 id="agent-skills-基本格式"&gt;Agent Skills 基本格式&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;官网与完整规范：https://agentskills.io/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="1-目录结构"&gt;1) 目录结构&lt;/h2&gt;
&lt;p&gt;一个 Skill 就是一个文件夹，至少包含一个 &lt;code&gt;SKILL.md&lt;/code&gt;：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;
skill-name/
└── SKILL.md
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可选：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;scripts/&lt;/code&gt;：可执行脚本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;references/&lt;/code&gt;：参考文档&lt;/li&gt;
&lt;li&gt;&lt;code&gt;assets/&lt;/code&gt;：模板或资源&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-skillmd-格式"&gt;2) SKILL.md 格式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SKILL.md&lt;/code&gt; 分为两部分：&lt;/p&gt;
&lt;h3 id="a-yaml-frontmatter必需"&gt;(A) YAML Frontmatter（必需）&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-yaml" data-lang="yaml"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;name&lt;/span&gt;: &lt;span style="color:#ae81ff"&gt;skill-name&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#f92672"&gt;description&lt;/span&gt;: &lt;span style="color:#ae81ff"&gt;该技能做什么，以及在什么情况下使用&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;约束：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt; 必须与文件夹名一致&lt;/li&gt;
&lt;li&gt;仅允许小写字母、数字、连字符 &lt;code&gt;-&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;1–64 字符，不能以 &lt;code&gt;-&lt;/code&gt; 开头或结尾，不能有连续 &lt;code&gt;--&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;description&lt;/code&gt; 为 1–1024 字符&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="b-markdown-正文指令内容"&gt;(B) Markdown 正文（指令内容）&lt;/h3&gt;
&lt;p&gt;Frontmatter 之后是普通 Markdown，用来写操作步骤、示例、注意事项等，结构不强制。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="3-最小示例"&gt;3) 最小示例&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-md" data-lang="md"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;name: pdf-processing
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;description: 提取 PDF 文本与表格，用于后续分析或填表。
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;# PDF Processing
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;## When to use
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;当用户需要处理 PDF 文件时。
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#75715e"&gt;## Procedure
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;1.&lt;/span&gt; 读取 PDF
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;2.&lt;/span&gt; 提取文本与表格
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#66d9ef"&gt;3.&lt;/span&gt; 输出结构化结果
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;这就是 Agent Skill 的基本格式。更多细节见官网：&lt;a href="https://agentskills.io/"&gt;https://agentskills.io/&lt;/a&gt;&lt;/p&gt;</description></item><item><title>PPO调参手册</title><link>https://analyst-huang.github.io/posts/ai/ppo%E8%B0%83%E5%8F%82%E6%89%8B%E5%86%8C/</link><pubDate>Sat, 03 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/ai/ppo%E8%B0%83%E5%8F%82%E6%89%8B%E5%86%8C/</guid><description>&lt;ul&gt;
&lt;li&gt;网络的大小对训练和收敛的速度有极大的影响
&lt;ul&gt;
&lt;li&gt;很多时候[256, 256]就已经足够&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>ELBO：证据、隐变量与变分下界的统一视角</title><link>https://analyst-huang.github.io/posts/ai/elbo/</link><pubDate>Fri, 02 Jan 2026 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/ai/elbo/</guid><description>&lt;h1 id="elbo证据隐变量与变分下界的统一视角"&gt;ELBO：证据、隐变量与变分下界的统一视角&lt;/h1&gt;
&lt;p&gt;本文给出一个可重复推导、可迁移到多种 AI 场景（VAE、世界模型、序列潜变量模型、变分推断等）的 ELBO（Evidence Lower Bound）理解框架。核心主线是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;训练目标始终是最大化 &lt;strong&gt;证据&lt;/strong&gt;（边缘似然）。&lt;/li&gt;
&lt;li&gt;隐变量不是深度学习才有的“工程拆解”，而是统计建模与推断的长期核心工具；ELBO 则是经典“下界化 + 可优化”范式的现代实现。&lt;/li&gt;
&lt;li&gt;ELBO 中显式出现的先验 KL 与“逼近真实后验”的 KL 并不矛盾：前者是目标函数的结构项，后者是 ELBO 与证据之间的缺口（gap）。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="1-证据到底是什么"&gt;1. “证据”到底是什么&lt;/h2&gt;
&lt;p&gt;给定观测数据 $x$ 与生成模型参数 $\theta$，所谓 **证据（evidence）**是数据在模型下出现的概率：
$p_\theta(x)$&lt;/p&gt;
&lt;p&gt;它也常被称为 &lt;strong&gt;边缘似然（marginal likelihood）&lt;/strong&gt;、&lt;strong&gt;模型证据（model evidence）&lt;/strong&gt;。当模型含潜变量 $z$ 时，证据是对潜变量积分（或求和）后的量：&lt;/p&gt;
&lt;span class="math" style="display: block; text-align: center;"&gt;
$p_\theta(x)=\int p_\theta(x,z)\,dz$
&lt;/span&gt;
&lt;p&gt;如果进一步将联合分布写成“先验 + 条件似然”的形式：&lt;/p&gt;
&lt;span class="math" style="display: block; text-align: center;"&gt;
$p_\theta(x,z)=p_\theta(x\mid z)\,p(z)$
&lt;/span&gt;
&lt;p&gt;则证据变为：&lt;/p&gt;
&lt;span class="math" style="display: block; text-align: center;"&gt;
$p_\theta(x)=\int p_\theta(x\mid z)\,p(z)\,dz$
&lt;/span&gt;
&lt;p&gt;这句话的统计含义非常直接：&lt;strong&gt;模型整体（在不知道真实潜变量的情况下）生成 $x$ 的能力&lt;/strong&gt;。在贝叶斯公式中，它是后验归一化因子：&lt;/p&gt;
&lt;span class="math" style="display: block; text-align: center;"&gt;
$p_\theta(z\mid x)=\frac{p_\theta(x\mid z)p(z)}{p_\theta(x)}$
&lt;/span&gt;
&lt;p&gt;因此，“证据”并不是某个特定解释 $z^*$ 的质量，而是&lt;strong&gt;所有可能解释对 $x$ 的总体支持度&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="2-隐变量在统计中的地位不是工程权宜而是核心范式"&gt;2. 隐变量在统计中的地位：不是工程权宜，而是核心范式&lt;/h2&gt;
&lt;p&gt;隐变量（latent variables）在统计中长期处于中心位置，原因主要有两类：&lt;/p&gt;</description></item><item><title>PPO：策略梯度、重要性采样与 Clip</title><link>https://analyst-huang.github.io/posts/ai/ppo/</link><pubDate>Wed, 31 Dec 2025 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/ai/ppo/</guid><description>&lt;hr&gt;
&lt;h1 id="ppo-中的策略梯度重要性采样与概率密度比"&gt;PPO 中的策略梯度、重要性采样与概率密度比&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;从策略梯度定理出发，经由重要性采样与“对梯度的不定积分”，理解 PPO 的 surrogate objective 与 Clip 机制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="1-策略梯度定理起点而不是终点"&gt;1. 策略梯度定理：起点而不是终点&lt;/h2&gt;
&lt;p&gt;策略梯度定理给出的是&lt;strong&gt;梯度形式&lt;/strong&gt;，而不是一个可直接优化的损失函数：&lt;/p&gt;
&lt;span class="math" style="display: block; text-align: center;"&gt;
$$
\nabla_\theta J(\theta)
= \mathbb E_{\pi_\theta}
\big[
\nabla_\theta \log \pi_\theta(a_t\mid s_t), A^\pi(s_t,a_t)
\big].
$$
&lt;/span&gt;
&lt;p&gt;这一定理说明了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;梯度方向由 $ \nabla_\theta \log \pi $决定；&lt;/li&gt;
&lt;li&gt;学习信号由优势函数 $A$ 提供；&lt;/li&gt;
&lt;li&gt;它本质上是 &lt;strong&gt;on-policy&lt;/strong&gt; 的结论。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但工程上我们并不是直接“写梯度”，而是希望：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;构造一个目标函数 $L(\theta)$，使其梯度自动给出合理的策略更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这正是 PPO / TRPO 所做的事情。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="2-从-on-policy-到-off-policy重要性采样的引入"&gt;2. 从 on-policy 到 off-policy：重要性采样的引入&lt;/h2&gt;
&lt;p&gt;在实践中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rollout 使用的是旧策略 $ \pi_{\text{old}} $；&lt;/li&gt;
&lt;li&gt;更新时参数已经变为 $ \pi_\theta $。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是需要通过重要性采样来修正期望的测度：&lt;/p&gt;
&lt;span class="math" style="display: block; text-align: center;"&gt;
$$
\mathbb E_{\pi_\theta}[f(s,a)]
=
\mathbb E_{\pi_{\text{old}}}
\left[
\frac{\pi_\theta(a\mid s)}{\pi_{\text{old}}(a\mid s)}
f(s,a)
\right].
$$
&lt;/span&gt;
&lt;p&gt;定义&lt;strong&gt;重要性采样率（概率比 / 密度比）&lt;/strong&gt;：&lt;/p&gt;</description></item><item><title>分析哲学与小说结构</title><link>https://analyst-huang.github.io/posts/%E6%9D%82%E8%B0%88/%E5%88%86%E6%9E%90%E5%93%B2%E5%AD%A6-%E5%B0%8F%E8%AF%B4%E7%BB%93%E6%9E%84/</link><pubDate>Tue, 30 Dec 2025 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E6%9D%82%E8%B0%88/%E5%88%86%E6%9E%90%E5%93%B2%E5%AD%A6-%E5%B0%8F%E8%AF%B4%E7%BB%93%E6%9E%84/</guid><description>&lt;p&gt;最近复习完分析哲学的期末考试，虽然从结构主义视角下看这些理论都有些意识形态偏见和过分的与现实脱节，但是在言语层面的复杂结构正好可以用来作为叙事的骨架，甚至是肌肉。一个理论，在其失败之处，或是在其成功之处，如果不是因为其符号系统内部矛盾而发生的解离，那么一定是因为实在界的入侵而解离了。实在界的入侵，正是人物的、剧情的矛盾所在。我们都是在大他者所规定的世界里活着，时有运行不畅之处，那正是小说发生的地方。而尝试将大他者说清楚到底是什么，问题在哪里，这是分析哲学可以提供的东西。分析哲学基于资本主义伦理观/后科学时代自然观，尝试分析出话语的边界，虽然说它不可能触及被蓄意遮蔽的东西，但是能触及的那些概念，像自由意志、心灵等等，已经可以构成小说的一部分结构了。我们接下来对关于“自由意志”的法兰克福案例进行分析。&lt;/p&gt;
&lt;h2 id="harry-frankfurt-案例的叙事核心"&gt;Harry Frankfurt 案例的叙事核心&lt;/h2&gt;
&lt;p&gt;在小说/叙事层面，法兰克福案例的真正贡献不是：否认自由意志，证明决定论，玩反事实逻辑游戏，而是这一点：即使主体在行动中具有自由意志，自由意志也不再是伦理与世界反应的决定性变量。这是对法兰克福案例的一个倒置，因为其原来用于说明自由意志的要求没有那么高，即不要求本可以不这么做。我们必须将其倒置，因为小说的关键成分就在于一个被认为有自由意志的主体，否则角色的挣扎、关系的变换都将失去张力。换句话说：自由意志仍然存在（主体内部），但它失去了“让世界必须回应它”的权力，这是一个典型的悲剧内核。&lt;/p&gt;
&lt;h2 id="小说母题"&gt;小说母题&lt;/h2&gt;
&lt;p&gt;我们最终沉淀出的母题可以表述为：&lt;/p&gt;
&lt;p&gt;主体在真实地行动、判断、付出努力，
并不断制造“我影响了世界”的因果幻象；
但世界运行在另一套评价与决策维度中，
自由意志与努力既不被否定，也不被采用。&lt;/p&gt;
&lt;p&gt;一句更锋利的版本是：&lt;/p&gt;
&lt;p&gt;自由意志存在，但与世界毫无关系。&lt;/p&gt;
&lt;p&gt;不是被压制、被否认、被证明为假，
而是被正确理解、却被绕开。&lt;/p&gt;
&lt;h2 id="更多的分析哲学理论的叙事化改造"&gt;更多的分析哲学理论的叙事化改造&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;模态实在论：可能世界的模态实在论观点作为科幻小说的底层架构支持上层叙事&lt;/li&gt;
&lt;li&gt;盖梯尔案例：以JTB的形式作为主角的动机结构，但是后面会让这个“知道”变成不知道，达成叙事张力&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>策略梯度定理</title><link>https://analyst-huang.github.io/posts/ai/%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6%E5%AE%9A%E7%90%86/</link><pubDate>Tue, 30 Dec 2025 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/ai/%E7%AD%96%E7%95%A5%E6%A2%AF%E5%BA%A6%E5%AE%9A%E7%90%86/</guid><description>&lt;h1 id="策略梯度从-reinforce-到策略梯度定理含详细证明"&gt;策略梯度：从 REINFORCE 到策略梯度定理（含详细证明）&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;本文目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用统一符号说明策略梯度家族的“同一梯度、两种坐标系”本质；&lt;/li&gt;
&lt;li&gt;给出 REINFORCE（Williams, 1992）的 &lt;strong&gt;score-function / likelihood-ratio&lt;/strong&gt; 推导；&lt;/li&gt;
&lt;li&gt;给出 Sutton et al.（1999）式 &lt;strong&gt;策略梯度定理（Policy Gradient Theorem）&lt;/strong&gt; 的 Bellman/占用测度推导；&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="0-记号与设定"&gt;0. 记号与设定&lt;/h2&gt;
&lt;p&gt;我们考虑离散时间、可数（或有限）状态动作的折扣 MDP：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态：$s\in\mathcal S$&lt;/li&gt;
&lt;li&gt;动作：$a\in\mathcal A$&lt;/li&gt;
&lt;li&gt;转移：$P(s&amp;rsquo;\mid s,a)$&lt;/li&gt;
&lt;li&gt;即时奖励：$r(s,a)$（或 $r_t$）&lt;/li&gt;
&lt;li&gt;折扣：$\gamma\in(0,1)$&lt;/li&gt;
&lt;li&gt;初始状态分布：$\mu(s)=\Pr(s_0=s)$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;随机策略以参数 $\theta$ 参数化：$\pi_\theta(a\mid s)$。&lt;/p&gt;
&lt;p&gt;定义折扣回报（episode 有限长度 $T$ 或无穷长度均可；下文为便于书写采用有限 $T$，无穷时取极限）：&lt;/p&gt;
&lt;p&gt;$$
R(\tau):=\sum_{t=0}^{T}\gamma^t r_{t+1}.
$$&lt;/p&gt;
&lt;p&gt;目标函数（期望折扣回报）：&lt;/p&gt;
&lt;p&gt;$$
J(\theta)=\mathbb E_{\tau\sim p_\theta}[R(\tau)].
$$&lt;/p&gt;
&lt;p&gt;其中轨迹 $\tau$ 表示
$
\tau=(s_0,a_0,r_1,s_1,a_1,r_2,\ldots,s_T,a_T,r_{T+1})
$
，轨迹分布为&lt;/p&gt;
&lt;p&gt;$$
p_\theta(\tau)=\mu(s_0)\prod_{t=0}^{T}\pi_\theta(a_t\mid s_t),P(s_{t+1}\mid s_t,a_t).
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关键点：环境动力学 $P$ 与初始分布 $\mu$ 不依赖 $\theta$。$\theta$ 只通过策略 $\pi_\theta$ 进入。&lt;/p&gt;</description></item><item><title>认识论（怀疑论）</title><link>https://analyst-huang.github.io/posts/2025%E7%A7%8B%E5%A4%96%E5%93%B2%E6%89%80%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A4%E8%AF%86%E8%AE%BA3/</link><pubDate>Fri, 26 Dec 2025 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/2025%E7%A7%8B%E5%A4%96%E5%93%B2%E6%89%80%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A4%E8%AF%86%E8%AE%BA3/</guid><description>&lt;h1 id="认识论--怀疑论epistemology-skepticism"&gt;认识论 · 怀疑论（Epistemology: Skepticism）&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;课程：Introduction to Philosophy&lt;br&gt;
主题：Epistemology – Skepticism&lt;br&gt;
讲义来源：北大 Bin Zhao 教授课程讲义 :contentReference[oaicite:0]{index=0}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="一什么是怀疑论skepticism"&gt;一、什么是怀疑论（Skepticism）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;基本主张&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;怀疑论者主张：
&lt;blockquote&gt;
&lt;p&gt;我们并不知道（或没有正当理由相信）许多我们平常以为自己知道的事情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="1-怀疑论主张的两个维度"&gt;1. 怀疑论主张的两个维度&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;力度（Force）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;否认的认识地位类型：
&lt;ul&gt;
&lt;li&gt;知识（knowledge）&lt;/li&gt;
&lt;li&gt;正当信念（justified belief）&lt;/li&gt;
&lt;li&gt;证据（evidence）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;范围（Scope）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被怀疑的信念类型：
&lt;ul&gt;
&lt;li&gt;外部世界信念&lt;/li&gt;
&lt;li&gt;关于未来的信念&lt;/li&gt;
&lt;li&gt;关于未观察事物的信念&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;⚠️ &lt;strong&gt;重要澄清&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;怀疑论者并不声称这些信念是假的&lt;/li&gt;
&lt;li&gt;只是否认：我们“知道”它们&lt;/li&gt;
&lt;li&gt;例如：无神论者并不是（相关意义上的）怀疑论者&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="二三种经典怀疑论论证"&gt;二、三种经典怀疑论论证&lt;/h2&gt;
&lt;h3 id="一错误可能性论证"&gt;（一）错误可能性论证&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;The Possibility of Error Argument&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;几乎所有关于外部世界的信念，都&lt;strong&gt;可能是错误的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果你对 p 的信念可能是错误的，那么你就不知道 p&lt;/li&gt;
&lt;li&gt;所以：你几乎不知道任何关于外部世界的事情&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id="二确定性论证"&gt;（二）确定性论证&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;The Certainty Argument&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果你知道 p，那么你必须对 p &lt;strong&gt;绝对确定&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;你对任何外部世界命题都不是绝对确定的&lt;/li&gt;
&lt;li&gt;所以：你不知道任何关于外部世界的事情&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;区分&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;心理确定性（psychological certainty）&lt;/li&gt;
&lt;li&gt;认识论确定性（epistemic certainty）：拥有最强理由&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="三传递性论证"&gt;（三）传递性论证&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;The Transmissibility Argument&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设定：&lt;/p&gt;</description></item><item><title>认识论（知识分析）</title><link>https://analyst-huang.github.io/posts/2025%E7%A7%8B%E5%A4%96%E5%93%B2%E6%89%80%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A4%E8%AF%86%E8%AE%BA1/</link><pubDate>Fri, 26 Dec 2025 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/2025%E7%A7%8B%E5%A4%96%E5%93%B2%E6%89%80%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A4%E8%AF%86%E8%AE%BA1/</guid><description>&lt;h1 id="epistemologythe-analysis-of-knowledge"&gt;Epistemology：The Analysis of Knowledge&lt;/h1&gt;
&lt;p&gt;（知识论：知识的分析）复习笔记&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="一什么是知识论epistemology"&gt;一、什么是知识论（Epistemology）&lt;/h2&gt;
&lt;p&gt;知识论研究以下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是知识（knowledge）&lt;/li&gt;
&lt;li&gt;什么是辩护/证成（justification）&lt;/li&gt;
&lt;li&gt;什么是证据（evidence）&lt;/li&gt;
&lt;li&gt;我们何时有理由相信某事&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="命题知识propositional-knowledge"&gt;命题知识（Propositional Knowledge）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;表达形式：S knows that p&lt;/li&gt;
&lt;li&gt;p 是命题（proposition）&lt;/li&gt;
&lt;li&gt;命题可真可假&lt;/li&gt;
&lt;li&gt;为真的命题对应事实（facts）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="二分析analysis与反例counterexample"&gt;二、分析（Analysis）与反例（Counterexample）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;分析 X&lt;/strong&gt;：试图给出 X 的精确定义&lt;br&gt;
例：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Mother = a woman who has given birth&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;反例&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有 X 但不满足定义&lt;/li&gt;
&lt;li&gt;或满足定义但不是 X&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;三种回应策略&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修改被分析项（X）&lt;/li&gt;
&lt;li&gt;修改分析条件&lt;/li&gt;
&lt;li&gt;否认反例直觉&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="三jtb-分析justified-true-belief"&gt;三、JTB 分析（Justified True Belief）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;JTB：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;S 知道 p&lt;br&gt;
iff&lt;br&gt;
(1) p 为真&lt;br&gt;
(2) S 相信 p&lt;br&gt;
(3) S 对 p 的信念是有辩护的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="支持理由"&gt;支持理由&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;不可能“知道假命题”&lt;/li&gt;
&lt;li&gt;不可能“知道却不相信”&lt;/li&gt;
&lt;li&gt;猜对 ≠ 知识&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="四gettier-案例对-jtb-的反例"&gt;四、Gettier 案例（对 JTB 的反例）&lt;/h2&gt;
&lt;h3 id="gettier-的基本结构"&gt;Gettier 的基本结构&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;主体有一个&lt;strong&gt;通常会导致假信念&lt;/strong&gt;的证成&lt;/li&gt;
&lt;li&gt;该信念&lt;strong&gt;由于无关的巧合而为真&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="经典案例"&gt;经典案例&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;十枚硬币案例&lt;/li&gt;
&lt;li&gt;Ford / Barcelona 案例&lt;/li&gt;
&lt;li&gt;田野里的羊&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;：&lt;/p&gt;</description></item><item><title>认识论（认识辩护）</title><link>https://analyst-huang.github.io/posts/2025%E7%A7%8B%E5%A4%96%E5%93%B2%E6%89%80%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A4%E8%AF%86%E8%AE%BA2/</link><pubDate>Fri, 26 Dec 2025 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/2025%E7%A7%8B%E5%A4%96%E5%93%B2%E6%89%80%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A4%E8%AF%86%E8%AE%BA2/</guid><description>&lt;h1 id="epistemology-epistemic-justification认识辩护复习笔记"&gt;Epistemology: Epistemic Justification（认识辩护）复习笔记&lt;/h1&gt;
&lt;hr&gt;
&lt;h2 id="一jtb-框架与认识后退问题epistemic-regress-problem"&gt;一、JTB 框架与认识后退问题（Epistemic Regress Problem）&lt;/h2&gt;
&lt;h3 id="1-jtb-分析"&gt;1. JTB+ 分析&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;S 知道 p&lt;br&gt;
= S 对 p 有 &lt;strong&gt;被正当化的真信念&lt;/strong&gt;（Justified True Belief）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;满足某个额外条件（用于排除 Gettier 案例）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Truth（真）&lt;/strong&gt;：世界条件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Belief（信）&lt;/strong&gt;：心理态度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Justification（正当性）&lt;/strong&gt;：认识论规范地位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三者&lt;strong&gt;概念上可区分&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="2-认识后退问题"&gt;2. 认识后退问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;我们希望信念有理由&lt;/li&gt;
&lt;li&gt;理由本身又需要理由&lt;/li&gt;
&lt;li&gt;→ 正当性链条如何停止 / 组织？&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="二四种对后退问题的回应"&gt;二、四种对后退问题的回应&lt;/h2&gt;
&lt;h3 id="1-infinitism无限主义"&gt;1. Infinitism（无限主义）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;正当化理由链 &lt;strong&gt;无限、不重复&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;无终点，也无循环&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="1起源未解释反对"&gt;（1）起源未解释反对&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;反对：无限链无“正当性起源”&lt;/li&gt;
&lt;li&gt;回应：
&lt;ul&gt;
&lt;li&gt;预设了“推理只能传递、不能生成正当性”&lt;/li&gt;
&lt;li&gt;无限制推理本身可以生成正当性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="2有限心智反对"&gt;（2）有限心智反对&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;人类无法实际拥有无限理由&lt;/li&gt;
&lt;li&gt;回应：
&lt;ul&gt;
&lt;li&gt;区分三类信念：
&lt;ul&gt;
&lt;li&gt;Occurrent beliefs（现实信念）&lt;/li&gt;
&lt;li&gt;First-order dispositional beliefs（一阶倾向性信念）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Second-order dispositional beliefs（二阶倾向性信念）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;无限性是 &lt;strong&gt;原则上可延展&lt;/strong&gt;，非心理上实际占有&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="2-coherentism连贯主义"&gt;2. Coherentism（连贯主义）&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;信念正当&lt;br&gt;
⇔ 它属于一个高度连贯的信念系统&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;连贯性 ≠ 仅逻辑一致&lt;br&gt;
而是：&lt;/p&gt;</description></item><item><title>元伦理学</title><link>https://analyst-huang.github.io/posts/2025%E7%A7%8B%E5%A4%96%E5%93%B2%E6%89%80%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%83%E4%BC%A6%E7%90%86%E5%AD%A6/</link><pubDate>Thu, 25 Dec 2025 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/2025%E7%A7%8B%E5%A4%96%E5%93%B2%E6%89%80%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%83%E4%BC%A6%E7%90%86%E5%AD%A6/</guid><description>&lt;h1 id="元伦理学meta-ethics复习整理"&gt;元伦理学（Meta-Ethics）复习整理&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;主题线索：&lt;strong&gt;语义（谓词/概念）—形而上学（属性）—动机—推理—规范性&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="一基础区分谓词--概念-vs-属性"&gt;一、基础区分：谓词 / 概念 vs 属性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;谓词 / 概念（predicate / concept）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;属于语言与意义层面&lt;/li&gt;
&lt;li&gt;决定语句在语义上&lt;strong&gt;要求世界必须是什么样&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;例如：“是对的”“是好的”“有理由”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;属性（property）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;属于世界的形而上学层面&lt;/li&gt;
&lt;li&gt;决定世界中&lt;strong&gt;实际上有什么&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;关键点：&lt;br&gt;
语句可以是&lt;strong&gt;有意义的&lt;/strong&gt;，但世界中&lt;strong&gt;并不存在&lt;/strong&gt;与之对应的属性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="二moore开放问题论证两种重构与评估"&gt;二、Moore：开放问题论证（两种重构与评估）&lt;/h2&gt;
&lt;h3 id="一第一种重构从开放性到非同一性"&gt;（一）第一种重构：从“开放性”到“非同一性”&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;论证结构&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;（归谬假设）F 就是好（F = good）。&lt;/li&gt;
&lt;li&gt;若（属性）A 就是（属性）B，则问题“&lt;strong&gt;A 是 B 吗？&lt;/strong&gt;”应当是&lt;strong&gt;封闭的&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;若 F = good，则问题“&lt;strong&gt;F 是好的吗？&lt;/strong&gt;”应当是封闭的。（由 1,2）&lt;/li&gt;
&lt;li&gt;但事实上，问题“&lt;strong&gt;F 是好的吗？&lt;/strong&gt;”总是开放的。&lt;/li&gt;
&lt;li&gt;因此，F ≠ good。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;思考：该论证可靠吗？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键问题在于 &lt;strong&gt;第 2 步是否成立&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;该前提把&lt;strong&gt;属性同一&lt;/strong&gt;与&lt;strong&gt;概念同义&lt;/strong&gt;混为一谈：
&lt;ul&gt;
&lt;li&gt;“问题是否封闭”只反映&lt;strong&gt;概念/谓词层面&lt;/strong&gt;的同义性；&lt;/li&gt;
&lt;li&gt;但属性同一可以是&lt;strong&gt;后验的、非分析的&lt;/strong&gt;（如“水 = H₂O”）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;因而：
&lt;ul&gt;
&lt;li&gt;该论证&lt;strong&gt;最多&lt;/strong&gt;说明：
&lt;blockquote&gt;
&lt;p&gt;“F”这一概念 ≠ “好”这一概念&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;但&lt;strong&gt;不能推出&lt;/strong&gt;：
&lt;blockquote&gt;
&lt;p&gt;F 所指称的属性 ≠ good 所指称的属性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该论证&lt;strong&gt;不可靠&lt;/strong&gt;：它从“概念不可还原”非法推出“属性非同一”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id="二第二种重构信念差异--莱布尼兹律"&gt;（二）第二种重构：信念差异 + 莱布尼兹律&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;论证结构&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>可能性和可能世界</title><link>https://analyst-huang.github.io/posts/2025%E7%A7%8B%E5%A4%96%E5%93%B2%E6%89%80%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8F%AF%E8%83%BD%E6%80%A7%E5%92%8C%E5%8F%AF%E8%83%BD%E4%B8%96%E7%95%8C/</link><pubDate>Thu, 25 Dec 2025 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/2025%E7%A7%8B%E5%A4%96%E5%93%B2%E6%89%80%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%8F%AF%E8%83%BD%E6%80%A7%E5%92%8C%E5%8F%AF%E8%83%BD%E4%B8%96%E7%95%8C/</guid><description>&lt;h2 id="一基本问题框架"&gt;一、基本问题框架&lt;/h2&gt;
&lt;h3 id="1-什么是模态事实"&gt;1. 什么是模态事实？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;必然（necessity）：不可能为假&lt;/li&gt;
&lt;li&gt;可能（possibility）：不必然为假&lt;/li&gt;
&lt;li&gt;偶然（contingency）：真但可能为假&lt;/li&gt;
&lt;li&gt;不可能（impossibility）：不可能为真&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-为什么引入可能世界"&gt;2. 为什么引入“可能世界”？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;为系统刻画：
&lt;ul&gt;
&lt;li&gt;模态逻辑（□ / ◇）（必然/可能）&lt;/li&gt;
&lt;li&gt;反事实条件句&lt;/li&gt;
&lt;li&gt;本质 / 偶然属性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;但：&lt;br&gt;
&lt;strong&gt;“可能世界”究竟是实在的？抽象的？虚构的？还是语言工具？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="二de-dicto--de-re-的区分针对什么谈可能性"&gt;二、de dicto / de re 的区分（“针对什么谈可能性”）&lt;/h2&gt;
&lt;h3 id="1-从言的de-dicto"&gt;1. 从言的（de dicto）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;模态算子作用于&lt;strong&gt;命题整体&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;例：
&lt;ul&gt;
&lt;li&gt;◇∃x(Fx)&lt;/li&gt;
&lt;li&gt;“可能存在一个 F”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="2-从物的de-re"&gt;2. 从物的（de re）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;模态算子作用于&lt;strong&gt;对象的属性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;例：
&lt;ul&gt;
&lt;li&gt;∃x◇(Fx)&lt;/li&gt;
&lt;li&gt;“某个对象可能是 F”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;该区分是理解&lt;strong&gt;本质必然性&lt;/strong&gt;与&lt;strong&gt;对应物理论争议&lt;/strong&gt;的基础。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="三可能世界的三种核心理解"&gt;三、可能世界的三种核心理解&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id="三1-非还原的可能世界观plantinga"&gt;三.1 非还原的可能世界观（Plantinga）&lt;/h2&gt;
&lt;h3 id="核心主张"&gt;核心主张&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;可能世界 = &lt;strong&gt;最大的、可以实现的事物状态&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;“w 蕴含 p”&lt;br&gt;
⇔ &lt;em&gt;w 与 ¬p 不可同时实现&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;“可以实现性（obtainability）”是原初概念&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="特点"&gt;特点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;非还原：因为“可以实现”依旧是一种模态的提法&lt;/li&gt;
&lt;li&gt;强 de re 模态（本质主义友好）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="代价"&gt;代价&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;“可以实现”未被进一步分析&lt;/li&gt;
&lt;li&gt;解释在形而上学层面&lt;strong&gt;止步&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="还原的可能世界观armstrong"&gt;还原的可能世界观（Armstrong）&lt;/h2&gt;
&lt;p&gt;可能世界 = 现实世界的重组（世界、事实、原子事实、个体、共相）&lt;/p&gt;</description></item><item><title>因果性</title><link>https://analyst-huang.github.io/posts/2025%E7%A7%8B%E5%A4%96%E5%93%B2%E6%89%80%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%A0%E6%9E%9C%E6%80%A7/</link><pubDate>Thu, 25 Dec 2025 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/2025%E7%A7%8B%E5%A4%96%E5%93%B2%E6%89%80%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%9B%A0%E6%9E%9C%E6%80%A7/</guid><description>&lt;h1 id="因果性causation复习笔记"&gt;因果性（Causation）复习笔记&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;本笔记系统总结当代因果哲学中的主要理论、核心论证与关键反例，重点对比还原论与反还原论路径，并标出各理论在抢先、过度决定、负面因果等难题上的表现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="一休谟传统规律性理论regularity-theory"&gt;一、休谟传统：规律性理论（Regularity Theory）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;核心思想&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因果性 = 时间先后 + 空间邻近 + 恒常联结（规律性相继）&lt;/li&gt;
&lt;li&gt;排除“必然联系”的形而上学承诺&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;主要问题&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;过于宽松&lt;/strong&gt;：琐屑规律（如“按开关 → 月亮未爆炸”）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;共同原因&lt;/strong&gt;：相关≠因果 (冰激凌销量高，中暑人数增加)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方向性缺失&lt;/strong&gt;：无法解释为何是 A 导致 B&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件类型非中立&lt;/strong&gt;：规律依赖描述粒度与理论背景&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="二mackieinus-条件理论"&gt;二、Mackie：INUS 条件理论&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;INUS 定义&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原因是“不足但不可或缺的部分”，属于“非必要但充分的条件组”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;改进&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;贴合多因素因果&lt;/li&gt;
&lt;li&gt;通过“不可或缺性”削弱琐屑规律&lt;/li&gt;
&lt;li&gt;容纳多重实现与过度决定&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;遗留问题&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;过于宽松&lt;/strong&gt;：条件组可任意拼装&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;背景/原因区分&lt;/strong&gt;需诉诸“因果场（causal field）”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方向性与共同原因&lt;/strong&gt;仍不稳&lt;/li&gt;
&lt;li&gt;本体论上仍接近规律主义&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="三反事实因果论lewis"&gt;三、反事实因果论（Lewis）&lt;/h2&gt;
&lt;h3 id="31-基本语义"&gt;3.1 基本语义&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;反事实：&lt;code&gt;p □→ q&lt;/code&gt; 为真&lt;br&gt;
iff 在&lt;strong&gt;相对于现实世界&lt;/strong&gt;的&lt;strong&gt;最邻近 p 世界&lt;/strong&gt;中，q 为真&lt;/li&gt;
&lt;li&gt;“最邻近”基于整体相似性（保自然定律、最小改动）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="32-版本演进"&gt;3.2 版本演进&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;版本1&lt;/strong&gt;：因果 = 直接反事实依赖&lt;br&gt;
→ 失败于&lt;strong&gt;抢先（preemption）&lt;/strong&gt;：约定先后扔石头&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;版本2&lt;/strong&gt;：因果 = &lt;strong&gt;实际发生的反事实依赖链&lt;/strong&gt;&lt;br&gt;
→ 解决**早抢先*:约定先后扔石头*&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;版本3（影响）&lt;/strong&gt;：因果 = &lt;strong&gt;对结果实现方式的反事实影响&lt;/strong&gt;&lt;br&gt;
→ 解决&lt;strong&gt;晚抢先&lt;/strong&gt;:一起扔石头，有快有慢&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="33-典型难题"&gt;3.3 典型难题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;抢先&lt;/strong&gt;：需区分实际路径&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;过度决定&lt;/strong&gt;：完全对称冗余下，差异消失&lt;br&gt;
→ Lewis：相关直觉不可靠&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负面因果&lt;/strong&gt;：可处理，但依赖“最近世界”选择&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="四概率因果论reichenbach"&gt;四、概率因果论（Reichenbach）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;核心公式&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>应用伦理学</title><link>https://analyst-huang.github.io/posts/2025%E7%A7%8B%E5%A4%96%E5%93%B2%E6%89%80%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BA%94%E7%94%A8%E4%BC%A6%E7%90%86%E5%AD%A6/</link><pubDate>Thu, 25 Dec 2025 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/2025%E7%A7%8B%E5%A4%96%E5%93%B2%E6%89%80%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BA%94%E7%94%A8%E4%BC%A6%E7%90%86%E5%AD%A6/</guid><description>&lt;h1 id="动物的道德地位"&gt;动物的道德地位&lt;/h1&gt;
&lt;h2 id="人类例外论"&gt;人类例外论&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;人类有独特的理性能力&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“我”的表征（康德）&lt;/li&gt;
&lt;li&gt;反思欲望，寻求理由（Christine Korsgaard）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;边缘案例挑战&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;残疾人，植物人，婴儿&amp;hellip;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;物种主义是否如同种族主义？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="承认动物道德低位"&gt;承认动物道德低位&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;感受能力：受苦（suffer）（Bentham）&lt;/li&gt;
&lt;li&gt;多高的道德地位？&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="气候变化"&gt;气候变化&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;maxmin: 让未来的最坏情况最好&lt;/li&gt;
&lt;li&gt;对未来负责？
&lt;ul&gt;
&lt;li&gt;折现的负责&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="非同一性问题"&gt;非同一性问题&lt;/h2&gt;
&lt;h2 id="1-核心问题what-is-the-problem"&gt;1. 核心问题（What is the problem?）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在许多&lt;strong&gt;代际政策&lt;/strong&gt;（气候、能源、资源、公共卫生、生育政策）中：
&lt;ul&gt;
&lt;li&gt;政策会改变未来的经济/技术/人口路径&lt;/li&gt;
&lt;li&gt;进而改变&lt;strong&gt;哪些人将会出生&lt;/strong&gt;（identity dependence）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;困境：我们直觉上认为某些政策&lt;strong&gt;明显更不正当&lt;/strong&gt;，但它们似乎并未让任何“同一的某个人”更糟。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-标准案例结构depletion-vs-conservation"&gt;2. 标准案例结构（Depletion vs Conservation）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;保护（Conservation）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;当代付出一些成本&lt;/li&gt;
&lt;li&gt;未来生活质量更高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;枯竭（Depletion）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;当代更富裕或更便利&lt;/li&gt;
&lt;li&gt;未来生活质量更低&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关键前提：
&lt;ul&gt;
&lt;li&gt;两种政策将导致未来出现&lt;strong&gt;不同的人群&lt;/strong&gt;（并非同一批个体出生）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;因此：
&lt;ul&gt;
&lt;li&gt;枯竭政策下出生的人，并不是“被枯竭政策伤害的同一人”&lt;/li&gt;
&lt;li&gt;因为若改行保护政策，那些人&lt;strong&gt;可能根本不会存在&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="3-三个看似合理但不可兼得的主张the-inconsistent-triad"&gt;3. 三个看似合理但不可兼得的主张（The inconsistent triad）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;强人称原则（Strong person-affecting principle）&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;若一个行为没有使任何人更糟，则它不是道德上错误的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非同一性事实（Identity dependence）&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;许多长期政策改变“谁会出生”，因此没有同一受害者可对比。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;政策错误直觉（Policy wrongness intuition）&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;枯竭政策（或类似政策）仍然是道德上错误/更差的选择。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Parfit 的诊断：三者不能同时为真。代际伦理中必须放弃或修正其中至少一项。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="4-为什么对气候伦理致命why-it-matters-for-climate-ethics"&gt;4. 为什么对气候伦理“致命”（Why it matters for climate ethics）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;排放路径影响长期结构（技术、经济、人口、生育时点）&lt;/li&gt;
&lt;li&gt;因而气候政策高度可能改变未来人的身份构成&lt;/li&gt;
&lt;li&gt;若坚持“必须伤害某个确定的人才算错”：
&lt;ul&gt;
&lt;li&gt;很多长期气候伤害将难以表述为“伤害了同一人”&lt;/li&gt;
&lt;li&gt;从而削弱对减排、代际正义的道德论证&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>自由意志</title><link>https://analyst-huang.github.io/posts/2025%E7%A7%8B%E5%A4%96%E5%93%B2%E6%89%80%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%87%AA%E7%94%B1%E6%84%8F%E5%BF%97/</link><pubDate>Thu, 25 Dec 2025 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/2025%E7%A7%8B%E5%A4%96%E5%93%B2%E6%89%80%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%87%AA%E7%94%B1%E6%84%8F%E5%BF%97/</guid><description>&lt;h1 id="自由意志兼容论非兼容论与自由意志论libertarianism复习笔记"&gt;自由意志：兼容论、非兼容论与自由意志论（Libertarianism）复习笔记&lt;/h1&gt;
&lt;h2 id="0-预备概念决定论与自由意志责任要什么"&gt;0. 预备概念：决定论与“自由意志/责任”要什么？&lt;/h2&gt;
&lt;h3 id="01-决定论determinism"&gt;0.1 决定论（Determinism）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;世界在任一时刻的&lt;strong&gt;过去事实（past facts）&lt;strong&gt;与&lt;/strong&gt;自然法则（laws of nature）&lt;strong&gt;共同&lt;/strong&gt;唯一决定&lt;/strong&gt;未来所有事实（含人的行动）。&lt;/li&gt;
&lt;li&gt;直观：给定过去与法则，未来“只能那样”。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="02-自由意志常见要求不同立场取舍不同"&gt;0.2 自由意志常见要求（不同立场取舍不同）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可替代可能性（PAP, alternative possibilities）&lt;/strong&gt;：在相同条件下“本可以做别的”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制（control）&lt;/strong&gt;：行动由我掌控，而非纯粹外力或运气&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;源头性（sourcehood / ultimacy）&lt;/strong&gt;：行动在恰当意义上“最终源于我”，不是仅仅源于过去+法则&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;理由导向（reasons-responsiveness）&lt;/strong&gt;：行动对理由敏感、可被理性解释&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="1-不兼容论incompatibilism自由与决定论不相容"&gt;1. 不兼容论（Incompatibilism）：自由与决定论不相容&lt;/h2&gt;
&lt;h3 id="11-核心主张"&gt;1.1 核心主张&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;**自由意志（free will）&lt;strong&gt;与&lt;/strong&gt;决定论（determinism）**不能同时为真：
&lt;ul&gt;
&lt;li&gt;若决定论真 → 没有自由（至少没有“所需那种”自由）&lt;/li&gt;
&lt;li&gt;若要自由 → 世界必须在关键处非决定&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="12-说明性论证典型直觉"&gt;1.2 说明性论证（典型直觉）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;若决定论为真：
&lt;ul&gt;
&lt;li&gt;行动 = 过去事实 + 自然法则 的必然结果&lt;/li&gt;
&lt;li&gt;过去与法则不由我控制&lt;/li&gt;
&lt;li&gt;因此我缺乏“最终源头性控制”（ultimate sourcehood）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-兼容论compatibilism自由与决定论可以相容"&gt;2. 兼容论（Compatibilism）：自由与决定论可以相容&lt;/h2&gt;
&lt;h3 id="21-核心主张"&gt;2.1 核心主张&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;决定论即便为真，也可以有自由意志与责任。&lt;/li&gt;
&lt;li&gt;关键策略：重述“自由/责任”的条件，使其不要求 PAP 或终极源头性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;法兰克福案例&lt;/strong&gt;
- 小明犹豫是请假还是上课，经过考虑，他决定去上课。小明所不知道的是：考勤狂人在他头脑中装了监听器，如果他的考虑过程最终倾向于请假，那么在他即将做出请假决定的时候，监听器就会触发，并干预他的神经信号，让他决定去上课。不过，这种干预情形实际上并没发生。&lt;/p&gt;
&lt;h3 id="24-兼容论的优势"&gt;2.4 兼容论的优势&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;保留自然因果图景&lt;/strong&gt;：不需引入实体因果或形而上学“断裂”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可解释法律与道德实践&lt;/strong&gt;：责任可理解为社会规训、理由回应与人格塑造的制度实践。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="25-可能反驳对兼容论"&gt;2.5 可能反驳（对兼容论）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;反驳A：只是“换定义”（changing the subject）&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;不兼容论者：你描述的是“自愿”（voluntariness），不是“自由意志”。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反驳B：缺乏终极应得性（basic desert）基础&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;即便机制良好，若行动仍是过去+法则必然结果，“我凭什么应得赞扬/惩罚”？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反驳C：操控问题（manipulation argument）&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;若某人被精密操控成拥有某套欲望与反思结构，兼容论标准可能仍判为“自由”，但直觉拒斥。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id="3-自由意志论libertarianism不兼容论--肯定自由意志存在"&gt;3. 自由意志论（Libertarianism）：不兼容论 + 肯定自由意志存在&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Libertarianism（自由意志论）在此是形而上学立场：&lt;br&gt;
认为自由需要非决定性，但自由确实存在。&lt;/p&gt;</description></item><item><title>规范伦理学</title><link>https://analyst-huang.github.io/posts/2025%E7%A7%8B%E5%A4%96%E5%93%B2%E6%89%80%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%A7%84%E8%8C%83%E4%BC%A6%E7%90%86%E5%AD%A6/</link><pubDate>Thu, 25 Dec 2025 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/2025%E7%A7%8B%E5%A4%96%E5%93%B2%E6%89%80%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%A7%84%E8%8C%83%E4%BC%A6%E7%90%86%E5%AD%A6/</guid><description>&lt;h2 id="一规范伦理学总论"&gt;一、规范伦理学总论&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;规范伦理学（Normative Ethics）&lt;/strong&gt; 关注如何判断行为的对错。&lt;/p&gt;
&lt;p&gt;规范伦理学试图给出&lt;strong&gt;行动的评价标准&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id="三大主流理论"&gt;三大主流理论&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;理论&lt;/th&gt;
&lt;th&gt;核心标准&lt;/th&gt;
&lt;th&gt;代表人物与理念&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;后果主义&lt;/strong&gt;（Consequentialism）&lt;/td&gt;
&lt;td&gt;行为的道德价值完全由其后果决定&lt;/td&gt;
&lt;td&gt;杰里米·边沁提出功利主义；密尔区分高低之乐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;义务论&lt;/strong&gt;（Deontology）&lt;/td&gt;
&lt;td&gt;重视行为本身的性质，有些行为无论后果如何都必须做或不能做&lt;/td&gt;
&lt;td&gt;罗斯的原初义务；康德的定言命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;美德伦理学&lt;/strong&gt;（Virtue Ethics）&lt;/td&gt;
&lt;td&gt;先问“怎样的人是好人”，再由理想人格推导正确行为&lt;/td&gt;
&lt;td&gt;亚里士多德的功能论证与德性伦理&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id="二后果主义consequentialism"&gt;二、后果主义（Consequentialism）&lt;/h2&gt;
&lt;h3 id="21-核心原则与古典功利主义"&gt;2.1 核心原则与古典功利主义&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;基础原则&lt;/strong&gt;&lt;br&gt;
行为的道德对错完全由其后果决定。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;边沁（Jeremy Bentham）&lt;/strong&gt;&lt;br&gt;
提出“效用原则（Principle of Utility）”，认为快乐与痛苦是评价行为的标准。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;密尔（John Stuart Mill）&lt;/strong&gt;&lt;br&gt;
提出&lt;strong&gt;质的快乐论&lt;/strong&gt;，区分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;低等快乐（身体相关）&lt;/li&gt;
&lt;li&gt;高等快乐（心智与理性相关）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="22-后果主义的不同版本及其反驳"&gt;2.2 后果主义的不同版本（及其反驳）&lt;/h3&gt;
&lt;h4 id="1结果依据"&gt;（1）结果依据&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;① 实际后果主义（Actual Consequentialism）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主张：行为是否正确，取决于其事实上造成的后果。&lt;/li&gt;
&lt;li&gt;反驳：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;道德运气问题（moral luck）&lt;/strong&gt;：行动者可能在完全理性、信息充分的情况下行事，却因不可控偶然因素被判为道德错误。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不公平的责任归属&lt;/strong&gt;：道德评价被事后结果“劫持”，忽视行动者的认知与合理预期。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;② 预期后果主义（Expected Consequentialism）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主张：行为是否正确，取决于其期望后果（概率加权）。&lt;/li&gt;
&lt;li&gt;反驳：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;结果脱钩直觉&lt;/strong&gt;：一个导致灾难性结果的行为，可能仍被判为“道德正确”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;技术化风险&lt;/strong&gt;：道德判断过度依赖概率估计，弱化常识性道德责任。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id="2评价视角"&gt;（2）评价视角&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;① 行动者中立（Agent-neutral Consequentialism）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主张：所有人的利益在道德评估中具有同等权重。&lt;/li&gt;
&lt;li&gt;反驳：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;异化批评（alienation objection）&lt;/strong&gt;：忽视个人关系、承诺与人生项目的道德意义。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;角色道德冲突&lt;/strong&gt;：无法解释为何我对“我的孩子”“我的承诺”有特殊责任。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;② 行动者相对（Agent-relative Consequentialism）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主张：某些后果理由相对于行动者身份或关系而变化。&lt;/li&gt;
&lt;li&gt;反驳：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;规范统一性受损&lt;/strong&gt;：价值评估因人而异，削弱后果主义的客观性与普遍性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;滑向相对主义&lt;/strong&gt;：难以说明不同行动者理由之间的可比性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id="3聚合方式"&gt;（3）聚合方式&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;① 总和后果主义（Total / Sum Consequentialism）&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>bubblewrap</title><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/bubblewrap/</link><pubDate>Wed, 24 Dec 2025 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/bubblewrap/</guid><description>&lt;h1 id="bubblewrap-的功能与-gpu-隔离用法"&gt;Bubblewrap 的功能与 GPU 隔离用法&lt;/h1&gt;
&lt;h2 id="bubblewrap-是做什么的"&gt;Bubblewrap 是做什么的&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Bubblewrap（bwrap）&lt;/strong&gt; 是一个基于 Linux namespaces 的&lt;strong&gt;进程级 sandbox 工具&lt;/strong&gt;，核心功能只有一件事：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;在系统层面为“单个进程”构造一个最小可见、白名单式的运行环境。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从工程角度看，它提供的能力非常集中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建独立的 &lt;strong&gt;mount namespace&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;默认使用 &lt;strong&gt;空的根文件系统（tmpfs）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;仅通过 &lt;code&gt;--bind / --dev-bind&lt;/code&gt; 暴露&lt;strong&gt;显式允许的路径与设备&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;精确控制 &lt;code&gt;/dev&lt;/code&gt; 下可见的设备节点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;进程退出即销毁&lt;/strong&gt;，无任何残留状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它&lt;strong&gt;不负责&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;镜像构建&lt;/li&gt;
&lt;li&gt;服务部署&lt;/li&gt;
&lt;li&gt;长期运行&lt;/li&gt;
&lt;li&gt;资源调度&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="bubblewrap-能解决什么-gpu-问题"&gt;Bubblewrap 能解决什么 GPU 问题&lt;/h2&gt;
&lt;p&gt;在 Isaac Lab / Omniverse 场景中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CUDA_VISIBLE_DEVICES&lt;/code&gt; 只影响 &lt;strong&gt;CUDA&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Vulkan / RTX / NVML 仍可能枚举&lt;strong&gt;宿主机全部 GPU&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;根因是：&lt;strong&gt;系统设备节点未被隔离&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Bubblewrap 的作用是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;从 &lt;code&gt;/dev&lt;/code&gt; 与文件系统层面，让“不该存在的 GPU 真的不存在”。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="最小示例用-bubblewrap-屏蔽-gpu"&gt;最小示例：用 Bubblewrap 屏蔽 GPU&lt;/h2&gt;
&lt;p&gt;下面示例中，&lt;strong&gt;进程只能看到 GPU 0&lt;/strong&gt;，其余 GPU 在系统层面不可见。&lt;/p&gt;</description></item><item><title>心灵哲学：意向性与心理内容（Intentionality &amp; Mental Content）</title><link>https://analyst-huang.github.io/posts/2025%E7%A7%8B%E5%A4%96%E5%93%B2%E6%89%80%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BF%83%E7%81%B5%E5%93%B2%E5%AD%A62/</link><pubDate>Tue, 23 Dec 2025 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/2025%E7%A7%8B%E5%A4%96%E5%93%B2%E6%89%80%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BF%83%E7%81%B5%E5%93%B2%E5%AD%A62/</guid><description>&lt;blockquote&gt;
&lt;p&gt;课程主题：&lt;strong&gt;意向性（Intentionality）&lt;/strong&gt; 与 &lt;strong&gt;心理内容（Mental Content）&lt;/strong&gt; 如何可能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="0-基本框架与术语"&gt;0. 基本框架与术语&lt;/h2&gt;
&lt;h3 id="01-意向性intentionality"&gt;0.1 意向性（Intentionality）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;意向性&lt;/strong&gt;：心灵/心理状态具有“关于（aboutness）”某物的能力：能够&lt;strong&gt;指称（refer）&lt;/strong&gt;、&lt;strong&gt;表征（represent）&lt;strong&gt;或&lt;/strong&gt;指向（be about）&lt;strong&gt;对象、性质与&lt;/strong&gt;事态（state of affairs）&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;说一个人的心理状态“有意向性”，通常等于说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它们是&lt;strong&gt;心理表征（mental representations）&lt;/strong&gt;，或&lt;/li&gt;
&lt;li&gt;它们具有&lt;strong&gt;内容（content）&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;You hope that it will be warmer tomorrow.&lt;/em&gt;（你希望明天更暖和。）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;I believe that it will be.&lt;/em&gt;（我相信会更暖和。）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="02-命题态度propositional-attitudes"&gt;0.2 命题态度（Propositional Attitudes）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;标准形式：&lt;strong&gt;主体 S + 态度（believe/hope/fear…）+ 命题 p&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如：S believes that p.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;“心理内容”在这里主要是：这个命题 p &lt;strong&gt;说的是什么&lt;/strong&gt;（what is said / represented）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="03-p-obtains-的含义obtain"&gt;0.3 “p obtains” 的含义（obtain）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在分析哲学语境中：&lt;strong&gt;p obtains = 事态 p 在世界中成立/为真/发生（is the case / holds / is true）&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;这是讨论内容与世界关系时常用的写法：强调“世界中确实如此”，而非仅仅“句子语义上为真”。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="1-核心问题心理内容从何而来mental-content"&gt;1. 核心问题：心理内容从何而来？（Mental Content）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：这些意向状态/命题态度如何具有它们所具有的内容，并表征它们所表征的事态？&lt;/p&gt;</description></item><item><title>心灵哲学：意识问题（The Problems of Consciousness）</title><link>https://analyst-huang.github.io/posts/2025%E7%A7%8B%E5%A4%96%E5%93%B2%E6%89%80%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BF%83%E7%81%B5%E5%93%B2%E5%AD%A63/</link><pubDate>Tue, 23 Dec 2025 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/2025%E7%A7%8B%E5%A4%96%E5%93%B2%E6%89%80%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BF%83%E7%81%B5%E5%93%B2%E5%AD%A63/</guid><description>&lt;blockquote&gt;
&lt;p&gt;目标：区分并理解当代关于意识（consciousness）的核心问题结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;现象意识&lt;/strong&gt;（phenomenal consciousness / qualia）与 &lt;strong&gt;取用意识&lt;/strong&gt;（access consciousness）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;易问题&lt;/strong&gt;（the easy problem）与 &lt;strong&gt;难问题&lt;/strong&gt;（the hard problem）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解释鸿沟&lt;/strong&gt;（explanatory gap）以及由此引出的反物理主义论证（anti-physicalist arguments）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="1-two-types-of-consciousness两类意识"&gt;1. Two Types of Consciousness（两类意识）&lt;/h2&gt;
&lt;h3 id="11-phenomenal-consciousness现象意识"&gt;1.1 Phenomenal Consciousness（现象意识）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义（definition）&lt;/strong&gt;：现象意识是**经验（experience）**本身；一个状态的现象面向是“处于该状态是什么感觉”（&lt;em&gt;what it is like to be in that state&lt;/em&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;例子（examples）&lt;/strong&gt;：感觉（sensations）、情绪（emotions）、知觉（perceptions）、感受（feelings）。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;补充说明（概念强化）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;现象意识通常以 &lt;strong&gt;质感/质素&lt;/strong&gt;（qualia）表征：它们并非（至少表面上）通过功能角色（functional role）完全刻画。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id="12-access-consciousness取用意识"&gt;1.2 Access Consciousness（取用意识）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义（definition）&lt;/strong&gt;：当一个状态是有意识的，其所携带的内容能够被其它认知功能&lt;strong&gt;取用&lt;/strong&gt;（available for use），如推理、决策、言语报告（verbal reporting）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;例子（examples）&lt;/strong&gt;：思想（thoughts）、信念（beliefs）、欲望（desires）。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;补充说明（概念强化）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取用意识强调的是&lt;strong&gt;信息可用性&lt;/strong&gt;（availability）与认知模块之间的可访问性（accessibility），较容易被功能主义（functionalism）框架吸收。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id="2-access-consciousness-without-phenomenal-consciousness无现象的取用意识"&gt;2. Access Consciousness without Phenomenal Consciousness（无现象的取用意识）&lt;/h2&gt;
&lt;h3 id="blindsight盲视"&gt;Blindsight（盲视）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;现象（syndrome）&lt;/strong&gt;：初级视觉皮层（primary visual cortex）受损者在视野中存在盲区，主观报告“看不见”（no visual percepts）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;关键现象（key findings）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在盲区闪现刺激时，患者往往能&lt;strong&gt;猜对&lt;/strong&gt;刺激是“X”还是“O”，还能判断位置/运动；甚至能接住在盲区抛来的球。&lt;/li&gt;
&lt;li&gt;经训练后，患者可在无提示下作出“我被呈现了一个 X”之类的&lt;strong&gt;觉察&lt;/strong&gt;（awareness）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;哲学点（philosophical point）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该觉察的内容对推理与报告可用，因此是 &lt;strong&gt;access-conscious&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;但缺乏相应的“看见的感觉”，因此缺乏 &lt;strong&gt;phenomenal consciousness&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="3-phenomenal-consciousness-without-access-consciousness有现象但无取用"&gt;3. Phenomenal Consciousness without Access Consciousness（有现象但无取用）&lt;/h2&gt;
&lt;h3 id="automatic-pilot-driver自动驾驶驾驶者"&gt;Automatic Pilot Driver（“自动驾驶”驾驶者）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;现象（phenomenon）&lt;/strong&gt;：驾驶时突然“回过神”，发现过去半小时对道路与交通几乎无记忆。&lt;/p&gt;</description></item><item><title>心灵哲学（Philosophy of Mind）</title><link>https://analyst-huang.github.io/posts/2025%E7%A7%8B%E5%A4%96%E5%93%B2%E6%89%80%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BF%83%E7%81%B5%E5%93%B2%E5%AD%A61/</link><pubDate>Tue, 23 Dec 2025 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/2025%E7%A7%8B%E5%A4%96%E5%93%B2%E6%89%80%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%BF%83%E7%81%B5%E5%93%B2%E5%AD%A61/</guid><description>&lt;blockquote&gt;
&lt;p&gt;目标：在常识层面区分“心灵/心理”（the mental）与“物理”（the physical），并梳理主要立场与核心论证。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="1-心灵哲学讨论什么"&gt;1. 心灵哲学讨论什么&lt;/h2&gt;
&lt;p&gt;心灵哲学（Philosophy of Mind）研究心灵的本性，以及它与身体（尤其是大脑）及外部世界的关系。&lt;/p&gt;
&lt;h3 id="11-心理现象的两类典型例子"&gt;1.1 心理现象的两类典型例子&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;感受性 / 感觉质（sensations / sensory qualities; phenomenal or qualitative character）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;具有“现象特征/质性特征”（phenomenal/qualitative character），构成&lt;strong&gt;现象意识（phenomenal consciousness）&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;例：疼痛、痒、刺痛、余像、看到绿色圆斑、闻到氨味、恶心等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;命题态度 / 意向状态（propositional attitudes / intentional states）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以主体对某个命题（proposition）的“态度”（attitude）为核心。&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;常识心理学&lt;/strong&gt;中常用来解释与预测行为。&lt;/li&gt;
&lt;li&gt;例：
&lt;ul&gt;
&lt;li&gt;“我相信地球在运动”（belief）&lt;/li&gt;
&lt;li&gt;“我希望明天会下雨”（hope）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;其他心理现象&lt;/strong&gt;：情绪（emotions）、意志（volitions）、行动（actions）等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="2-心灵的标识物区分心灵与物理的判据mark-of-the-mental"&gt;2. “心灵的标识物”：区分心灵与物理的判据（Mark of the Mental）&lt;/h2&gt;
&lt;p&gt;问题：我们凭什么把某些现象归为“心灵的”，并把另一些归为“物理的”？常见思路有两类：&lt;strong&gt;认识论判据&lt;/strong&gt;与&lt;strong&gt;意向性判据&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id="21-认识论判据epistemological-criteria"&gt;2.1 认识论判据（epistemological criteria）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;直接/即时知识（direct or immediate knowledge）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直觉：对心灵状态的认识不依赖证据（evidence）；对物理状态的认识通常依赖证据。&lt;/li&gt;
&lt;li&gt;反例：对某些简单物理事实也可能是直接的（例如你正对着墙上的巨大红色圆形）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;隐私性与第一人称特权（privacy / first-person privilege; privileged access）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直觉：对某个心理事件的直接通达（direct access）只被单一主体拥有。&lt;/li&gt;
&lt;li&gt;反例：**本体感受/本体觉（proprioception）**在某些意义上也具有“直接性”，且可被外部测量与推断。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;不可错性与透明性（infallibility &amp;amp; transparency）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不可错性：主体不会弄错自己是否正在经历某个心理事件。&lt;/li&gt;
&lt;li&gt;透明性：心理事件对主体是“透明/可见”的（主体知道自己在经历什么）。&lt;/li&gt;
&lt;li&gt;反例：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;无意识/潜意识&lt;/strong&gt;信念、欲望、情绪（against transparency）&lt;/li&gt;
&lt;li&gt;感觉类型的误判/误分类（misclassification / misidentification）（against infallibility）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;小结：认识论判据往往抓住了心灵现象的一些“典型”特征，但并非无例外。&lt;/p&gt;</description></item><item><title/><link>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/pickle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/pickle/</guid><description>&lt;p&gt;Python 中的 pickle：对象序列化的原理与使用&lt;/p&gt;
&lt;p&gt;在 Python 中，pickle
是标准库提供的一种对象序列化（serialization）与反序列化（deserialization）机制。它可以将内存中的
Python
对象转换为字节流保存到文件或通过网络传输，并在之后将这些字节流还原为等价的
Python 对象。&lt;/p&gt;
&lt;p&gt;本文将从概念、使用方式、工作机制、常见问题与安全性等方面系统介绍
pickle。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;一、什么是序列化？&lt;/p&gt;
&lt;p&gt;程序运行时的对象存在于内存中，包含复杂的结构与指针关系，例如嵌套的列表、字典、对象之间的引用等。这些结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;依赖进程内存地址&lt;/li&gt;
&lt;li&gt;不能直接写入磁盘&lt;/li&gt;
&lt;li&gt;不能直接通过网络发送&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;序列化的目标，就是把这种 &lt;strong&gt;“对象图结构”&lt;/strong&gt; 转换为：&lt;/p&gt;
&lt;p&gt;一段连续的字节序列（byte stream）&lt;/p&gt;
&lt;p&gt;这样才能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写入文件&lt;/li&gt;
&lt;li&gt;通过 socket 发送&lt;/li&gt;
&lt;li&gt;作为缓存保存&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;反过来，从字节流恢复对象结构的过程称为反序列化。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;二、pickle 的基本用法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;序列化到文件&lt;/p&gt;
&lt;p&gt;import pickle&lt;/p&gt;
&lt;p&gt;data = {&amp;ldquo;a&amp;rdquo;: 1, &amp;ldquo;b&amp;rdquo;: [1, 2, 3]}&lt;/p&gt;
&lt;p&gt;with open(&amp;ldquo;data.pkl&amp;rdquo;, &amp;ldquo;wb&amp;rdquo;) as f:
pickle.dump(data, f)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意：必须使用二进制模式 &amp;ldquo;wb&amp;rdquo;。&lt;/p&gt;
&lt;hr&gt;
&lt;ol start="2"&gt;
&lt;li&gt;
&lt;p&gt;从文件反序列化&lt;/p&gt;
&lt;p&gt;with open(&amp;ldquo;data.pkl&amp;rdquo;, &amp;ldquo;rb&amp;rdquo;) as f:
data2 = pickle.load(f)&lt;/p&gt;
&lt;p&gt;print(data2)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同样必须使用 &amp;ldquo;rb&amp;rdquo; 二进制模式，否则会出现 UnicodeDecodeError。&lt;/p&gt;
&lt;hr&gt;
&lt;ol start="3"&gt;
&lt;li&gt;
&lt;p&gt;直接在内存中序列化&lt;/p&gt;
&lt;p&gt;bytes_data = pickle.dumps(data)
data3 = pickle.loads(bytes_data)&lt;/p&gt;</description></item></channel></rss>