<!doctype html><html lang=en dir=auto data-theme=auto><head><meta name=generator content="Hugo 0.154.5"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Blog</title><meta name=description content><meta name=author content><link rel=canonical href=https://analyst-huang.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://analyst-huang.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://analyst-huang.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://analyst-huang.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://analyst-huang.github.io/apple-touch-icon.png><link rel=mask-icon href=https://analyst-huang.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://analyst-huang.github.io/index.xml title=rss><link rel=alternate type=application/json href=https://analyst-huang.github.io/index.json title=json><link rel=alternate hreflang=en href=https://analyst-huang.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\\\(",right:"\\\\)",display:!1},{left:"\\\\[",right:"\\\\]",display:!0}]})})</script><meta property="og:url" content="https://analyst-huang.github.io/"><meta property="og:site_name" content="Blog"><meta property="og:title" content="Blog"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Blog"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Blog","url":"https://analyst-huang.github.io/","description":"","logo":"https://analyst-huang.github.io/favicon.ico","sameAs":[]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://analyst-huang.github.io/ accesskey=h title="Blog (Alt + H)">Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://analyst-huang.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://analyst-huang.github.io/about/ title=关于><span>关于</span></a></li><li><a href=https://analyst-huang.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=first-entry><header class=entry-header><h2 class=entry-hint-parent>用 Pandoc 将 Pandoc AST JSON 生成 EPUB（稳定可复现工作流）</h2></header><div class=entry-content><p>背景 当你的内容已经被整理成 Pandoc AST JSON（即 Pandoc 的抽象语法树 JSON：顶层包含 pandoc-api-version / meta / blocks），Pandoc 可以直接把它转换成 EPUB，而不需要再走「拼 Markdown」的路径。
这条路线的优势是：
结构严格：章节、段落、目录都由 AST 明确表达 自动化友好：适合爬虫/批处理/流水线 输出稳定：避免 “把 \n 塞进字符串却不换行” 等语义问题 本文默认你的 JSON 已经是 Pandoc AST JSON。如果你的 JSON 是业务结构（例如 chapters/paras），需要先转换为 Pandoc AST，再继续。
0. 快速自检：你的 JSON 是否是 Pandoc AST 打开 JSON 文件，顶层应类似：
pandoc-api-version: 版本数组 meta: 元数据 blocks: 块级节点数组（Header / Para 等） 也可以用 Pandoc 做一次“反向转换”来验证能否被解析：
pandoc -f json book.json -t markdown -o check.md 如果能生成合理的 Markdown（章节、段落结构正确），基本就没问题。
1. 最小命令：JSON → EPUB pandoc -f json -t epub book.json -o book.epub 参数说明：
...</p></div><footer class=entry-footer><span title='2026-01-26 23:00:00 -0800 -0800'>January 26, 2026</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to 用 Pandoc 将 Pandoc AST JSON 生成 EPUB（稳定可复现工作流）" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/pandoc-json-to-epub/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>从第一性原理理解 CSS：规则系统、约束求解与渲染管线</h2></header><div class=entry-content><p>CSS 往往被误解为“调颜色、调间距”的属性集合。但如果从第一性原理出发，CSS 更像一门作用于树结构的数据上的声明式规则系统：它描述约束，浏览器负责求解与渲染。本文尝试用尽可能少的经验主义记忆，构造一个可复用的抽象模型，帮助你在遇到布局、优先级、性能等问题时能“从底层推回去”。
1. 浏览器到底在做什么 浏览器的核心任务可以拆成三步：
解析：把 HTML 解析成结构化的树（DOM）。 求解：为树上每个节点求出“最终样式”（computed style），并进一步求出几何信息（layout：位置与尺寸）。 绘制：把几何与视觉属性转成像素（paint），再进行图层合成（composite）。 CSS 处在第 2 步的上游：它提供规则与约束，使浏览器能把“结构树”变成“可布局、可绘制的对象”。
2. CSS 的本体抽象：规则集合作用于树 把一个 CSS 文件抽象成一堆规则的集合：
规则（rule） = 选择器（selector） + 声明块（declarations） 选择器：对树节点成立与否的谓词（predicate） 声明：对节点施加的属性约束（property constraints） 最典型的形式：
selector { property: value; property: value; } 更形式化一点（接近数学/编译器视角）：
设规则集合 R = {r_1, r_2, ...} 每条规则 r_i = (S_i, D_i) S_i：选择器谓词（对节点及其上下文求值） D_i：一组声明（属性→值） 对任意节点 n，若 n ⊨ S_i（选择器对该节点成立），则 D_i 参与该节点的样式计算。
这里有一个关键点：CSS 不会“把样式写进节点”。浏览器内部更像维护一张映射：
node -> computed_style 样式是派生状态，而非原始数据结构的一部分。
3. 选择器不是“指针”，而是“逻辑条件” 很多初学者把 selector 理解为“找到某个元素”，但更准确的是：
...</p></div><footer class=entry-footer><span title='2026-01-26 00:00:00 +0000 UTC'>January 26, 2026</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to 从第一性原理理解 CSS：规则系统、约束求解与渲染管线" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/css-first-principles-hugo/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Elementary Calculus: An Infinitesimal Approach: Chapter 4</h2></header><div class=entry-content><p>TLDR; 通过划分区间的方法，非标准分析以直观的形式重新定义黎曼和积分。
Definition Let a &lt; b and let $\Delta x$ be a positive real number. Then the Riemann sum $\sum_a^b f(x) \Delta x$ is defined as the sum $$ \sum_a^b f(x) \Delta x = f(x_0)\Delta x + f(x_1)\Delta x + ... + f(x_{n-1})\Delta x + f(x_n)(b-x_n) $$ where n is the largest integer such that $a + n \Delta x \leq b$ and $$ x_0 = a, x_k = a + k\Delta x $$ are the partition points. ...</p></div><footer class=entry-footer><span title='2026-01-25 00:00:00 +0000 UTC'>January 25, 2026</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to Elementary Calculus: An Infinitesimal Approach: Chapter 4" href=https://analyst-huang.github.io/posts/math/elementary_calculus_an_infinitesimal_approach_chapter_4/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Elementary Calculus: An Infinitesimal Approach: Chapter 3</h2></header><div class=entry-content><p>TLDR； 本章讲解了非标准体系下，极限、连续的定义，并证明了费马引理，罗尔定理，中值定理等重要定理。对于无穷大整数切分区间的引入，使得证明更加符合直觉。
Difinition L is the limit of f(x) as x approaches c if whenever x is infinitely close to but not equal to c, f(x) is infinitely close to L $$ \lim_{x\rightarrow c}f(x) = L $$ Remark 这里的L是一个real number，否则等号后面就可以有不同的hyperreal number了。
由极限的定义和标准部的运算法则，可以很容易的推导出极限的运算法则，不再重复。
同理可以定义左极限和右极限。
Difinition f is said to be continuous at a point c if:
f is defined at c whenever x is infinitely close to c, f(x) is infinitely close to f(c) Remark 显然连续就等价于左极限等于右极限并且在该点有定义。以及左连续和右连续也是自然的。
...</p></div><footer class=entry-footer><span title='2026-01-23 00:00:00 +0000 UTC'>January 23, 2026</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to Elementary Calculus: An Infinitesimal Approach: Chapter 3" href=https://analyst-huang.github.io/posts/math/elementary_calculus_an_infinitesimal_approach_chapter_3/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Tailscale + VS Code Remote-SSH 故障排查复盘</h2></header><div class=entry-content><p>从原理到实战：Tailscale 在校园网环境下的连接机制与排障记录 1. 背景与问题陈述 我希望用 Tailscale 让两台处于不同网络环境（不同 NAT/不同局域网）的机器互相访问。实际使用/调试中遇到典型问题：
tailscale netcheck 有时显示 IPv6 可用、有时不可用； 关闭路由器 UPnP 后，PortMapping 变为空，但依旧无法 ping 对端； 路由器后台显示 WAN 口拿到了公网 IPv6，但内网主机 ipconfig 只有 fe80::（link-local）而没有公网 IPv6； 最终定位：校园网策略限制导致“路由器能拿到 IPv6，但无法向 LAN 下发前缀（Prefix Delegation/RA）”，从而使内网终端 IPv6 不可用；Tailscale 在纯 IPv4 + 多级 NAT 环境下直连成功率显著下降，表现为 ping 不通或频繁退化到 DERP 中继。 2. Tailscale 是什么：控制面与数据面 一句话概括：
Tailscale = WireGuard 数据面 + 云端控制面（身份/公钥/节点发现/路由下发） 的自动化 Overlay Network。
2.1 控制面（Control Plane）做什么 控制面通过 HTTPS 与每个节点通信，负责：
身份认证（SSO/OAuth 等）与设备注册 节点公钥分发（谁是谁的 peer） 节点地址发现与“可达性信息”交换（NAT 映射、候选 endpoint） ACL/路由策略下发（谁可以访问谁） 控制面不承载你的业务数据（除非走 DERP 时需要中继服务，见下文）。
...</p></div><footer class=entry-footer><span title='2026-01-23 00:00:00 +0000 UTC'>January 23, 2026</span>&nbsp;·&nbsp;<span>3 min</span></footer><a class=entry-link aria-label="post link to Tailscale + VS Code Remote-SSH 故障排查复盘" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/tailscale_remote_ssh_debug_summary/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Elementary Calculus: An Infinitesimal Approach: Chapter 2</h2></header><div class=entry-content><p>TLDR; 本章讲述的是用非标准分析建立导数概念的过程。相较于传统教材对dx，dy的语焉不详，非标准分析极清晰地给出了定义，并严格的建立了对$d$的运算法则。
Definition S is aid to be the slope of f at a if: $$ S = st(\frac{f(a + \Delta x) - f(a)}{\Delta x}) $$ for every nonzero infinitesimal $\Delta x$
Remark 这就是非标准分析中的slope的定义。我们取直觉上斜率在无穷小情况下的标准部，即可得到导数。这里的对于每个非零无穷小，是必要的，例如$|x|$ 在原点处。更好的例子是 $$ f(x) = x \sin (x) (x \neq 0), f(0) = 0 $$ 容易验证，在0处，原式等于$\sin(\frac{1}{\Delta x})$,我们可以构造无穷小，使得这个表达式可以等于一个确定的值。例如说，我们先取一个整数的无穷大N， 然后构造新的无穷大 $N\pi$, 那么 $\frac{1}{N\pi}$就是一个无穷小，而原式等于0。同样的，我们可以构造出使得原式任意取值的无穷小，因此这一点的slope是不存在的,同时也说明这个定义无法更宽泛了。
Definition Let f be a real function of one variable. The derivative of f is the new funtion f’ whose value at x is the slope of f at x. In symbols, $$ f'(x) = st(\frac{f(x + \Delta x) - f(x)}{\Delta x}) $$ whenever the slope exists.
...</p></div><footer class=entry-footer><span title='2026-01-22 00:00:00 +0000 UTC'>January 22, 2026</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to Elementary Calculus: An Infinitesimal Approach: Chapter 2" href=https://analyst-huang.github.io/posts/math/elementary_calculus_an_infinitesimal_approach_chapter_2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Elementary Calculus: An Infinitesimal Approach: Chapter 1</h2></header><div class=entry-content><p>前言 在大一的时候就在高数的书上看到了对非标准分析的科普，当时就找来了Robinson的大部头来看，结果当然是看不懂了，毕竟当时的数学基础很差。最近有空，而且LLM也发展的很好，很多问题都不用自己一个人苦思冥想，还不知道对不对了。所以挑了一本先把模型论等等的知识作直觉把握，然后重写微积分（严谨地）的书。
TLDR; 非标准分析之所以在某些方面比$\delta-\epsilon$语言清晰和简明，是因为通过将$\mathbb{R}$扩张为$\mathbb{R}^*$（超实数），将$\delta-\epsilon$语言的外在的量词压缩到了无穷小这个超实数的定义中。例如f(x)在a处的极限：
∀ε>0∃δ>0(∀x,∣x−a∣&lt;δ⇒∣f(x)−f(a)∣&lt;ε) 如果我们用非标准分析的语言来写，那么这个命题可以写成： ∀x≈a,f(x)≈f(a) 其中 x≈a的定义是 x-a是无穷小（指的是超实数，不是原来$\delta-\epsilon$语言的无穷小）。换言之，"对于任意的epsilon"在这里已经被作为*超实数*的无穷小这个概念所覆盖了。 超实数轴(The Hyperreal Line) 超实数是对实数的扩展：两端的无穷大，原点附近的无穷小，以及每个实数附近的超实数。通过模型论，可以严格保证——所有关于实数的标准一阶命题，在超实数体系中仍然成立。如果不深入模型论，只需要记住几个principle就可以了。
THE EXTENSION PRINCIPLE The real numbers from a subset of the hyperreal numbers, and the order relation of x &lt; y for the real numbers is a subset of the order relation for the hyperreal numbers. There is a hyperreal number that is greater than zero but less than every positive real number. For every real function of one or more variable we are given a corresponding hyperreal function f* of the same number of variables. f* is called the natural extension of f. Remark 这条准则给出了超实数的扩展方式。这里的natural extension并不是说给超实数来了一个函数的映射关系，而是说，这个延拓出来的函数，保持实数集上的性质，并且将会满足TRANSFER PRINCIPLE(见下)。
...</p></div><footer class=entry-footer><span title='2026-01-20 00:00:00 +0000 UTC'>January 20, 2026</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to Elementary Calculus: An Infinitesimal Approach: Chapter 1" href=https://analyst-huang.github.io/posts/math/elementary_calculus_an_infinitesimal_approach_chapter_1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>globbing and regex</h2></header><div class=entry-content><p>Globbing vs Regex：为什么会有两种“匹配语言”？ 在日常开发里，我们经常把“模式匹配”混为一谈：
ls *.urdf、rm mesh_* 这类 globbing（通配/路径匹配） grep -E 'urdf_[0-9]+\.obj'、re.match(r'^urdf_\d+\.obj$') 这类 regex（正则/文本匹配） 它们看起来都在“匹配”，但诞生目的、执行位置、工程约束完全不同，因此长期并存，且不可互相取代。
1. 一句话结论 Globbing 是为“选择文件集合”而生的路径匹配语言；Regex 是为“识别字符串结构”而生的通用文本匹配语言。
这不是历史包袱，而是系统边界的理性分工：
glob：快、可预测、安全，适配 shell 的交互与文件系统 regex：表达力强，适配应用内部的字符串解析与结构约束 2. 两者解决的是不同问题域 2.1 Globbing：人机交互中的“文件集合选择” 典型需求：
删除所有 .log 文件：rm *.log 复制所有 urdf_ 前缀文件：cp urdf_* /dst 批量处理当前目录某类资产 关键约束：
必须很快：每条 shell 命令都可能触发 必须可预测：用户要一眼知道会匹配哪些文件 必须安全：不能因为一个模式导致卡死或难以理解的误删 必须能在 exec 之前展开：shell 需要先把参数展开成文件列表再调用程序 因此 glob 的表达能力刻意保持在一个“甜点区间”：够用，但不会失控。
2.2 Regex：计算中的“字符串结构识别” 典型需求：
从日志中抽取时间戳、ID、字段 校验格式（IP、UUID、版本号） 解析协议文本、配置文本 关键目标：
表达能力最大化：分组、捕获、重复次数、断言、替换 允许复杂约束：结构、边界、条件 在程序内部执行：对性能风险、可读性风险的容忍度更高（可控） 3. 语法与能力：差异从根上决定了“不会统一” 3.1 Globbing 的常见语法（有限但高频） 写法 含义 示例 * 任意长度字符 *.urdf ? 单个字符 file?.txt [abc] 任意一个字符 mesh_[ab].obj [a-z] 范围 [0-9]*.log {a,b} brace expansion（shell 特性） file.{png,jpg} 注：{a,b} 属于 shell 的 brace expansion；它不是 POSIX glob 的核心，但在 bash/zsh 中非常常见。
...</p></div><footer class=entry-footer><span title='2026-01-20 00:00:00 +0000 UTC'>January 20, 2026</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to globbing and regex" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/globbing_and_regex/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>xargs</h2></header><div class=entry-content><p>xargs -I 的读取模型与分隔符机制详解 在日常 Linux 批处理管道中，xargs 经常被用于把标准输入转换为命令参数。其中，-I 模式与默认模式在 输入切分（tokenization / record parsing） 上存在本质差异。理解这一点，对于安全处理文件名、构造复杂命令模板以及性能优化非常关键。
本文系统整理以下问题：
使用 -I 时是否只能一行一行读取？ 是否可以自定义分隔符？ -I 与默认模式在行为与性能上的核心区别 实战建议与最佳实践 1. xargs -I 的基本语义 使用 -I 时，xargs 进入 模板替换模式（template substitution mode）：
xargs -I{} command "{}" 含义是：
对每一条输入记录，将其替换到模板中的 {} 位置，然后执行一次命令。
示例：
printf '%s ' a b c | xargs -I{} echo "item={}" # 输出： # item=a # item=b # item=c 核心特征：
每条输入 → 一次命令执行 输入内容整体保留，不再按空格拆分 适合需要把输入插入到命令中间或多处的位置 2. 是否只能"一行一行读取"？ 默认行为：按"行"读取 当启用 -I 时，xargs 默认以 换行符 (\n) 作为记录分隔符。
...</p></div><footer class=entry-footer><span title='2026-01-20 00:00:00 +0000 UTC'>January 20, 2026</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to xargs" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/xargs/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>XML 语法与工程实践：从树模型到 XPath、Namespace 与 CDATA</h2></header><div class=entry-content><p>0. 这篇文章解决什么问题 XML（eXtensible Markup Language）经常被当作“带尖括号的文本”。但在工程场景（URDF、USD/Omniverse 配置、各种工具链描述文件）里，理解 XML 的关键并不是记住几个标签写法，而是把它当成：
一棵“有序树 + 属性 + 文本”的数据结构
程序读的不是字符流，而是结构。
本文从这个树模型出发，系统整理 XML 的核心语法与常见机制：text/tail、XPath、Namespace、CDATA，并给出 Python（ElementTree）与命令行工具的可用做法。
1. Markup Language 是什么：用“标记”把文本变成结构 Markup Language（标记语言）的本质：用标签（tag）给文本加上边界、层级与语义。
&lt;robot name="taco"> &lt;link name="base_link"/> &lt;/robot> 这不是“字符串里夹标签”，而是树：
robot (name="taco") └── link (name="base_link") 标签名是“语义”，属性是“参数”，嵌套是“结构”。
因此 XML 的强项是：跨系统传递结构化语义（而不是仅仅渲染）。
2. XML 的基本语法（严格规则） XML 比 HTML 严格得多。常见约束如下：
2.1 标签必须闭合 ✅ 正确：
&lt;mesh>&lt;/mesh> &lt;mesh /> ❌ 错误：
&lt;mesh> 2.2 区分大小写 &lt;Mesh> ≠ &lt;mesh> 2.3 属性必须加引号 ✅
&lt;link name="base_link"/> ❌
&lt;link name=base_link/> 2.4 必须正确嵌套，且只有一个根节点 ✅
&lt;a>&lt;b/>&lt;/a> ❌
&lt;a>&lt;b>&lt;/a>&lt;/b> 3. Element / Attribute / Text：把 XML 当成对象模型 一个元素（Element）由：
...</p></div><footer class=entry-footer><span title='2026-01-19 00:00:00 +0000 UTC'>January 19, 2026</span>&nbsp;·&nbsp;<span>3 min</span></footer><a class=entry-link aria-label="post link to XML 语法与工程实践：从树模型到 XPath、Namespace 与 CDATA" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/xml/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://analyst-huang.github.io/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://analyst-huang.github.io/>Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>