<!doctype html><html lang=en dir=auto data-theme=auto><head><meta name=generator content="Hugo 0.154.5"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Blog</title><meta name=description content><meta name=author content><link rel=canonical href=https://analyst-huang.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://analyst-huang.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://analyst-huang.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://analyst-huang.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://analyst-huang.github.io/apple-touch-icon.png><link rel=mask-icon href=https://analyst-huang.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://analyst-huang.github.io/index.xml title=rss><link rel=alternate type=application/json href=https://analyst-huang.github.io/index.json title=json><link rel=alternate hreflang=en href=https://analyst-huang.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\\\(",right:"\\\\)",display:!1},{left:"\\\\[",right:"\\\\]",display:!0}]})})</script><meta property="og:url" content="https://analyst-huang.github.io/"><meta property="og:site_name" content="Blog"><meta property="og:title" content="Blog"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Blog"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Blog","url":"https://analyst-huang.github.io/","description":"","logo":"https://analyst-huang.github.io/favicon.ico","sameAs":[]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://analyst-huang.github.io/ accesskey=h title="Blog (Alt + H)">Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://analyst-huang.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://analyst-huang.github.io/about/ title=关于><span>关于</span></a></li><li><a href=https://analyst-huang.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=first-entry><header class=entry-header><h2 class=entry-hint-parent>Elementary Calculus: An Infinitesimal Approach: Chapter 1</h2></header><div class=entry-content><p>前言 在大一的时候就在高数的书上看到了对非标准分析的科普，当时就找来了Robinson的大部头来看，结果当然是看不懂了，毕竟当时的数学基础很差。最近有空，而且LLM也发展的很好，很多问题都不用自己一个人苦思冥想，还不知道对不对了。所以挑了一本先把模型论等等的知识作直觉把握，然后重写微积分（严谨地）的书。
TLDR; 非标准分析之所以在某些方面比$\delta-\epsilon$语言清晰和简明，是因为通过将$\mathbb{R}$扩张为$\mathbb{R}^*$（超实数），将$\delta-\epsilon$语言的外在的量词压缩到了无穷小这个超实数的定义中。例如f(x)在a处的极限：
∀ε>0∃δ>0(∀x,∣x−a∣&lt;δ⇒∣f(x)−f(a)∣&lt;ε) 如果我们用非标准分析的语言来写，那么这个命题可以写成： ∀x≈a,f(x)≈f(a) 其中 x≈a的定义是 x-a是无穷小（指的是超实数，不是原来$\delta-\epsilon$语言的无穷小）。换言之，"对于任意的epsilon"在这里已经被作为*超实数*的无穷小这个概念所覆盖了。 超实数轴(The Hyperreal Line) 超实数是对实数的扩展：两端的无穷大，原点附近的无穷小，以及每个实数附近的超实数。通过模型论，可以严格保证——所有关于实数的标准一阶命题，在超实数体系中仍然成立。如果不深入模型论，只需要记住几个principle就可以了。
THE EXTENSION PRINCIPLE The real numbers from a subset of the hyperreal numbers, and the order relation of x &lt; y for the real numbers is a subset of the order relation for the hyperreal numbers. There is a hyperreal number that is greater than zero but less than every positive real number. For every real function of one or more variable we are given a corresponding hyperreal function f* of the same number of variables. f* is called the natural extension of f. Remark 这条准则给出了超实数的扩展方式。这里的natural extension并不是说给超实数来了一个函数的映射关系，而是说，这个延拓出来的函数，保持实数集上的性质，并且将会满足TRANSFER PRINCIPLE(见下)。
...</p></div><footer class=entry-footer><span title='2026-01-20 00:00:00 +0000 UTC'>January 20, 2026</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to Elementary Calculus: An Infinitesimal Approach: Chapter 1" href=https://analyst-huang.github.io/posts/math/elementary_calculus_an_infinitesimal_approach_chapter_1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>globbing and regex</h2></header><div class=entry-content><p>Globbing vs Regex：为什么会有两种“匹配语言”？ 在日常开发里，我们经常把“模式匹配”混为一谈：
ls *.urdf、rm mesh_* 这类 globbing（通配/路径匹配） grep -E 'urdf_[0-9]+\.obj'、re.match(r'^urdf_\d+\.obj$') 这类 regex（正则/文本匹配） 它们看起来都在“匹配”，但诞生目的、执行位置、工程约束完全不同，因此长期并存，且不可互相取代。
1. 一句话结论 Globbing 是为“选择文件集合”而生的路径匹配语言；Regex 是为“识别字符串结构”而生的通用文本匹配语言。
这不是历史包袱，而是系统边界的理性分工：
glob：快、可预测、安全，适配 shell 的交互与文件系统 regex：表达力强，适配应用内部的字符串解析与结构约束 2. 两者解决的是不同问题域 2.1 Globbing：人机交互中的“文件集合选择” 典型需求：
删除所有 .log 文件：rm *.log 复制所有 urdf_ 前缀文件：cp urdf_* /dst 批量处理当前目录某类资产 关键约束：
必须很快：每条 shell 命令都可能触发 必须可预测：用户要一眼知道会匹配哪些文件 必须安全：不能因为一个模式导致卡死或难以理解的误删 必须能在 exec 之前展开：shell 需要先把参数展开成文件列表再调用程序 因此 glob 的表达能力刻意保持在一个“甜点区间”：够用，但不会失控。
2.2 Regex：计算中的“字符串结构识别” 典型需求：
从日志中抽取时间戳、ID、字段 校验格式（IP、UUID、版本号） 解析协议文本、配置文本 关键目标：
表达能力最大化：分组、捕获、重复次数、断言、替换 允许复杂约束：结构、边界、条件 在程序内部执行：对性能风险、可读性风险的容忍度更高（可控） 3. 语法与能力：差异从根上决定了“不会统一” 3.1 Globbing 的常见语法（有限但高频） 写法 含义 示例 * 任意长度字符 *.urdf ? 单个字符 file?.txt [abc] 任意一个字符 mesh_[ab].obj [a-z] 范围 [0-9]*.log {a,b} brace expansion（shell 特性） file.{png,jpg} 注：{a,b} 属于 shell 的 brace expansion；它不是 POSIX glob 的核心，但在 bash/zsh 中非常常见。
...</p></div><footer class=entry-footer><span title='2026-01-20 00:00:00 +0000 UTC'>January 20, 2026</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to globbing and regex" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/globbing_and_regex/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>xargs</h2></header><div class=entry-content><p>xargs -I 的读取模型与分隔符机制详解 在日常 Linux 批处理管道中，xargs 经常被用于把标准输入转换为命令参数。其中，-I 模式与默认模式在 输入切分（tokenization / record parsing） 上存在本质差异。理解这一点，对于安全处理文件名、构造复杂命令模板以及性能优化非常关键。
本文系统整理以下问题：
使用 -I 时是否只能一行一行读取？ 是否可以自定义分隔符？ -I 与默认模式在行为与性能上的核心区别 实战建议与最佳实践 1. xargs -I 的基本语义 使用 -I 时，xargs 进入 模板替换模式（template substitution mode）：
xargs -I{} command "{}" 含义是：
对每一条输入记录，将其替换到模板中的 {} 位置，然后执行一次命令。
示例：
printf '%s ' a b c | xargs -I{} echo "item={}" # 输出： # item=a # item=b # item=c 核心特征：
每条输入 → 一次命令执行 输入内容整体保留，不再按空格拆分 适合需要把输入插入到命令中间或多处的位置 2. 是否只能"一行一行读取"？ 默认行为：按"行"读取 当启用 -I 时，xargs 默认以 换行符 (\n) 作为记录分隔符。
...</p></div><footer class=entry-footer><span title='2026-01-20 00:00:00 +0000 UTC'>January 20, 2026</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to xargs" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/xargs/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>XML 语法与工程实践：从树模型到 XPath、Namespace 与 CDATA</h2></header><div class=entry-content><p>0. 这篇文章解决什么问题 XML（eXtensible Markup Language）经常被当作“带尖括号的文本”。但在工程场景（URDF、USD/Omniverse 配置、各种工具链描述文件）里，理解 XML 的关键并不是记住几个标签写法，而是把它当成：
一棵“有序树 + 属性 + 文本”的数据结构
程序读的不是字符流，而是结构。
本文从这个树模型出发，系统整理 XML 的核心语法与常见机制：text/tail、XPath、Namespace、CDATA，并给出 Python（ElementTree）与命令行工具的可用做法。
1. Markup Language 是什么：用“标记”把文本变成结构 Markup Language（标记语言）的本质：用标签（tag）给文本加上边界、层级与语义。
&lt;robot name="taco"> &lt;link name="base_link"/> &lt;/robot> 这不是“字符串里夹标签”，而是树：
robot (name="taco") └── link (name="base_link") 标签名是“语义”，属性是“参数”，嵌套是“结构”。
因此 XML 的强项是：跨系统传递结构化语义（而不是仅仅渲染）。
2. XML 的基本语法（严格规则） XML 比 HTML 严格得多。常见约束如下：
2.1 标签必须闭合 ✅ 正确：
&lt;mesh>&lt;/mesh> &lt;mesh /> ❌ 错误：
&lt;mesh> 2.2 区分大小写 &lt;Mesh> ≠ &lt;mesh> 2.3 属性必须加引号 ✅
&lt;link name="base_link"/> ❌
&lt;link name=base_link/> 2.4 必须正确嵌套，且只有一个根节点 ✅
&lt;a>&lt;b/>&lt;/a> ❌
&lt;a>&lt;b>&lt;/a>&lt;/b> 3. Element / Attribute / Text：把 XML 当成对象模型 一个元素（Element）由：
...</p></div><footer class=entry-footer><span title='2026-01-19 00:00:00 +0000 UTC'>January 19, 2026</span>&nbsp;·&nbsp;<span>3 min</span></footer><a class=entry-link aria-label="post link to XML 语法与工程实践：从树模型到 XPath、Namespace 与 CDATA" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/xml/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>爬虫爬取淘股吧</h2></header><div class=entry-content><p>因为之前公众号封过一次，所以当时将近一个月的复盘笔记全部拿不回来了。所以又过了半年，写了一个爬虫把tgb的帖子全部爬下来。上次写爬虫还是大一的时候的课程作业。 不得不说还是有点烦的。要存state，要用devtool，要看css selector。这玩意真是纯粹的工程了。 本来还说要不要记录什么东西。后来发现，没什么好记录的，用的熟当然厉害，但是我也不是干这个的，所以记录几个关键词得了（</p></div><footer class=entry-footer><span title='2026-01-16 00:00:00 +0000 UTC'>January 16, 2026</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to 爬虫爬取淘股吧" href=https://analyst-huang.github.io/posts/%E6%9D%82%E8%B0%88/%E7%88%AC%E8%99%AB%E5%88%9D%E6%8E%A2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>利用大模型读论文</h2></header><div class=entry-content><p>之前用大模型看论文总觉得没有用对，因为效率不高，有各种繁琐的操作，并且理解的程度也不够。
今天发现，最后的拼图其实是记事本，因为模型因为system prompt或者其他的原因，可能回复的很长，如果在当前页面问某个细节，就完全打乱了思路，但是如果把问题全部记录在记事本里面，然后一下子问，反复迭代，问题就会变少，理解也会变清晰。
以及要一个一个模块问，比如说“详细介绍方法，不要漏掉一个细节”，必须一个模块一个模块过，才不会不理解，细节也不能错过。</p></div><footer class=entry-footer><span title='2026-01-13 00:00:00 +0000 UTC'>January 13, 2026</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to 利用大模型读论文" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E8%AF%BB%E8%AE%BA%E6%96%87/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>在 .bashrc 设置 LD_LIBRARY_PATH 导致 bash 提示 libtinfo.so.6: no version information available 的原因与影响</h2></header><div class=entry-content><p>现象 在 ~/.bashrc 中全局设置了类似下面的环境变量后：
export LD_LIBRARY_PATH=/home/ziye_huang/anaconda3/envs/isaacgym/lib:$LD_LIBRARY_PATH 启动新的终端或执行 /bin/bash 时会出现警告：
/home/ziye_huang/anaconda3/envs/isaacgym/lib/libtinfo.so.6: no version information available (required by /bin/bash) 这通常发生在 Conda 环境的动态库优先级 覆盖了系统库之后。
背景：bash 为什么会碰到 libtinfo bash 在很多发行版上会链接到 readline/ncurses 相关库（交互式编辑、历史记录、终端能力等）。 ncurses 的一部分拆分为 libtinfo（terminfo 数据与接口）。 因此，/bin/bash 在启动时会通过动态链接器加载 libtinfo.so.6。 关键点在于：动态链接器会按搜索顺序选择要加载的 libtinfo.so.6 的“具体文件”。
根因：LD_LIBRARY_PATH 让 bash 先加载了 Conda 里的 libtinfo 1) 动态链接器的常见搜索顺序（简化版） 通常会按优先级从高到低搜索：
LD_LIBRARY_PATH 可执行文件的 RPATH/RUNPATH（如果存在） 系统缓存 /etc/ld.so.cache 默认系统目录（如 /lib/x86_64-linux-gnu、/usr/lib/x86_64-linux-gnu 等） 你在 .bashrc 里 全局 把：
/home/ziye_huang/anaconda3/envs/isaacgym/lib 放到了 LD_LIBRARY_PATH 的最前面，使得启动 /bin/bash 时，动态链接器优先选择了 Conda 环境中的：
.../envs/isaacgym/lib/libtinfo.so.6 而不是系统自带的 libtinfo.so.6。
...</p></div><footer class=entry-footer><span title='2026-01-13 00:00:00 +0000 UTC'>January 13, 2026</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to 在 .bashrc 设置 LD_LIBRARY_PATH 导致 bash 提示 libtinfo.so.6: no version information available 的原因与影响" href=https://analyst-huang.github.io/posts/%E6%9D%82%E8%B0%88/ld_library_path_libtinfo_bash_warning/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>windows ctrl v 失效</h2></header><div class=entry-content><p>搞了半天，原来是被向日葵这个进程阻碍了剪切板的正常使用，把向日葵关掉就能正常使用了。</p></div><footer class=entry-footer><span title='2026-01-11 00:00:00 +0000 UTC'>January 11, 2026</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to windows ctrl v 失效" href=https://analyst-huang.github.io/posts/%E6%9D%82%E8%B0%88/windows_ctrl_v/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>zmq</h2></header><div class=entry-content><p>最近在做机器人遥操，所以需要在多进程之间交换数据。直接用socket来写就太底层了，所以就研究了一下封装库zmq怎么用。结果出了一个延迟的bug，特此记录zmq的用法。
ZeroMQ PUB-SUB 总结（代码导向）
一、角色职责（Role Semantics）
Publisher（PUB）
职责：只负责发送消息（广播），不接收任何数据。
import zmq ctx = zmq.Context() pub = ctx.socket(zmq.PUB) pub.bind("tcp://*:5555") while True: pub.send(b"state robot_pose=...") 特点： - 只能 send()，不能 recv() - 不知道是否有订阅者 - 不关心订阅者订了什么
Subscriber（SUB）
职责：只负责接收并按 topic 过滤消息，不发送任何数据。
import zmq ctx = zmq.Context() sub = ctx.socket(zmq.SUB) sub.connect("tcp://localhost:5555") # 订阅前缀为 b"state" 的消息 sub.setsockopt(zmq.SUBSCRIBE, b"state") while True: msg = sub.recv() print(msg) 特点： - 只能 recv()，不能 send() - 必须显式设置订阅规则 - 只能收到匹配前缀的消息
二、连接方式（Connection Pattern）
语义与 bind / connect 无关，只是部署方式不同。
...</p></div><footer class=entry-footer><span title='2026-01-11 00:00:00 +0000 UTC'>January 11, 2026</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to zmq" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/zmq/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>精神分析与社交</h2></header><div class=entry-content><p>三种读取基本幻想结构的方法（总—分结构）
目标：在最短时间内，从话语与互动中判断主体的基本幻想结构，而非停留在性格或态度层面的印象。
总论：三界协同下的幻想读取框架
在拉康理论中，基本幻想并不是内心图像，而是主体在以下三个层面上的稳定配置：
象征界（Symbolic）：主体如何获得话语与身份的合法性（大他者假设） 实在界（Real）：主体在防御哪种作为 objet petit a 的坠落位置（核心恐惧） 想象界（Imaginary）：主体如何在关系中重演并维持这一防御（互动脚本） 对应到实践中的三种读取方法：
方法一：读语言中的合法性来源（象征层） 方法二：读被遮蔽的 objet a 位置（实在层） 方法三：读关系中的角色分配（想象层） 三者共同指向同一件事：
主体如何回答“我在他者欲望中是什么”。
方法一：通过语言判断合法性来源（象征界 / 大他者假设）
核心问题
主体在说话时，默认谁拥有裁决其话语与价值的权力？
这对应的是主体对大他者位置的假设方式。
可观察信号
频繁引用：规则、制度、专家、行业共识 强调：正常人、大家都觉得、社会现实 道德化表达：应该、不应该、对与错 清醒话语：别人都被洗脑了、只有少数人明白 结构判断
通过这些线索可以判断主体：
是依附稳定的大他者（规则 / 权威） 还是依附社会共识（群体承认） 还是依附道德正当性 或是占据“去他者化”的清醒位置 该方法用于快速定位：
主体如何在象征秩序中获得自我合法性。
方法二：通过防御与贬斥判断 objet a 的恐惧位置（实在界 / 核心缺失）
核心问题
主体最无法承受自己在他者欲望中处于哪种位置？
objet petit a 在这里不作为对象，而作为：
主体可能坠入的“多余之物 / 被使用之物 / 被忽视之物”的位置。
可观察信号
对某类人或状态的高强度贬低 对某些评价极端敏感 反复自我辩护：“我其实不是那样的人” 在特定话题上情绪迅速升级 结构反推原则
通常可以进行结构翻转：
被强烈排斥的位置 ≈ 主体最恐惧坠入的位置
常见对应关系
恐惧被抛弃 → 幻想为“我被需要” 恐惧无价值 → 幻想为“我必须成功” 恐惧被看穿 → 幻想为“我更清醒 / 更掌控” 恐惧被忽视 → 幻想为“我必须占据中心” 该方法用于定位：
...</p></div><footer class=entry-footer><span title='2026-01-11 00:00:00 +0000 UTC'>January 11, 2026</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to 精神分析与社交" href=https://analyst-huang.github.io/posts/%E6%9D%82%E8%B0%88/%E7%B2%BE%E7%A5%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%A4%BE%E4%BA%A4/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://analyst-huang.github.io/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://analyst-huang.github.io/>Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>