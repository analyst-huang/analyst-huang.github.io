<!doctype html><html lang=en dir=auto data-theme=auto><head><meta name=generator content="Hugo 0.154.5"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Blog</title><meta name=description content><meta name=author content><link rel=canonical href=https://analyst-huang.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://analyst-huang.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://analyst-huang.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://analyst-huang.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://analyst-huang.github.io/apple-touch-icon.png><link rel=mask-icon href=https://analyst-huang.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://analyst-huang.github.io/index.xml title=rss><link rel=alternate type=application/json href=https://analyst-huang.github.io/index.json title=json><link rel=alternate hreflang=en href=https://analyst-huang.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\\\(",right:"\\\\)",display:!1},{left:"\\\\[",right:"\\\\]",display:!0}]})})</script><meta property="og:url" content="https://analyst-huang.github.io/"><meta property="og:site_name" content="Blog"><meta property="og:title" content="Blog"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Blog"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Blog","url":"https://analyst-huang.github.io/","description":"","logo":"https://analyst-huang.github.io/favicon.ico","sameAs":[]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://analyst-huang.github.io/ accesskey=h title="Blog (Alt + H)">Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://analyst-huang.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://analyst-huang.github.io/about/ title=关于><span>关于</span></a></li><li><a href=https://analyst-huang.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=first-entry><header class=entry-header><h2 class=entry-hint-parent>XML 语法与工程实践：从树模型到 XPath、Namespace 与 CDATA</h2></header><div class=entry-content><p>0. 这篇文章解决什么问题 XML（eXtensible Markup Language）经常被当作“带尖括号的文本”。但在工程场景（URDF、USD/Omniverse 配置、各种工具链描述文件）里，理解 XML 的关键并不是记住几个标签写法，而是把它当成：
一棵“有序树 + 属性 + 文本”的数据结构
程序读的不是字符流，而是结构。
本文从这个树模型出发，系统整理 XML 的核心语法与常见机制：text/tail、XPath、Namespace、CDATA，并给出 Python（ElementTree）与命令行工具的可用做法。
1. Markup Language 是什么：用“标记”把文本变成结构 Markup Language（标记语言）的本质：用标签（tag）给文本加上边界、层级与语义。
&lt;robot name="taco"> &lt;link name="base_link"/> &lt;/robot> 这不是“字符串里夹标签”，而是树：
robot (name="taco") └── link (name="base_link") 标签名是“语义”，属性是“参数”，嵌套是“结构”。
因此 XML 的强项是：跨系统传递结构化语义（而不是仅仅渲染）。
2. XML 的基本语法（严格规则） XML 比 HTML 严格得多。常见约束如下：
2.1 标签必须闭合 ✅ 正确：
&lt;mesh>&lt;/mesh> &lt;mesh /> ❌ 错误：
&lt;mesh> 2.2 区分大小写 &lt;Mesh> ≠ &lt;mesh> 2.3 属性必须加引号 ✅
&lt;link name="base_link"/> ❌
&lt;link name=base_link/> 2.4 必须正确嵌套，且只有一个根节点 ✅
&lt;a>&lt;b/>&lt;/a> ❌
&lt;a>&lt;b>&lt;/a>&lt;/b> 3. Element / Attribute / Text：把 XML 当成对象模型 一个元素（Element）由：
...</p></div><footer class=entry-footer><span title='2026-01-19 00:00:00 +0000 UTC'>January 19, 2026</span>&nbsp;·&nbsp;<span>3 min</span></footer><a class=entry-link aria-label="post link to XML 语法与工程实践：从树模型到 XPath、Namespace 与 CDATA" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/xml/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>爬虫爬取淘股吧</h2></header><div class=entry-content><p>因为之前公众号封过一次，所以当时将近一个月的复盘笔记全部拿不回来了。所以又过了半年，写了一个爬虫把tgb的帖子全部爬下来。上次写爬虫还是大一的时候的课程作业。 不得不说还是有点烦的。要存state，要用devtool，要看css selector。这玩意真是纯粹的工程了。 本来还说要不要记录什么东西。后来发现，没什么好记录的，用的熟当然厉害，但是我也不是干这个的，所以记录几个关键词得了（</p></div><footer class=entry-footer><span title='2026-01-16 00:00:00 +0000 UTC'>January 16, 2026</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to 爬虫爬取淘股吧" href=https://analyst-huang.github.io/posts/%E6%9D%82%E8%B0%88/%E7%88%AC%E8%99%AB%E5%88%9D%E6%8E%A2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>利用大模型读论文</h2></header><div class=entry-content><p>之前用大模型看论文总觉得没有用对，因为效率不高，有各种繁琐的操作，并且理解的程度也不够。
今天发现，最后的拼图其实是记事本，因为模型因为system prompt或者其他的原因，可能回复的很长，如果在当前页面问某个细节，就完全打乱了思路，但是如果把问题全部记录在记事本里面，然后一下子问，反复迭代，问题就会变少，理解也会变清晰。
以及要一个一个模块问，比如说“详细介绍方法，不要漏掉一个细节”，必须一个模块一个模块过，才不会不理解，细节也不能错过。</p></div><footer class=entry-footer><span title='2026-01-13 00:00:00 +0000 UTC'>January 13, 2026</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to 利用大模型读论文" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E8%AF%BB%E8%AE%BA%E6%96%87/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>在 .bashrc 设置 LD_LIBRARY_PATH 导致 bash 提示 libtinfo.so.6: no version information available 的原因与影响</h2></header><div class=entry-content><p>现象 在 ~/.bashrc 中全局设置了类似下面的环境变量后：
export LD_LIBRARY_PATH=/home/ziye_huang/anaconda3/envs/isaacgym/lib:$LD_LIBRARY_PATH 启动新的终端或执行 /bin/bash 时会出现警告：
/home/ziye_huang/anaconda3/envs/isaacgym/lib/libtinfo.so.6: no version information available (required by /bin/bash) 这通常发生在 Conda 环境的动态库优先级 覆盖了系统库之后。
背景：bash 为什么会碰到 libtinfo bash 在很多发行版上会链接到 readline/ncurses 相关库（交互式编辑、历史记录、终端能力等）。 ncurses 的一部分拆分为 libtinfo（terminfo 数据与接口）。 因此，/bin/bash 在启动时会通过动态链接器加载 libtinfo.so.6。 关键点在于：动态链接器会按搜索顺序选择要加载的 libtinfo.so.6 的“具体文件”。
根因：LD_LIBRARY_PATH 让 bash 先加载了 Conda 里的 libtinfo 1) 动态链接器的常见搜索顺序（简化版） 通常会按优先级从高到低搜索：
LD_LIBRARY_PATH 可执行文件的 RPATH/RUNPATH（如果存在） 系统缓存 /etc/ld.so.cache 默认系统目录（如 /lib/x86_64-linux-gnu、/usr/lib/x86_64-linux-gnu 等） 你在 .bashrc 里 全局 把：
/home/ziye_huang/anaconda3/envs/isaacgym/lib 放到了 LD_LIBRARY_PATH 的最前面，使得启动 /bin/bash 时，动态链接器优先选择了 Conda 环境中的：
.../envs/isaacgym/lib/libtinfo.so.6 而不是系统自带的 libtinfo.so.6。
...</p></div><footer class=entry-footer><span title='2026-01-13 00:00:00 +0000 UTC'>January 13, 2026</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to 在 .bashrc 设置 LD_LIBRARY_PATH 导致 bash 提示 libtinfo.so.6: no version information available 的原因与影响" href=https://analyst-huang.github.io/posts/%E6%9D%82%E8%B0%88/ld_library_path_libtinfo_bash_warning/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>windows ctrl v 失效</h2></header><div class=entry-content><p>搞了半天，原来是被向日葵这个进程阻碍了剪切板的正常使用，把向日葵关掉就能正常使用了。</p></div><footer class=entry-footer><span title='2026-01-11 00:00:00 +0000 UTC'>January 11, 2026</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to windows ctrl v 失效" href=https://analyst-huang.github.io/posts/%E6%9D%82%E8%B0%88/windows_ctrl_v/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>zmq</h2></header><div class=entry-content><p>最近在做机器人遥操，所以需要在多进程之间交换数据。直接用socket来写就太底层了，所以就研究了一下封装库zmq怎么用。结果出了一个延迟的bug，特此记录zmq的用法。
ZeroMQ PUB-SUB 总结（代码导向）
一、角色职责（Role Semantics）
Publisher（PUB）
职责：只负责发送消息（广播），不接收任何数据。
import zmq ctx = zmq.Context() pub = ctx.socket(zmq.PUB) pub.bind("tcp://*:5555") while True: pub.send(b"state robot_pose=...") 特点： - 只能 send()，不能 recv() - 不知道是否有订阅者 - 不关心订阅者订了什么
Subscriber（SUB）
职责：只负责接收并按 topic 过滤消息，不发送任何数据。
import zmq ctx = zmq.Context() sub = ctx.socket(zmq.SUB) sub.connect("tcp://localhost:5555") # 订阅前缀为 b"state" 的消息 sub.setsockopt(zmq.SUBSCRIBE, b"state") while True: msg = sub.recv() print(msg) 特点： - 只能 recv()，不能 send() - 必须显式设置订阅规则 - 只能收到匹配前缀的消息
二、连接方式（Connection Pattern）
语义与 bind / connect 无关，只是部署方式不同。
...</p></div><footer class=entry-footer><span title='2026-01-11 00:00:00 +0000 UTC'>January 11, 2026</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to zmq" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/zmq/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>精神分析与社交</h2></header><div class=entry-content><p>三种读取基本幻想结构的方法（总—分结构）
目标：在最短时间内，从话语与互动中判断主体的基本幻想结构，而非停留在性格或态度层面的印象。
总论：三界协同下的幻想读取框架
在拉康理论中，基本幻想并不是内心图像，而是主体在以下三个层面上的稳定配置：
象征界（Symbolic）：主体如何获得话语与身份的合法性（大他者假设） 实在界（Real）：主体在防御哪种作为 objet petit a 的坠落位置（核心恐惧） 想象界（Imaginary）：主体如何在关系中重演并维持这一防御（互动脚本） 对应到实践中的三种读取方法：
方法一：读语言中的合法性来源（象征层） 方法二：读被遮蔽的 objet a 位置（实在层） 方法三：读关系中的角色分配（想象层） 三者共同指向同一件事：
主体如何回答“我在他者欲望中是什么”。
方法一：通过语言判断合法性来源（象征界 / 大他者假设）
核心问题
主体在说话时，默认谁拥有裁决其话语与价值的权力？
这对应的是主体对大他者位置的假设方式。
可观察信号
频繁引用：规则、制度、专家、行业共识 强调：正常人、大家都觉得、社会现实 道德化表达：应该、不应该、对与错 清醒话语：别人都被洗脑了、只有少数人明白 结构判断
通过这些线索可以判断主体：
是依附稳定的大他者（规则 / 权威） 还是依附社会共识（群体承认） 还是依附道德正当性 或是占据“去他者化”的清醒位置 该方法用于快速定位：
主体如何在象征秩序中获得自我合法性。
方法二：通过防御与贬斥判断 objet a 的恐惧位置（实在界 / 核心缺失）
核心问题
主体最无法承受自己在他者欲望中处于哪种位置？
objet petit a 在这里不作为对象，而作为：
主体可能坠入的“多余之物 / 被使用之物 / 被忽视之物”的位置。
可观察信号
对某类人或状态的高强度贬低 对某些评价极端敏感 反复自我辩护：“我其实不是那样的人” 在特定话题上情绪迅速升级 结构反推原则
通常可以进行结构翻转：
被强烈排斥的位置 ≈ 主体最恐惧坠入的位置
常见对应关系
恐惧被抛弃 → 幻想为“我被需要” 恐惧无价值 → 幻想为“我必须成功” 恐惧被看穿 → 幻想为“我更清醒 / 更掌控” 恐惧被忽视 → 幻想为“我必须占据中心” 该方法用于定位：
...</p></div><footer class=entry-footer><span title='2026-01-11 00:00:00 +0000 UTC'>January 11, 2026</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to 精神分析与社交" href=https://analyst-huang.github.io/posts/%E6%9D%82%E8%B0%88/%E7%B2%BE%E7%A5%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%A4%BE%E4%BA%A4/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>配置RSS reader</h2></header><div class=entry-content><p>Feed 与 RSS：从信息推送到个人信息流的技术基础
本文从工程与使用两个层面，系统性介绍： 1. Feed 与 RSS 的概念与格式 2. RSS Reader 的实际好处 3. 如何将邮件转换为 RSS 4. 如何导出与迁移 OPML 配置
适合希望构建个人信息流管道（personal information pipeline）的技术用户。
Feed 与 RSS 1.1 什么是 Feed
Feed 是一种“可被机器订阅的更新流”，本质是： - 按时间排序的条目（items / entries） - 每条包含：标题、链接、摘要、发布时间等元数据 - 客户端可以周期性拉取并增量更新
Feed 是概念层；RSS / Atom 是实现层的具体协议格式。
1.2 一个最小 RSS 结构
&lt;rss version="2.0"> &lt;channel> &lt;title>Example Feed&lt;/title> &lt;link>https://example.com&lt;/link> &lt;item> &lt;title>Post Title&lt;/title> &lt;link>https://example.com/post&lt;/link> &lt;pubDate>Mon, 12 Jan 2026 12:00:00 GMT&lt;/pubDate> &lt;description>Summary...&lt;/description> &lt;/item> &lt;/channel> &lt;/rss> RSS Reader 的工作本质是： - 周期性 GET - 解析 XML - 去重 - 按时间排序展示
...</p></div><footer class=entry-footer><span title='2026-01-11 00:00:00 +0000 UTC'>January 11, 2026</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to 配置RSS reader" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/rss_reader/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Socket</h2></header><div class=entry-content><p>进程、内核与 Socket：通信机制要点 一、每个进程都有哪些是“独立的”？ 每个进程有独立的：
虚拟地址空间 寄存器上下文 内核用时间片轮转在同一颗物理 CPU 上切换它们。
但有一件事是不虚拟的：
所有进程共享同一个操作系统内核。
而 socket 属于：
内核对象（kernel object） 当你在用户态调用：
sock.send(...) 实际上发生的是：
触发系统调用（syscall） CPU 切到内核态 内核代表你这个进程去执行真正的发送逻辑 所以通信的“公共场所”不是 CPU，而是：
内核里的网络协议栈 + 内核缓冲区
二、Socket 在内核里到底是什么？ 从内核视角看，一个 socket 大致包含：
socket 结构体 接收缓冲区（recv buffer） 发送缓冲区（send buffer） 协议状态机（TCP 状态、序列号等） 每个进程持有的其实只是：
一个文件描述符 fd → 指向内核里的 socket 对象
所以：
两个进程可以分别持有：
指向同一个 socket 对象的 fd（例如通过 fork 继承） 或一对互相关联的 socket（TCP 连接两端） Socket 与 TCP 出现之前的通信历史（极简时间线） 一、最早期：只有物理通信（无协议） 串口、并口、专用总线 直接发送电信号 特点： 无地址 无连接 无可靠性 本质：硬件层通信，没有操作系统抽象 二、分组交换网络：只有“包”，没有“连接” ARPANET / 早期 IP 思想 通信模型： send(packet) 网络尽力投递 特点： 无连接 可能丢包 / 乱序 / 重复 接近今天的：IP / UDP 语义 三、应用自己实现可靠性（应用层协议时代） FTP / Telnet 等早期协议 每个应用自己实现： 序号 ACK 重传 流控 问题： 重复造轮子 质量不可控 网络整体容易拥塞 四、TCP 的出现：把“可靠流”下沉到内核 TCP 抽象： 可靠 有序 字节流 协议状态必须长期维护： 状态机 缓冲区 拥塞控制 结果： 状态进入操作系统内核 通信关系成为内核对象 五、Socket 的诞生：进程访问内核协议栈的统一接口 BSD Unix 引入 socket API 设计目标： 用 fd 表示通信端点 统一 TCP / UDP / 本地域通信 本质： socket = 协议状态 + 缓冲区 + 控制逻辑 的内核对象 一句话总结 TCP 之前：
→ 要么无连接无可靠性（只发包）
→ 要么可靠性由应用自己实现
...</p></div><footer class=entry-footer><span title='2026-01-09 00:00:00 +0000 UTC'>January 9, 2026</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to Socket" href=https://analyst-huang.github.io/posts/system/socket/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DexMachina and Deus ex machina</h2></header><div class=entry-content><p>在Google Scholar搜索DexMachina的时候，发现好几篇署名缩写是“Dex Machina”的文章，各种语言的都有，所以发现了一个有趣的关于 Deus Ex Machina的知识。
(generated by chatgpt)
Deus Ex Machina 作为署名与修辞：一则19世纪期刊中的机械音乐评论 起点：在一篇 19 世纪音乐期刊短文《Mechanical Music》文末，作者署名为 “Deus ex machina”。这并不是一个人的名字，而是一种极具历史意味的修辞性署名。
一、Deus ex machina：从舞台装置到叙事术语 Deus ex machina 是拉丁语短语，字面意思是“从机器中降下的神”。它来自古希腊戏剧的舞台实践：
当剧情陷入无解困境时， 通过机械装置（machina）把扮演神的演员吊到舞台上， 由“神”直接裁决冲突、给出结局。 从亚里士多德开始，这种做法就被视为一种叙事上的取巧手段：不是从情节内在因果推出结局，而是引入外在权威强行收束。
因此在现代叙事学中，deus ex machina 通常带有负面或讽刺意味：
指突兀的外力解决方案 指不由人物行动或情节逻辑自然导出的结局 二、为什么会被用作“署名” 在 19 世纪期刊文化中，尤其是评论、随笔、短评栏目里，使用假名、拉丁短语或概念性署名非常常见。目的通常不是隐藏身份，而是：
标记文本体裁：提示读者这是观点性、讽刺性或机智短评 制造修辞效果：署名本身就是文章的一部分 弱化作者个体性：强调观点而非作者权威 常见的类似署名包括：
拉丁格言 神话人物 抽象概念（如 Truth, Observer, Spectator 等） 在这种传统下，“Deus ex machina”更像是一个带立场的栏目签名，而非真实作者。
三、与“Mechanical Music”的语义互文 在讨论**机械音乐（Mechanical Music）**时使用“Deus ex machina”署名，本身构成了一层明显的语义叠加：
machina 同时指舞台机械装置 也指工业时代的物理机器 这使得署名产生双重讽刺效果：
一方面指向戏剧中“靠机器把神吊下来解决问题”的老套路 另一方面暗示现代社会中“靠机器解决艺术与情感问题”的幻想 在 19 世纪末期，自动演奏装置（音乐盒、自动钢琴、风琴机械系统等）迅速普及，评论界普遍存在以下张力：
...</p></div><footer class=entry-footer><span title='2026-01-08 00:00:00 +0000 UTC'>January 8, 2026</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to DexMachina and Deus ex machina" href=https://analyst-huang.github.io/posts/%E6%9D%82%E8%B0%88/dexmachina/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://analyst-huang.github.io/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://analyst-huang.github.io/>Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>