<!doctype html><html lang=en dir=auto data-theme=auto><head><meta name=generator content="Hugo 0.154.5"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Blog</title><meta name=description content><meta name=author content><link rel=canonical href=https://analyst-huang.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://analyst-huang.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://analyst-huang.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://analyst-huang.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://analyst-huang.github.io/apple-touch-icon.png><link rel=mask-icon href=https://analyst-huang.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://analyst-huang.github.io/index.xml title=rss><link rel=alternate type=application/json href=https://analyst-huang.github.io/index.json title=json><link rel=alternate hreflang=en href=https://analyst-huang.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\\\(",right:"\\\\)",display:!1},{left:"\\\\[",right:"\\\\]",display:!0}]})})</script><meta property="og:url" content="https://analyst-huang.github.io/"><meta property="og:site_name" content="Blog"><meta property="og:title" content="Blog"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Blog"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Blog","url":"https://analyst-huang.github.io/","description":"","logo":"https://analyst-huang.github.io/favicon.ico","sameAs":[]}</script></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://analyst-huang.github.io/ accesskey=h title="Blog (Alt + H)">Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://analyst-huang.github.io/posts/ title=文章><span>文章</span></a></li><li><a href=https://analyst-huang.github.io/about/ title=关于><span>关于</span></a></li><li><a href=https://analyst-huang.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>精神分析与社交</h2></header><div class=entry-content><p>三种读取基本幻想结构的方法（总—分结构）
目标：在最短时间内，从话语与互动中判断主体的基本幻想结构，而非停留在性格或态度层面的印象。
总论：三界协同下的幻想读取框架
在拉康理论中，基本幻想并不是内心图像，而是主体在以下三个层面上的稳定配置：
象征界（Symbolic）：主体如何获得话语与身份的合法性（大他者假设） 实在界（Real）：主体在防御哪种作为 objet petit a 的坠落位置（核心恐惧） 想象界（Imaginary）：主体如何在关系中重演并维持这一防御（互动脚本） 对应到实践中的三种读取方法：
方法一：读语言中的合法性来源（象征层） 方法二：读被遮蔽的 objet a 位置（实在层） 方法三：读关系中的角色分配（想象层） 三者共同指向同一件事：
主体如何回答“我在他者欲望中是什么”。
方法一：通过语言判断合法性来源（象征界 / 大他者假设）
核心问题
主体在说话时，默认谁拥有裁决其话语与价值的权力？
这对应的是主体对大他者位置的假设方式。
可观察信号
频繁引用：规则、制度、专家、行业共识 强调：正常人、大家都觉得、社会现实 道德化表达：应该、不应该、对与错 清醒话语：别人都被洗脑了、只有少数人明白 结构判断
通过这些线索可以判断主体：
是依附稳定的大他者（规则 / 权威） 还是依附社会共识（群体承认） 还是依附道德正当性 或是占据“去他者化”的清醒位置 该方法用于快速定位：
主体如何在象征秩序中获得自我合法性。
方法二：通过防御与贬斥判断 objet a 的恐惧位置（实在界 / 核心缺失）
核心问题
主体最无法承受自己在他者欲望中处于哪种位置？
objet petit a 在这里不作为对象，而作为：
主体可能坠入的“多余之物 / 被使用之物 / 被忽视之物”的位置。
可观察信号
对某类人或状态的高强度贬低 对某些评价极端敏感 反复自我辩护：“我其实不是那样的人” 在特定话题上情绪迅速升级 结构反推原则
通常可以进行结构翻转：
被强烈排斥的位置 ≈ 主体最恐惧坠入的位置
常见对应关系
恐惧被抛弃 → 幻想为“我被需要” 恐惧无价值 → 幻想为“我必须成功” 恐惧被看穿 → 幻想为“我更清醒 / 更掌控” 恐惧被忽视 → 幻想为“我必须占据中心” 该方法用于定位：
...</p></div><footer class=entry-footer><span title='2026-01-11 00:00:00 +0000 UTC'>January 11, 2026</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to 精神分析与社交" href=https://analyst-huang.github.io/posts/%E6%9D%82%E8%B0%88/%E7%B2%BE%E7%A5%9E%E5%88%86%E6%9E%90%E4%B8%8E%E7%A4%BE%E4%BA%A4/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>配置RSS reader</h2></header><div class=entry-content><p>Feed 与 RSS：从信息推送到个人信息流的技术基础
本文从工程与使用两个层面，系统性介绍： 1. Feed 与 RSS 的概念与格式 2. RSS Reader 的实际好处 3. 如何将邮件转换为 RSS 4. 如何导出与迁移 OPML 配置
适合希望构建个人信息流管道（personal information pipeline）的技术用户。
Feed 与 RSS 1.1 什么是 Feed
Feed 是一种“可被机器订阅的更新流”，本质是： - 按时间排序的条目（items / entries） - 每条包含：标题、链接、摘要、发布时间等元数据 - 客户端可以周期性拉取并增量更新
Feed 是概念层；RSS / Atom 是实现层的具体协议格式。
1.2 一个最小 RSS 结构
&lt;rss version="2.0"> &lt;channel> &lt;title>Example Feed&lt;/title> &lt;link>https://example.com&lt;/link> &lt;item> &lt;title>Post Title&lt;/title> &lt;link>https://example.com/post&lt;/link> &lt;pubDate>Mon, 12 Jan 2026 12:00:00 GMT&lt;/pubDate> &lt;description>Summary...&lt;/description> &lt;/item> &lt;/channel> &lt;/rss> RSS Reader 的工作本质是： - 周期性 GET - 解析 XML - 去重 - 按时间排序展示
...</p></div><footer class=entry-footer><span title='2026-01-11 00:00:00 +0000 UTC'>January 11, 2026</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to 配置RSS reader" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/rss_reader/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Socket</h2></header><div class=entry-content><p>进程、内核与 Socket：通信机制要点 一、每个进程都有哪些是“独立的”？ 每个进程有独立的：
虚拟地址空间 寄存器上下文 内核用时间片轮转在同一颗物理 CPU 上切换它们。
但有一件事是不虚拟的：
所有进程共享同一个操作系统内核。
而 socket 属于：
内核对象（kernel object） 当你在用户态调用：
sock.send(...) 实际上发生的是：
触发系统调用（syscall） CPU 切到内核态 内核代表你这个进程去执行真正的发送逻辑 所以通信的“公共场所”不是 CPU，而是：
内核里的网络协议栈 + 内核缓冲区
二、Socket 在内核里到底是什么？ 从内核视角看，一个 socket 大致包含：
socket 结构体 接收缓冲区（recv buffer） 发送缓冲区（send buffer） 协议状态机（TCP 状态、序列号等） 每个进程持有的其实只是：
一个文件描述符 fd → 指向内核里的 socket 对象
所以：
两个进程可以分别持有：
指向同一个 socket 对象的 fd（例如通过 fork 继承） 或一对互相关联的 socket（TCP 连接两端） Socket 与 TCP 出现之前的通信历史（极简时间线） 一、最早期：只有物理通信（无协议） 串口、并口、专用总线 直接发送电信号 特点： 无地址 无连接 无可靠性 本质：硬件层通信，没有操作系统抽象 二、分组交换网络：只有“包”，没有“连接” ARPANET / 早期 IP 思想 通信模型： send(packet) 网络尽力投递 特点： 无连接 可能丢包 / 乱序 / 重复 接近今天的：IP / UDP 语义 三、应用自己实现可靠性（应用层协议时代） FTP / Telnet 等早期协议 每个应用自己实现： 序号 ACK 重传 流控 问题： 重复造轮子 质量不可控 网络整体容易拥塞 四、TCP 的出现：把“可靠流”下沉到内核 TCP 抽象： 可靠 有序 字节流 协议状态必须长期维护： 状态机 缓冲区 拥塞控制 结果： 状态进入操作系统内核 通信关系成为内核对象 五、Socket 的诞生：进程访问内核协议栈的统一接口 BSD Unix 引入 socket API 设计目标： 用 fd 表示通信端点 统一 TCP / UDP / 本地域通信 本质： socket = 协议状态 + 缓冲区 + 控制逻辑 的内核对象 一句话总结 TCP 之前：
→ 要么无连接无可靠性（只发包）
→ 要么可靠性由应用自己实现
...</p></div><footer class=entry-footer><span title='2026-01-09 00:00:00 +0000 UTC'>January 9, 2026</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to Socket" href=https://analyst-huang.github.io/posts/system/socket/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>DexMachina and Deus ex machina</h2></header><div class=entry-content><p>在Google Scholar搜索DexMachina的时候，发现好几篇署名缩写是“Dex Machina”的文章，各种语言的都有，所以发现了一个有趣的关于 Deus Ex Machina的知识。
(generated by chatgpt)
Deus Ex Machina 作为署名与修辞：一则19世纪期刊中的机械音乐评论 起点：在一篇 19 世纪音乐期刊短文《Mechanical Music》文末，作者署名为 “Deus ex machina”。这并不是一个人的名字，而是一种极具历史意味的修辞性署名。
一、Deus ex machina：从舞台装置到叙事术语 Deus ex machina 是拉丁语短语，字面意思是“从机器中降下的神”。它来自古希腊戏剧的舞台实践：
当剧情陷入无解困境时， 通过机械装置（machina）把扮演神的演员吊到舞台上， 由“神”直接裁决冲突、给出结局。 从亚里士多德开始，这种做法就被视为一种叙事上的取巧手段：不是从情节内在因果推出结局，而是引入外在权威强行收束。
因此在现代叙事学中，deus ex machina 通常带有负面或讽刺意味：
指突兀的外力解决方案 指不由人物行动或情节逻辑自然导出的结局 二、为什么会被用作“署名” 在 19 世纪期刊文化中，尤其是评论、随笔、短评栏目里，使用假名、拉丁短语或概念性署名非常常见。目的通常不是隐藏身份，而是：
标记文本体裁：提示读者这是观点性、讽刺性或机智短评 制造修辞效果：署名本身就是文章的一部分 弱化作者个体性：强调观点而非作者权威 常见的类似署名包括：
拉丁格言 神话人物 抽象概念（如 Truth, Observer, Spectator 等） 在这种传统下，“Deus ex machina”更像是一个带立场的栏目签名，而非真实作者。
三、与“Mechanical Music”的语义互文 在讨论**机械音乐（Mechanical Music）**时使用“Deus ex machina”署名，本身构成了一层明显的语义叠加：
machina 同时指舞台机械装置 也指工业时代的物理机器 这使得署名产生双重讽刺效果：
一方面指向戏剧中“靠机器把神吊下来解决问题”的老套路 另一方面暗示现代社会中“靠机器解决艺术与情感问题”的幻想 在 19 世纪末期，自动演奏装置（音乐盒、自动钢琴、风琴机械系统等）迅速普及，评论界普遍存在以下张力：
...</p></div><footer class=entry-footer><span title='2026-01-08 00:00:00 +0000 UTC'>January 8, 2026</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to DexMachina and Deus ex machina" href=https://analyst-huang.github.io/posts/%E6%9D%82%E8%B0%88/dexmachina/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Diffusion</h2></header><div class=entry-content><p>t步加噪可以写成如下形式：
$x_t = \sqrt{\bar{\alpha}_t}\, x_0 + \sqrt{1 - \bar{\alpha}_t}\, \varepsilon,\quad \varepsilon \sim \mathcal{N}(0, I)$ 其中：
$\alpha_t = 1 - \beta_t,\quad \bar{\alpha}_t = \prod_{s=1}^{t} \alpha_s, \alpha_t \in [0,1] $ 二、严格推导：用贝叶斯公式（forward 后验） 1) 概率图结构与贝叶斯展开 从概率图（forward 链）： $ x_0 \rightarrow x_{t-1} \rightarrow x_t $ 由贝叶斯公式： $ q(x_{t-1}\mid x_t, x_0) = \frac{q(x_t\mid x_{t-1}, x_0)\,q(x_{t-1}\mid x_0)}{q(x_t\mid x_0)}. $ 由于 forward 过程的马尔可夫性： $ q(x_t\mid x_{t-1}, x_0)=q(x_t\mid x_{t-1}), $ 因此： $ q(x_{t-1}\mid x_t, x_0) = \frac{q(x_t\mid x_{t-1})\,q(x_{t-1}\mid x_0)}{q(x_t\mid x_0)}. $ ...</p></div><footer class=entry-footer><span title='2026-01-08 00:00:00 +0000 UTC'>January 8, 2026</span>&nbsp;·&nbsp;<span>4 min</span></footer><a class=entry-link aria-label="post link to Diffusion" href=https://analyst-huang.github.io/posts/ai/diffusion/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>uv</h2></header><div class=entry-content><p>最近又在配一个环境，所以想到了之前被同事推荐过的uv。因为发现在conda环境中也可以用，而且比pip快很多，所以记录一下uv的用法。
看了一下，发现和科研需求并没有那么重合，记录一下和GPT的几个问题：
Conda vs uv：科研工作流下依赖管理的真实差异（Q&amp;A） 面向读者：长期使用 conda + pip 的科研/工程混合用户（如深度学习、机器人、CUDA 相关项目），在接触 uv / poetry 等“项目化依赖管理工具”时感到困惑的人。
Q1：我一直用 conda 建环境 + pip / conda install 装包，这样有什么问题吗？ A：没有问题，而且这是科研圈的主流做法。
你的典型流程是：
conda create -n xxx python=3.10 conda activate xxx pip install ... 或 conda install ... 稳定后：conda env export > env.yaml 这个流程的特点是：
环境层面高度可控 CUDA / PyTorch / 编译依赖更容易处理 适合频繁试错和快速实验 在深度学习与机器人领域，这种方式依然是现实最优解之一。
Q2：那 uv 到底在解决什么问题？为什么工程界很推它？ A：uv 的核心目标不是“更好地装包”，而是“让项目自带可复现环境定义”。
uv 想解决的是这些问题：
clone 一个 repo 后，一条命令就能得到一致环境 CI / 多人协作环境一致 依赖升级过程可审计、可回滚 因此它强调：
...</p></div><footer class=entry-footer><span title='2026-01-08 00:00:00 +0000 UTC'>January 8, 2026</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to uv" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/uv/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Codex</h2></header><div class=entry-content><p>由于最近发现Codex非常好用，并且众多业界大牛一起指出Vibe Coding是未来的趋势，所以系统学习一下Codex。或许人类真的已经来到了理解复杂系统的时候了。
感觉总体来说使用方法是相当自然的，唯一需要注意的是最近新增加的skill功能。原来是anthropic提出的标准，现在被大量采纳，估计会是一个会持续很多年的标准，值得学习。
Agent Skills 基本格式 官网与完整规范：https://agentskills.io/
1) 目录结构 一个 Skill 就是一个文件夹，至少包含一个 SKILL.md：
skill-name/ └── SKILL.md 可选：
scripts/：可执行脚本 references/：参考文档 assets/：模板或资源 2) SKILL.md 格式 SKILL.md 分为两部分：
(A) YAML Frontmatter（必需） --- name: skill-name description: 该技能做什么，以及在什么情况下使用 --- 约束：
name 必须与文件夹名一致 仅允许小写字母、数字、连字符 - 1–64 字符，不能以 - 开头或结尾，不能有连续 -- description 为 1–1024 字符 (B) Markdown 正文（指令内容） Frontmatter 之后是普通 Markdown，用来写操作步骤、示例、注意事项等，结构不强制。
3) 最小示例 --- name: pdf-processing description: 提取 PDF 文本与表格，用于后续分析或填表。 --- # PDF Processing ## When to use 当用户需要处理 PDF 文件时。 ## Procedure 1. 读取 PDF 2. 提取文本与表格 3. 输出结构化结果 这就是 Agent Skill 的基本格式。更多细节见官网：https://agentskills.io/
...</p></div><footer class=entry-footer><span title='2026-01-07 00:00:00 +0000 UTC'>January 7, 2026</span>&nbsp;·&nbsp;<span>3 min</span></footer><a class=entry-link aria-label="post link to Codex" href=https://analyst-huang.github.io/posts/%E5%A6%99%E5%A6%99%E5%B7%A5%E5%85%B7/codex/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>PPO调参手册</h2></header><div class=entry-content><p>网络的大小对训练和收敛的速度有极大的影响 很多时候[256, 256]就已经足够</p></div><footer class=entry-footer><span title='2026-01-03 00:00:00 +0000 UTC'>January 3, 2026</span>&nbsp;·&nbsp;<span>1 min</span></footer><a class=entry-link aria-label="post link to PPO调参手册" href=https://analyst-huang.github.io/posts/ai/ppo%E8%B0%83%E5%8F%82%E6%89%8B%E5%86%8C/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ELBO：证据、隐变量与变分下界的统一视角</h2></header><div class=entry-content><p>ELBO：证据、隐变量与变分下界的统一视角 本文给出一个可重复推导、可迁移到多种 AI 场景（VAE、世界模型、序列潜变量模型、变分推断等）的 ELBO（Evidence Lower Bound）理解框架。核心主线是：
训练目标始终是最大化 证据（边缘似然）。 隐变量不是深度学习才有的“工程拆解”，而是统计建模与推断的长期核心工具；ELBO 则是经典“下界化 + 可优化”范式的现代实现。 ELBO 中显式出现的先验 KL 与“逼近真实后验”的 KL 并不矛盾：前者是目标函数的结构项，后者是 ELBO 与证据之间的缺口（gap）。 1. “证据”到底是什么 给定观测数据 $x$ 与生成模型参数 $\theta$，所谓 **证据（evidence）**是数据在模型下出现的概率： $p_\theta(x)$
它也常被称为 边缘似然（marginal likelihood）、模型证据（model evidence）。当模型含潜变量 $z$ 时，证据是对潜变量积分（或求和）后的量：
$p_\theta(x)=\int p_\theta(x,z)\,dz$ 如果进一步将联合分布写成“先验 + 条件似然”的形式：
$p_\theta(x,z)=p_\theta(x\mid z)\,p(z)$ 则证据变为：
$p_\theta(x)=\int p_\theta(x\mid z)\,p(z)\,dz$ 这句话的统计含义非常直接：模型整体（在不知道真实潜变量的情况下）生成 $x$ 的能力。在贝叶斯公式中，它是后验归一化因子：
$p_\theta(z\mid x)=\frac{p_\theta(x\mid z)p(z)}{p_\theta(x)}$ 因此，“证据”并不是某个特定解释 $z^*$ 的质量，而是所有可能解释对 $x$ 的总体支持度。
2. 隐变量在统计中的地位：不是工程权宜，而是核心范式 隐变量（latent variables）在统计中长期处于中心位置，原因主要有两类：
...</p></div><footer class=entry-footer><span title='2026-01-02 00:00:00 +0000 UTC'>January 2, 2026</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to ELBO：证据、隐变量与变分下界的统一视角" href=https://analyst-huang.github.io/posts/ai/elbo/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>PPO：策略梯度、重要性采样与 Clip</h2></header><div class=entry-content><p>PPO 中的策略梯度、重要性采样与概率密度比 从策略梯度定理出发，经由重要性采样与“对梯度的不定积分”，理解 PPO 的 surrogate objective 与 Clip 机制。
1. 策略梯度定理：起点而不是终点 策略梯度定理给出的是梯度形式，而不是一个可直接优化的损失函数：
$$ \nabla_\theta J(\theta) = \mathbb E_{\pi_\theta} \big[ \nabla_\theta \log \pi_\theta(a_t\mid s_t), A^\pi(s_t,a_t) \big]. $$ 这一定理说明了：
梯度方向由 $ \nabla_\theta \log \pi $决定； 学习信号由优势函数 $A$ 提供； 它本质上是 on-policy 的结论。 但工程上我们并不是直接“写梯度”，而是希望：
构造一个目标函数 $L(\theta)$，使其梯度自动给出合理的策略更新。
这正是 PPO / TRPO 所做的事情。
2. 从 on-policy 到 off-policy：重要性采样的引入 在实践中：
rollout 使用的是旧策略 $ \pi_{\text{old}} $； 更新时参数已经变为 $ \pi_\theta $。 于是需要通过重要性采样来修正期望的测度：
$$ \mathbb E_{\pi_\theta}[f(s,a)] = \mathbb E_{\pi_{\text{old}}} \left[ \frac{\pi_\theta(a\mid s)}{\pi_{\text{old}}(a\mid s)} f(s,a) \right]. $$ 定义重要性采样率（概率比 / 密度比）：
...</p></div><footer class=entry-footer><span title='2025-12-31 00:00:00 +0000 UTC'>December 31, 2025</span>&nbsp;·&nbsp;<span>2 min</span></footer><a class=entry-link aria-label="post link to PPO：策略梯度、重要性采样与 Clip" href=https://analyst-huang.github.io/posts/ai/ppo/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://analyst-huang.github.io/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://analyst-huang.github.io/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://analyst-huang.github.io/>Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>