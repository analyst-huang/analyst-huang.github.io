Python 中的 pickle：对象序列化的原理与使用

在 Python 中，pickle
是标准库提供的一种对象序列化（serialization）与反序列化（deserialization）机制。它可以将内存中的
Python
对象转换为字节流保存到文件或通过网络传输，并在之后将这些字节流还原为等价的
Python 对象。

本文将从概念、使用方式、工作机制、常见问题与安全性等方面系统介绍
pickle。

------------------------------------------------------------------------

一、什么是序列化？

程序运行时的对象存在于内存中，包含复杂的结构与指针关系，例如嵌套的列表、字典、对象之间的引用等。这些结构：

-   依赖进程内存地址
-   不能直接写入磁盘
-   不能直接通过网络发送

序列化的目标，就是把这种 **“对象图结构”** 转换为：

  一段连续的字节序列（byte stream）

这样才能：

-   写入文件
-   通过 socket 发送
-   作为缓存保存

反过来，从字节流恢复对象结构的过程称为反序列化。

------------------------------------------------------------------------

二、pickle 的基本用法

1. 序列化到文件

    import pickle

    data = {"a": 1, "b": [1, 2, 3]}

    with open("data.pkl", "wb") as f:
        pickle.dump(data, f)

注意：必须使用二进制模式 "wb"。

------------------------------------------------------------------------

2. 从文件反序列化

    with open("data.pkl", "rb") as f:
        data2 = pickle.load(f)

    print(data2)

同样必须使用 "rb" 二进制模式，否则会出现 UnicodeDecodeError。

------------------------------------------------------------------------

3. 直接在内存中序列化

    bytes_data = pickle.dumps(data)
    data3 = pickle.loads(bytes_data)

适用于：

-   网络通信
-   内存缓存
-   IPC 场景

------------------------------------------------------------------------

三、pickle 能保存哪些对象？

可以保存

-   基本类型：int, float, str, bool
-   容器：list, tuple, dict, set
-   自定义类的实例
-   多层匌套结构
-   对象之间的共享引用关系

例如：

    a = []
    b = [a, a]

反序列化后仍然保持两个元素指向同一个对象。

------------------------------------------------------------------------

有限制或不能保存

-   打开的文件句柄
-   socket
-   线程锁
-   生成器 / 协程
-   依赖底层 C 状态的对象

这些对象依赖当前进程运行环境，无法在另一个进程中恢复语义。

------------------------------------------------------------------------

四、pickle 是如何记录自定义对象的？

当 pickle 保存一个类实例时，并 **不会保存类的代码** ，而是保存：

-   类所在模块路径
-   类名
-   实例的内部状态（通常是 __dict__）

例如：

    from mypkg.mymodule import MyClass
    obj = MyClass(10)

pickle 中实际记录的是类似：

    mypkg.mymodule.MyClass
    state = {...}

反序列化时，解释器会：

1.  import 对应模块
2.  找到类定义
3.  创建实例
4.  恢复其内部状态

因此，如果：

-   模块路径变化
-   类名变化
-   类被删除

都会导致反序列化失败。

------------------------------------------------------------------------

五、协议版本（protocol）

pickle 支持多种协议版本：

    pickle.dump(obj, f, protocol=pickle.HIGHEST_PROTOCOL)

协议影响：

-   编码方式
-   文件大小
-   序列化速度
-   向后兼容性

一般建议：

-   新项目使用 HIGHEST_PROTOCOL
-   需要兼容旧 Python 版本时指定较低协议

------------------------------------------------------------------------

六、与 JSON 等格式的对比

  特性               pickle   JSON
  ------------------ -------- ------
  是否保存类型信息   是       否
  是否保存引用关系   是       否
  是否跨语言         否       是
  是否可读           否       是
  是否安全           否       是

JSON 适合：

-   数据交换
-   配置文件
-   跨语言接口

pickle 适合：

-   Python 内部缓存
-   临时状态保存
-   快速原型

不适合作为长期数据存储或公共数据格式。

------------------------------------------------------------------------

七、安全性问题（非常重要）

pickle.load() 在反序列化过程中：

  会执行对象构造相关的代码

这意味着：

-   反序列化恶意 pickle 文件可以执行任意代码
-   等价于运行不可信脚本

因此：

-   不要从不可信来源加载 pickle
-   不要用于网络公开接口
-   不要作为用户上传数据的解析格式

如果需要安全格式，应使用：

-   JSON
-   MessagePack
-   Protocol Buffers

------------------------------------------------------------------------

八、工程实践建议

1.  pickle 适合：
    -   同一项目内部使用
    -   快速保存复杂 Python 对象
2.  不适合：
    -   跨项目长期数据资产
    -   数据集分发
    -   公共接口协议
3.  对长期存储的数据：
    -   数值数据使用专用格式（如 .npy, .npz）
    -   结构化信息使用 JSON / YAML
4.  避免：
    -   用类对象或 Enum 作为 dict 的 key
    -   在 pickle 中保存强依赖模块路径的对象

------------------------------------------------------------------------

九、小结

pickle 提供了一种强大的方式来保存和恢复 Python 对象结构，其优势在于：

-   使用简单
-   表达能力强
-   能完整恢复对象关系

但同时也存在明显局限：

-   强依赖代码结构
-   不跨语言
-   存在安全风险

因此，它更适合作为开发阶段的内部工具，而不是稳定的数据交换与存储格式。

理解这一点，有助于在工程实践中正确选择数据持久化方案。