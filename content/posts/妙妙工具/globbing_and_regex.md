---
title: "globbing and regex"
date: 2026-01-20
draft: false
---
# Globbing vs Regex：为什么会有两种“匹配语言”？

在日常开发里，我们经常把“模式匹配”混为一谈：

- `ls *.urdf`、`rm mesh_*` 这类 **globbing**（通配/路径匹配）
- `grep -E 'urdf_[0-9]+\.obj'`、`re.match(r'^urdf_\d+\.obj$')` 这类 **regex**（正则/文本匹配）

它们看起来都在“匹配”，但**诞生目的、执行位置、工程约束**完全不同，因此长期并存，且不可互相取代。

---

## 1. 一句话结论

> **Globbing 是为“选择文件集合”而生的路径匹配语言；Regex 是为“识别字符串结构”而生的通用文本匹配语言。**

这不是历史包袱，而是系统边界的理性分工：

- glob：快、可预测、安全，适配 shell 的交互与文件系统
- regex：表达力强，适配应用内部的字符串解析与结构约束

---

## 2. 两者解决的是不同问题域

### 2.1 Globbing：人机交互中的“文件集合选择”

典型需求：

- 删除所有 `.log` 文件：`rm *.log`
- 复制所有 `urdf_` 前缀文件：`cp urdf_* /dst`
- 批量处理当前目录某类资产

关键约束：

- **必须很快**：每条 shell 命令都可能触发
- **必须可预测**：用户要一眼知道会匹配哪些文件
- **必须安全**：不能因为一个模式导致卡死或难以理解的误删
- **必须能在 exec 之前展开**：shell 需要先把参数展开成文件列表再调用程序

因此 glob 的表达能力刻意保持在一个“甜点区间”：够用，但不会失控。

### 2.2 Regex：计算中的“字符串结构识别”

典型需求：

- 从日志中抽取时间戳、ID、字段
- 校验格式（IP、UUID、版本号）
- 解析协议文本、配置文本

关键目标：

- **表达能力最大化**：分组、捕获、重复次数、断言、替换
- **允许复杂约束**：结构、边界、条件
- **在程序内部执行**：对性能风险、可读性风险的容忍度更高（可控）

---

## 3. 语法与能力：差异从根上决定了“不会统一”

### 3.1 Globbing 的常见语法（有限但高频）

| 写法 | 含义 | 示例 |
|---|---|---|
| `*` | 任意长度字符 | `*.urdf` |
| `?` | 单个字符 | `file?.txt` |
| `[abc]` | 任意一个字符 | `mesh_[ab].obj` |
| `[a-z]` | 范围 | `[0-9]*.log` |
| `{a,b}` | brace expansion（shell 特性） | `file.{png,jpg}` |

> 注：`{a,b}` 属于 shell 的 brace expansion；它不是 POSIX glob 的核心，但在 bash/zsh 中非常常见。

### 3.2 Regex 的关键能力（强表达）

| 能力 | 示例 |
|---|---|
| 分组/捕获 | `(\d+)` |
| 或逻辑 | `a|b` |
| 重复次数 | `{2,5}`、`+`、`*` |
| 边界 | `^`、`$`、`\b` |
| 断言 | `(?=...)`、`(?!...)` |

---

## 4. 为什么 shell 不直接用 regex 来匹配文件？

表面上看，把 glob 升级成 regex 似乎能“一统天下”，但工程上会引发三类灾难。

### 4.1 性能与实时性：regex 的最坏情况不可控

许多 regex 引擎采用回溯模型，存在**最坏情况指数级**的模式（典型“灾难回溯”）。

如果 shell 在每次命令执行前都要对目录内容跑 regex：

- 目录大时交互卡死
- 自动补全（tab completion）失效
- 脚本性能与稳定性不可预测

glob 的匹配模型简单，可严格控制上界复杂度，更符合 shell 的实时交互要求。

### 4.2 安全与可预期性：文件操作需要“所见即所得”

考虑：

```bash
rm -rf <pattern>
```

如果 pattern 是复杂 regex：

- 用户很难凭直觉判断匹配集合
- 误删风险上升
- 展开结果难以提前验证

glob 则更接近“视觉直觉”：`*.log`、`mesh_*` 的含义足够清晰。

### 4.3 兼容性与工具链：quoting/escaping 规则会爆炸

shell 的展开链路通常类似：

> 变量展开 → 引号规则 → glob 展开 → exec

如果 glob 改成 regex：

- 需要引入更复杂的转义、引用规则
- 不同 shell 之间不可避免地产生不兼容
- 脚本可移植性下降

Unix 体系长期强调“稳定的小语言 + 组合”，而不是“单一万能语法”。

---

## 5. 反过来：为什么 regex 也不能取代 glob？

用 regex 做文件选择通常意味着：

```bash
ls | grep -E '...'
```

代价是：

- 多出额外进程（`grep`/`awk`）
- 组合管道更复杂、可读性下降
- regex 本质上只看字符串，不理解文件系统层级、路径语义、链接等
- 交互体验差（补全、错误提示等）

换句话说：regex 适合“在已有文本上做识别”，而 glob 适合“在文件系统上做选择”。

---

## 6. 一个对比例子：为什么 glob 做不到 regex 的精确性

目标：匹配 `urdf_12_v3.obj`、`urdf_99_v10.obj`。

### 6.1 glob 只能模糊

```bash
urdf_*_v*.obj
```

它无法表达：

- `_` 后必须是数字
- `v` 后必须是数字
- 版本号位数约束

### 6.2 regex 可以精确表达

```regex
^urdf_\d+_v\d+\.obj$
```

---

## 7. 工程实践：什么时候用哪一个？

### 7.1 优先用 glob 的场景

- 前缀/后缀批量处理
- 按扩展名筛选
- 文件集合规模不大或可控

Python 示例：

```python
from glob import glob
files = glob('urdf_*.obj')
```

### 7.2 使用 regex 的场景

- 文件名包含语义结构（编号、版本、参数）
- 需要校验命名合法性
- 需要从名称中提取字段

Python 示例：

```python
import re
pat = re.compile(r'^urdf_(\d+)_v(\d+)\.obj$')
```

### 7.3 推荐的混合策略（常用且高效）

> **先用 glob 缩小候选集，再用 regex 精确筛选与抽取。**

```python
from glob import glob
import os, re

pat = re.compile(r'^urdf_(\d+)_v(\d+)\.obj$')

for path in glob('urdf_*.obj'):
    name = os.path.basename(path)
    m = pat.match(name)
    if not m:
        continue
    obj_id, ver = map(int, m.groups())
    # ...处理...
```

---

## 8. 与 `rm` 相关的常见误区（快速排雷）

- `rm` / `ls` / `cp` 本身通常**不解析 regex**；它们接收到的是 shell 已展开后的参数
- `rm urdf_[0-9]+.obj` 会错，因为 `+` 不是 glob 语法

如果你确实需要“按 regex 删除”，常见做法是 `find -regex ... -delete` 或管道筛选后再删除。

---

## 9. 总结

两种匹配语言并存的根因，是它们站在不同的系统层级、服务不同的工程目标：

- **glob**：为 shell 的交互与文件系统“选对象集合”优化——快、安全、可预测
- **regex**：为应用中的字符串结构识别优化——表达力强、可抽取、可替换

试图用单一语言统一两者，要么牺牲交互安全与确定性，要么牺牲表达能力。这种分层不是偶然，而是系统设计中常见的“边界不可塌缩”。
